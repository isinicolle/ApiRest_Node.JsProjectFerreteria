
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Categorias
 * 
 */
export type Categorias = {
  id_categoria: number
  descripcion_categoria: string
  estado: boolean
}

/**
 * Model Ciudades
 * 
 */
export type Ciudades = {
  id_ciudad: number
  nombre_ciudad: string
  codigoPostal: string
  id_departamento: number
}

/**
 * Model Clientes
 * 
 */
export type Clientes = {
  id_cliente: number
  nom_cliente: string
  apellido_cliente: string
  RTN: string | null
  direccion_cliente: string
  id_ciudad: number
  tel_cliente: string
  estado: boolean
  DNI_Cliente: string
}

/**
 * Model Compras
 * 
 */
export type Compras = {
  id_compra: number
  fecha_compra: Date
  id_prov: number
  id_empleado: number
  isv: number
  descuento: number
}

/**
 * Model Departamentos
 * 
 */
export type Departamentos = {
  id_departamento: number
  nombreDepartamento: string
}

/**
 * Model DetalleCompras
 * 
 */
export type DetalleCompras = {
  id_detalleCompra: number
  id_producto: number
  id_compra: number
  precio: number
  cantidad: number
}

/**
 * Model DetallesVentas
 * 
 */
export type DetallesVentas = {
  id_detalleVenta: number
  id_producto: number
  id_venta: number
  precio: number
  cantidad: number
}

/**
 * Model DireccionesEnvio
 * 
 */
export type DireccionesEnvio = {
  id_direccionEnvio: number
  direccion: string
  id_ciudad: number
  id_usuarioCliente: number
  direccion_opcional: string
}

/**
 * Model Empleados
 * 
 */
export type Empleados = {
  id_empleado: number
  nom_empleado: string
  apellido_empleado: string
  telefono_empleado: string
  direccion_empleado: string
  id_ciudad: number
  id_rol: number
  fnacimiento_empleado: number
  Estado: boolean
}

/**
 * Model EmpresasEnvio
 * 
 */
export type EmpresasEnvio = {
  id_empresaEnvio: number
  nombre_empresa: string
  direccion_empresa: string
  telefono_empresa: string
  id_ciudad: number
  estado: boolean
  correo_empresa: string
}

/**
 * Model Envios
 * 
 */
export type Envios = {
  id_envio: number
  num_rastreo: string
  id_venta: number
  id_empresaEnvio: number
}

/**
 * Model Marcas
 * 
 */
export type Marcas = {
  id_marca: number
  descripcion_marca: string
  estado: boolean
}

/**
 * Model Productos
 * 
 */
export type Productos = {
  id_producto: number
  descripcion_producto: string
  id_marca: number
  id_categoria: number
  id_proveedor: number
  cantidad_por_unidad: string
  costo_producto: number
  precio_actual: number
  stock: number
  descuento: number | null
  estado: boolean
  imagen: string | null
}

/**
 * Model Proveedores
 * 
 */
export type Proveedores = {
  id_prov: number
  nom_prov: string
  telefono_prov: string
  correo_prov: string
  direccion_prov: string
  id_ciudad: number
  Estado: boolean
}

/**
 * Model RolesEmpleados
 * 
 */
export type RolesEmpleados = {
  id_rol: number
  descripcion: string
}

/**
 * Model sysdiagrams
 * 
 */
export type sysdiagrams = {
  name: string
  principal_id: number
  diagram_id: number
  version: number | null
  definition: Buffer | null
}

/**
 * Model UsuarioEmpleados
 * 
 */
export type UsuarioEmpleados = {
  id_usuarioEmpleado: number
  nom_usuarioEmpleado: string
  estado: boolean
  contrasenia_empleado: string
  correo_empleado: string
  id_empleado: number
}

/**
 * Model usuariosClientes
 * 
 */
export type usuariosClientes = {
  id_usuarioCliente: number
  nombre_usuario: string
  contraenia_usuario: string
  id_cliente: number
  correo_usuario: string
  estado: boolean
}

/**
 * Model Venta
 * 
 */
export type Venta = {
  id_Venta: number
  fecha: Date
  id_cliente: number
  RTN_estado: boolean
  ISV: number
  id_direccionEnvio: number
  descuento: number
}

/**
 * Model Carrito
 * 
 */
export type Carrito = {
  id_carrito: number
  id_usuarioCliente: number
}

/**
 * Model CarritoItem
 * 
 */
export type CarritoItem = {
  id_itemCarrito: number
  id_Carrito: number
  id_producto: number
  cantidad: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categorias
 * const categorias = await prisma.categorias.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categorias
   * const categorias = await prisma.categorias.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.categorias`: Exposes CRUD operations for the **Categorias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categorias.findMany()
    * ```
    */
  get categorias(): Prisma.CategoriasDelegate<GlobalReject>;

  /**
   * `prisma.ciudades`: Exposes CRUD operations for the **Ciudades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ciudades
    * const ciudades = await prisma.ciudades.findMany()
    * ```
    */
  get ciudades(): Prisma.CiudadesDelegate<GlobalReject>;

  /**
   * `prisma.clientes`: Exposes CRUD operations for the **Clientes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.clientes.findMany()
    * ```
    */
  get clientes(): Prisma.ClientesDelegate<GlobalReject>;

  /**
   * `prisma.compras`: Exposes CRUD operations for the **Compras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Compras
    * const compras = await prisma.compras.findMany()
    * ```
    */
  get compras(): Prisma.ComprasDelegate<GlobalReject>;

  /**
   * `prisma.departamentos`: Exposes CRUD operations for the **Departamentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departamentos
    * const departamentos = await prisma.departamentos.findMany()
    * ```
    */
  get departamentos(): Prisma.DepartamentosDelegate<GlobalReject>;

  /**
   * `prisma.detalleCompras`: Exposes CRUD operations for the **DetalleCompras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetalleCompras
    * const detalleCompras = await prisma.detalleCompras.findMany()
    * ```
    */
  get detalleCompras(): Prisma.DetalleComprasDelegate<GlobalReject>;

  /**
   * `prisma.detallesVentas`: Exposes CRUD operations for the **DetallesVentas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetallesVentas
    * const detallesVentas = await prisma.detallesVentas.findMany()
    * ```
    */
  get detallesVentas(): Prisma.DetallesVentasDelegate<GlobalReject>;

  /**
   * `prisma.direccionesEnvio`: Exposes CRUD operations for the **DireccionesEnvio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DireccionesEnvios
    * const direccionesEnvios = await prisma.direccionesEnvio.findMany()
    * ```
    */
  get direccionesEnvio(): Prisma.DireccionesEnvioDelegate<GlobalReject>;

  /**
   * `prisma.empleados`: Exposes CRUD operations for the **Empleados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleados
    * const empleados = await prisma.empleados.findMany()
    * ```
    */
  get empleados(): Prisma.EmpleadosDelegate<GlobalReject>;

  /**
   * `prisma.empresasEnvio`: Exposes CRUD operations for the **EmpresasEnvio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmpresasEnvios
    * const empresasEnvios = await prisma.empresasEnvio.findMany()
    * ```
    */
  get empresasEnvio(): Prisma.EmpresasEnvioDelegate<GlobalReject>;

  /**
   * `prisma.envios`: Exposes CRUD operations for the **Envios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Envios
    * const envios = await prisma.envios.findMany()
    * ```
    */
  get envios(): Prisma.EnviosDelegate<GlobalReject>;

  /**
   * `prisma.marcas`: Exposes CRUD operations for the **Marcas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marcas
    * const marcas = await prisma.marcas.findMany()
    * ```
    */
  get marcas(): Prisma.MarcasDelegate<GlobalReject>;

  /**
   * `prisma.productos`: Exposes CRUD operations for the **Productos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.productos.findMany()
    * ```
    */
  get productos(): Prisma.ProductosDelegate<GlobalReject>;

  /**
   * `prisma.proveedores`: Exposes CRUD operations for the **Proveedores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedores
    * const proveedores = await prisma.proveedores.findMany()
    * ```
    */
  get proveedores(): Prisma.ProveedoresDelegate<GlobalReject>;

  /**
   * `prisma.rolesEmpleados`: Exposes CRUD operations for the **RolesEmpleados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolesEmpleados
    * const rolesEmpleados = await prisma.rolesEmpleados.findMany()
    * ```
    */
  get rolesEmpleados(): Prisma.RolesEmpleadosDelegate<GlobalReject>;

  /**
   * `prisma.sysdiagrams`: Exposes CRUD operations for the **sysdiagrams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sysdiagrams
    * const sysdiagrams = await prisma.sysdiagrams.findMany()
    * ```
    */
  get sysdiagrams(): Prisma.sysdiagramsDelegate<GlobalReject>;

  /**
   * `prisma.usuarioEmpleados`: Exposes CRUD operations for the **UsuarioEmpleados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuarioEmpleados
    * const usuarioEmpleados = await prisma.usuarioEmpleados.findMany()
    * ```
    */
  get usuarioEmpleados(): Prisma.UsuarioEmpleadosDelegate<GlobalReject>;

  /**
   * `prisma.usuariosClientes`: Exposes CRUD operations for the **usuariosClientes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuariosClientes
    * const usuariosClientes = await prisma.usuariosClientes.findMany()
    * ```
    */
  get usuariosClientes(): Prisma.usuariosClientesDelegate<GlobalReject>;

  /**
   * `prisma.venta`: Exposes CRUD operations for the **Venta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ventas
    * const ventas = await prisma.venta.findMany()
    * ```
    */
  get venta(): Prisma.VentaDelegate<GlobalReject>;

  /**
   * `prisma.carrito`: Exposes CRUD operations for the **Carrito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carritos
    * const carritos = await prisma.carrito.findMany()
    * ```
    */
  get carrito(): Prisma.CarritoDelegate<GlobalReject>;

  /**
   * `prisma.carritoItem`: Exposes CRUD operations for the **CarritoItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CarritoItems
    * const carritoItems = await prisma.carritoItem.findMany()
    * ```
    */
  get carritoItem(): Prisma.CarritoItemDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.10.0
   * Query Engine version: 73e60b76d394f8d37d8ebd1f8918c79029f0db86
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Categorias: 'Categorias',
    Ciudades: 'Ciudades',
    Clientes: 'Clientes',
    Compras: 'Compras',
    Departamentos: 'Departamentos',
    DetalleCompras: 'DetalleCompras',
    DetallesVentas: 'DetallesVentas',
    DireccionesEnvio: 'DireccionesEnvio',
    Empleados: 'Empleados',
    EmpresasEnvio: 'EmpresasEnvio',
    Envios: 'Envios',
    Marcas: 'Marcas',
    Productos: 'Productos',
    Proveedores: 'Proveedores',
    RolesEmpleados: 'RolesEmpleados',
    sysdiagrams: 'sysdiagrams',
    UsuarioEmpleados: 'UsuarioEmpleados',
    usuariosClientes: 'usuariosClientes',
    Venta: 'Venta',
    Carrito: 'Carrito',
    CarritoItem: 'CarritoItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriasCountOutputType
   */


  export type CategoriasCountOutputType = {
    Productos: number
  }

  export type CategoriasCountOutputTypeSelect = {
    Productos?: boolean
  }

  export type CategoriasCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CategoriasCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CategoriasCountOutputType
    : S extends undefined
    ? never
    : S extends CategoriasCountOutputTypeArgs
    ?'include' extends U
    ? CategoriasCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CategoriasCountOutputType ? CategoriasCountOutputType[P] : never
  } 
    : CategoriasCountOutputType
  : CategoriasCountOutputType




  // Custom InputTypes

  /**
   * CategoriasCountOutputType without action
   */
  export type CategoriasCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoriasCountOutputType
     * 
    **/
    select?: CategoriasCountOutputTypeSelect | null
  }



  /**
   * Count Type CiudadesCountOutputType
   */


  export type CiudadesCountOutputType = {
    Clientes: number
    DireccionesEnvio: number
    Empleados: number
    EmpresasEnvio: number
    Proveedores: number
  }

  export type CiudadesCountOutputTypeSelect = {
    Clientes?: boolean
    DireccionesEnvio?: boolean
    Empleados?: boolean
    EmpresasEnvio?: boolean
    Proveedores?: boolean
  }

  export type CiudadesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CiudadesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CiudadesCountOutputType
    : S extends undefined
    ? never
    : S extends CiudadesCountOutputTypeArgs
    ?'include' extends U
    ? CiudadesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CiudadesCountOutputType ? CiudadesCountOutputType[P] : never
  } 
    : CiudadesCountOutputType
  : CiudadesCountOutputType




  // Custom InputTypes

  /**
   * CiudadesCountOutputType without action
   */
  export type CiudadesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CiudadesCountOutputType
     * 
    **/
    select?: CiudadesCountOutputTypeSelect | null
  }



  /**
   * Count Type ClientesCountOutputType
   */


  export type ClientesCountOutputType = {
    usuariosClientes: number
    Venta: number
  }

  export type ClientesCountOutputTypeSelect = {
    usuariosClientes?: boolean
    Venta?: boolean
  }

  export type ClientesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ClientesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ClientesCountOutputType
    : S extends undefined
    ? never
    : S extends ClientesCountOutputTypeArgs
    ?'include' extends U
    ? ClientesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ClientesCountOutputType ? ClientesCountOutputType[P] : never
  } 
    : ClientesCountOutputType
  : ClientesCountOutputType




  // Custom InputTypes

  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClientesCountOutputType
     * 
    **/
    select?: ClientesCountOutputTypeSelect | null
  }



  /**
   * Count Type ComprasCountOutputType
   */


  export type ComprasCountOutputType = {
    DetalleCompras: number
  }

  export type ComprasCountOutputTypeSelect = {
    DetalleCompras?: boolean
  }

  export type ComprasCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ComprasCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ComprasCountOutputType
    : S extends undefined
    ? never
    : S extends ComprasCountOutputTypeArgs
    ?'include' extends U
    ? ComprasCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ComprasCountOutputType ? ComprasCountOutputType[P] : never
  } 
    : ComprasCountOutputType
  : ComprasCountOutputType




  // Custom InputTypes

  /**
   * ComprasCountOutputType without action
   */
  export type ComprasCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ComprasCountOutputType
     * 
    **/
    select?: ComprasCountOutputTypeSelect | null
  }



  /**
   * Count Type DepartamentosCountOutputType
   */


  export type DepartamentosCountOutputType = {
    Ciudades: number
  }

  export type DepartamentosCountOutputTypeSelect = {
    Ciudades?: boolean
  }

  export type DepartamentosCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DepartamentosCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DepartamentosCountOutputType
    : S extends undefined
    ? never
    : S extends DepartamentosCountOutputTypeArgs
    ?'include' extends U
    ? DepartamentosCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DepartamentosCountOutputType ? DepartamentosCountOutputType[P] : never
  } 
    : DepartamentosCountOutputType
  : DepartamentosCountOutputType




  // Custom InputTypes

  /**
   * DepartamentosCountOutputType without action
   */
  export type DepartamentosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DepartamentosCountOutputType
     * 
    **/
    select?: DepartamentosCountOutputTypeSelect | null
  }



  /**
   * Count Type DireccionesEnvioCountOutputType
   */


  export type DireccionesEnvioCountOutputType = {
    Venta: number
  }

  export type DireccionesEnvioCountOutputTypeSelect = {
    Venta?: boolean
  }

  export type DireccionesEnvioCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DireccionesEnvioCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DireccionesEnvioCountOutputType
    : S extends undefined
    ? never
    : S extends DireccionesEnvioCountOutputTypeArgs
    ?'include' extends U
    ? DireccionesEnvioCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DireccionesEnvioCountOutputType ? DireccionesEnvioCountOutputType[P] : never
  } 
    : DireccionesEnvioCountOutputType
  : DireccionesEnvioCountOutputType




  // Custom InputTypes

  /**
   * DireccionesEnvioCountOutputType without action
   */
  export type DireccionesEnvioCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DireccionesEnvioCountOutputType
     * 
    **/
    select?: DireccionesEnvioCountOutputTypeSelect | null
  }



  /**
   * Count Type EmpleadosCountOutputType
   */


  export type EmpleadosCountOutputType = {
    Compras: number
    UsuarioEmpleados: number
  }

  export type EmpleadosCountOutputTypeSelect = {
    Compras?: boolean
    UsuarioEmpleados?: boolean
  }

  export type EmpleadosCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EmpleadosCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EmpleadosCountOutputType
    : S extends undefined
    ? never
    : S extends EmpleadosCountOutputTypeArgs
    ?'include' extends U
    ? EmpleadosCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EmpleadosCountOutputType ? EmpleadosCountOutputType[P] : never
  } 
    : EmpleadosCountOutputType
  : EmpleadosCountOutputType




  // Custom InputTypes

  /**
   * EmpleadosCountOutputType without action
   */
  export type EmpleadosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EmpleadosCountOutputType
     * 
    **/
    select?: EmpleadosCountOutputTypeSelect | null
  }



  /**
   * Count Type EmpresasEnvioCountOutputType
   */


  export type EmpresasEnvioCountOutputType = {
    Envios: number
  }

  export type EmpresasEnvioCountOutputTypeSelect = {
    Envios?: boolean
  }

  export type EmpresasEnvioCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EmpresasEnvioCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EmpresasEnvioCountOutputType
    : S extends undefined
    ? never
    : S extends EmpresasEnvioCountOutputTypeArgs
    ?'include' extends U
    ? EmpresasEnvioCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EmpresasEnvioCountOutputType ? EmpresasEnvioCountOutputType[P] : never
  } 
    : EmpresasEnvioCountOutputType
  : EmpresasEnvioCountOutputType




  // Custom InputTypes

  /**
   * EmpresasEnvioCountOutputType without action
   */
  export type EmpresasEnvioCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EmpresasEnvioCountOutputType
     * 
    **/
    select?: EmpresasEnvioCountOutputTypeSelect | null
  }



  /**
   * Count Type MarcasCountOutputType
   */


  export type MarcasCountOutputType = {
    Productos: number
  }

  export type MarcasCountOutputTypeSelect = {
    Productos?: boolean
  }

  export type MarcasCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MarcasCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MarcasCountOutputType
    : S extends undefined
    ? never
    : S extends MarcasCountOutputTypeArgs
    ?'include' extends U
    ? MarcasCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MarcasCountOutputType ? MarcasCountOutputType[P] : never
  } 
    : MarcasCountOutputType
  : MarcasCountOutputType




  // Custom InputTypes

  /**
   * MarcasCountOutputType without action
   */
  export type MarcasCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MarcasCountOutputType
     * 
    **/
    select?: MarcasCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductosCountOutputType
   */


  export type ProductosCountOutputType = {
    CarritoItem: number
    DetalleCompras: number
    DetallesVentas: number
  }

  export type ProductosCountOutputTypeSelect = {
    CarritoItem?: boolean
    DetalleCompras?: boolean
    DetallesVentas?: boolean
  }

  export type ProductosCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductosCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductosCountOutputType
    : S extends undefined
    ? never
    : S extends ProductosCountOutputTypeArgs
    ?'include' extends U
    ? ProductosCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductosCountOutputType ? ProductosCountOutputType[P] : never
  } 
    : ProductosCountOutputType
  : ProductosCountOutputType




  // Custom InputTypes

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductosCountOutputType
     * 
    **/
    select?: ProductosCountOutputTypeSelect | null
  }



  /**
   * Count Type ProveedoresCountOutputType
   */


  export type ProveedoresCountOutputType = {
    Compras: number
    Productos: number
  }

  export type ProveedoresCountOutputTypeSelect = {
    Compras?: boolean
    Productos?: boolean
  }

  export type ProveedoresCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProveedoresCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProveedoresCountOutputType
    : S extends undefined
    ? never
    : S extends ProveedoresCountOutputTypeArgs
    ?'include' extends U
    ? ProveedoresCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProveedoresCountOutputType ? ProveedoresCountOutputType[P] : never
  } 
    : ProveedoresCountOutputType
  : ProveedoresCountOutputType




  // Custom InputTypes

  /**
   * ProveedoresCountOutputType without action
   */
  export type ProveedoresCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProveedoresCountOutputType
     * 
    **/
    select?: ProveedoresCountOutputTypeSelect | null
  }



  /**
   * Count Type RolesEmpleadosCountOutputType
   */


  export type RolesEmpleadosCountOutputType = {
    Empleados: number
  }

  export type RolesEmpleadosCountOutputTypeSelect = {
    Empleados?: boolean
  }

  export type RolesEmpleadosCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RolesEmpleadosCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RolesEmpleadosCountOutputType
    : S extends undefined
    ? never
    : S extends RolesEmpleadosCountOutputTypeArgs
    ?'include' extends U
    ? RolesEmpleadosCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RolesEmpleadosCountOutputType ? RolesEmpleadosCountOutputType[P] : never
  } 
    : RolesEmpleadosCountOutputType
  : RolesEmpleadosCountOutputType




  // Custom InputTypes

  /**
   * RolesEmpleadosCountOutputType without action
   */
  export type RolesEmpleadosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RolesEmpleadosCountOutputType
     * 
    **/
    select?: RolesEmpleadosCountOutputTypeSelect | null
  }



  /**
   * Count Type UsuariosClientesCountOutputType
   */


  export type UsuariosClientesCountOutputType = {
    Carrito: number
    DireccionesEnvio: number
  }

  export type UsuariosClientesCountOutputTypeSelect = {
    Carrito?: boolean
    DireccionesEnvio?: boolean
  }

  export type UsuariosClientesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsuariosClientesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsuariosClientesCountOutputType
    : S extends undefined
    ? never
    : S extends UsuariosClientesCountOutputTypeArgs
    ?'include' extends U
    ? UsuariosClientesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsuariosClientesCountOutputType ? UsuariosClientesCountOutputType[P] : never
  } 
    : UsuariosClientesCountOutputType
  : UsuariosClientesCountOutputType




  // Custom InputTypes

  /**
   * UsuariosClientesCountOutputType without action
   */
  export type UsuariosClientesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsuariosClientesCountOutputType
     * 
    **/
    select?: UsuariosClientesCountOutputTypeSelect | null
  }



  /**
   * Count Type VentaCountOutputType
   */


  export type VentaCountOutputType = {
    DetallesVentas: number
    Envios: number
  }

  export type VentaCountOutputTypeSelect = {
    DetallesVentas?: boolean
    Envios?: boolean
  }

  export type VentaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | VentaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? VentaCountOutputType
    : S extends undefined
    ? never
    : S extends VentaCountOutputTypeArgs
    ?'include' extends U
    ? VentaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof VentaCountOutputType ? VentaCountOutputType[P] : never
  } 
    : VentaCountOutputType
  : VentaCountOutputType




  // Custom InputTypes

  /**
   * VentaCountOutputType without action
   */
  export type VentaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VentaCountOutputType
     * 
    **/
    select?: VentaCountOutputTypeSelect | null
  }



  /**
   * Count Type CarritoCountOutputType
   */


  export type CarritoCountOutputType = {
    CarritoItem: number
  }

  export type CarritoCountOutputTypeSelect = {
    CarritoItem?: boolean
  }

  export type CarritoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CarritoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CarritoCountOutputType
    : S extends undefined
    ? never
    : S extends CarritoCountOutputTypeArgs
    ?'include' extends U
    ? CarritoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CarritoCountOutputType ? CarritoCountOutputType[P] : never
  } 
    : CarritoCountOutputType
  : CarritoCountOutputType




  // Custom InputTypes

  /**
   * CarritoCountOutputType without action
   */
  export type CarritoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CarritoCountOutputType
     * 
    **/
    select?: CarritoCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Categorias
   */


  export type AggregateCategorias = {
    _count: CategoriasCountAggregateOutputType | null
    _avg: CategoriasAvgAggregateOutputType | null
    _sum: CategoriasSumAggregateOutputType | null
    _min: CategoriasMinAggregateOutputType | null
    _max: CategoriasMaxAggregateOutputType | null
  }

  export type CategoriasAvgAggregateOutputType = {
    id_categoria: number | null
  }

  export type CategoriasSumAggregateOutputType = {
    id_categoria: number | null
  }

  export type CategoriasMinAggregateOutputType = {
    id_categoria: number | null
    descripcion_categoria: string | null
    estado: boolean | null
  }

  export type CategoriasMaxAggregateOutputType = {
    id_categoria: number | null
    descripcion_categoria: string | null
    estado: boolean | null
  }

  export type CategoriasCountAggregateOutputType = {
    id_categoria: number
    descripcion_categoria: number
    estado: number
    _all: number
  }


  export type CategoriasAvgAggregateInputType = {
    id_categoria?: true
  }

  export type CategoriasSumAggregateInputType = {
    id_categoria?: true
  }

  export type CategoriasMinAggregateInputType = {
    id_categoria?: true
    descripcion_categoria?: true
    estado?: true
  }

  export type CategoriasMaxAggregateInputType = {
    id_categoria?: true
    descripcion_categoria?: true
    estado?: true
  }

  export type CategoriasCountAggregateInputType = {
    id_categoria?: true
    descripcion_categoria?: true
    estado?: true
    _all?: true
  }

  export type CategoriasAggregateArgs = {
    /**
     * Filter which Categorias to aggregate.
     * 
    **/
    where?: CategoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriasMaxAggregateInputType
  }

  export type GetCategoriasAggregateType<T extends CategoriasAggregateArgs> = {
        [P in keyof T & keyof AggregateCategorias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategorias[P]>
      : GetScalarType<T[P], AggregateCategorias[P]>
  }




  export type CategoriasGroupByArgs = {
    where?: CategoriasWhereInput
    orderBy?: Enumerable<CategoriasOrderByWithAggregationInput>
    by: Array<CategoriasScalarFieldEnum>
    having?: CategoriasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriasCountAggregateInputType | true
    _avg?: CategoriasAvgAggregateInputType
    _sum?: CategoriasSumAggregateInputType
    _min?: CategoriasMinAggregateInputType
    _max?: CategoriasMaxAggregateInputType
  }


  export type CategoriasGroupByOutputType = {
    id_categoria: number
    descripcion_categoria: string
    estado: boolean
    _count: CategoriasCountAggregateOutputType | null
    _avg: CategoriasAvgAggregateOutputType | null
    _sum: CategoriasSumAggregateOutputType | null
    _min: CategoriasMinAggregateOutputType | null
    _max: CategoriasMaxAggregateOutputType | null
  }

  type GetCategoriasGroupByPayload<T extends CategoriasGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoriasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriasGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriasGroupByOutputType[P]>
        }
      >
    >


  export type CategoriasSelect = {
    id_categoria?: boolean
    descripcion_categoria?: boolean
    estado?: boolean
    Productos?: boolean | ProductosFindManyArgs
    _count?: boolean | CategoriasCountOutputTypeArgs
  }

  export type CategoriasInclude = {
    Productos?: boolean | ProductosFindManyArgs
    _count?: boolean | CategoriasCountOutputTypeArgs
  }

  export type CategoriasGetPayload<
    S extends boolean | null | undefined | CategoriasArgs,
    U = keyof S
      > = S extends true
        ? Categorias
    : S extends undefined
    ? never
    : S extends CategoriasArgs | CategoriasFindManyArgs
    ?'include' extends U
    ? Categorias  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Productos' ? Array < ProductosGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoriasCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Productos' ? Array < ProductosGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoriasCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Categorias ? Categorias[P] : never
  } 
    : Categorias
  : Categorias


  type CategoriasCountArgs = Merge<
    Omit<CategoriasFindManyArgs, 'select' | 'include'> & {
      select?: CategoriasCountAggregateInputType | true
    }
  >

  export interface CategoriasDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Categorias that matches the filter.
     * @param {CategoriasFindUniqueArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoriasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Categorias'> extends True ? CheckSelect<T, Prisma__CategoriasClient<Categorias>, Prisma__CategoriasClient<CategoriasGetPayload<T>>> : CheckSelect<T, Prisma__CategoriasClient<Categorias | null >, Prisma__CategoriasClient<CategoriasGetPayload<T> | null >>

    /**
     * Find the first Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasFindFirstArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoriasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Categorias'> extends True ? CheckSelect<T, Prisma__CategoriasClient<Categorias>, Prisma__CategoriasClient<CategoriasGetPayload<T>>> : CheckSelect<T, Prisma__CategoriasClient<Categorias | null >, Prisma__CategoriasClient<CategoriasGetPayload<T> | null >>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categorias.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categorias.findMany({ take: 10 })
     * 
     * // Only select the `id_categoria`
     * const categoriasWithId_categoriaOnly = await prisma.categorias.findMany({ select: { id_categoria: true } })
     * 
    **/
    findMany<T extends CategoriasFindManyArgs>(
      args?: SelectSubset<T, CategoriasFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Categorias>>, PrismaPromise<Array<CategoriasGetPayload<T>>>>

    /**
     * Create a Categorias.
     * @param {CategoriasCreateArgs} args - Arguments to create a Categorias.
     * @example
     * // Create one Categorias
     * const Categorias = await prisma.categorias.create({
     *   data: {
     *     // ... data to create a Categorias
     *   }
     * })
     * 
    **/
    create<T extends CategoriasCreateArgs>(
      args: SelectSubset<T, CategoriasCreateArgs>
    ): CheckSelect<T, Prisma__CategoriasClient<Categorias>, Prisma__CategoriasClient<CategoriasGetPayload<T>>>

    /**
     * Create many Categorias.
     *     @param {CategoriasCreateManyArgs} args - Arguments to create many Categorias.
     *     @example
     *     // Create many Categorias
     *     const categorias = await prisma.categorias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoriasCreateManyArgs>(
      args?: SelectSubset<T, CategoriasCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Categorias.
     * @param {CategoriasDeleteArgs} args - Arguments to delete one Categorias.
     * @example
     * // Delete one Categorias
     * const Categorias = await prisma.categorias.delete({
     *   where: {
     *     // ... filter to delete one Categorias
     *   }
     * })
     * 
    **/
    delete<T extends CategoriasDeleteArgs>(
      args: SelectSubset<T, CategoriasDeleteArgs>
    ): CheckSelect<T, Prisma__CategoriasClient<Categorias>, Prisma__CategoriasClient<CategoriasGetPayload<T>>>

    /**
     * Update one Categorias.
     * @param {CategoriasUpdateArgs} args - Arguments to update one Categorias.
     * @example
     * // Update one Categorias
     * const categorias = await prisma.categorias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriasUpdateArgs>(
      args: SelectSubset<T, CategoriasUpdateArgs>
    ): CheckSelect<T, Prisma__CategoriasClient<Categorias>, Prisma__CategoriasClient<CategoriasGetPayload<T>>>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriasDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categorias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriasDeleteManyArgs>(
      args?: SelectSubset<T, CategoriasDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categorias = await prisma.categorias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriasUpdateManyArgs>(
      args: SelectSubset<T, CategoriasUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Categorias.
     * @param {CategoriasUpsertArgs} args - Arguments to update or create a Categorias.
     * @example
     * // Update or create a Categorias
     * const categorias = await prisma.categorias.upsert({
     *   create: {
     *     // ... data to create a Categorias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categorias we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriasUpsertArgs>(
      args: SelectSubset<T, CategoriasUpsertArgs>
    ): CheckSelect<T, Prisma__CategoriasClient<Categorias>, Prisma__CategoriasClient<CategoriasGetPayload<T>>>

    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categorias.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriasCountArgs>(
      args?: Subset<T, CategoriasCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriasAggregateArgs>(args: Subset<T, CategoriasAggregateArgs>): PrismaPromise<GetCategoriasAggregateType<T>>

    /**
     * Group by Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriasGroupByArgs['orderBy'] }
        : { orderBy?: CategoriasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriasGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categorias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoriasClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Productos<T extends ProductosFindManyArgs = {}>(args?: Subset<T, ProductosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Productos>>, PrismaPromise<Array<ProductosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Categorias findUnique
   */
  export type CategoriasFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Categorias
     * 
    **/
    select?: CategoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriasInclude | null
    /**
     * Throw an Error if a Categorias can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Categorias to fetch.
     * 
    **/
    where: CategoriasWhereUniqueInput
  }


  /**
   * Categorias findFirst
   */
  export type CategoriasFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Categorias
     * 
    **/
    select?: CategoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriasInclude | null
    /**
     * Throw an Error if a Categorias can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Categorias to fetch.
     * 
    **/
    where?: CategoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     * 
    **/
    cursor?: CategoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     * 
    **/
    distinct?: Enumerable<CategoriasScalarFieldEnum>
  }


  /**
   * Categorias findMany
   */
  export type CategoriasFindManyArgs = {
    /**
     * Select specific fields to fetch from the Categorias
     * 
    **/
    select?: CategoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriasInclude | null
    /**
     * Filter, which Categorias to fetch.
     * 
    **/
    where?: CategoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     * 
    **/
    cursor?: CategoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoriasScalarFieldEnum>
  }


  /**
   * Categorias create
   */
  export type CategoriasCreateArgs = {
    /**
     * Select specific fields to fetch from the Categorias
     * 
    **/
    select?: CategoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriasInclude | null
    /**
     * The data needed to create a Categorias.
     * 
    **/
    data: XOR<CategoriasCreateInput, CategoriasUncheckedCreateInput>
  }


  /**
   * Categorias createMany
   */
  export type CategoriasCreateManyArgs = {
    /**
     * The data used to create many Categorias.
     * 
    **/
    data: Enumerable<CategoriasCreateManyInput>
  }


  /**
   * Categorias update
   */
  export type CategoriasUpdateArgs = {
    /**
     * Select specific fields to fetch from the Categorias
     * 
    **/
    select?: CategoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriasInclude | null
    /**
     * The data needed to update a Categorias.
     * 
    **/
    data: XOR<CategoriasUpdateInput, CategoriasUncheckedUpdateInput>
    /**
     * Choose, which Categorias to update.
     * 
    **/
    where: CategoriasWhereUniqueInput
  }


  /**
   * Categorias updateMany
   */
  export type CategoriasUpdateManyArgs = {
    /**
     * The data used to update Categorias.
     * 
    **/
    data: XOR<CategoriasUpdateManyMutationInput, CategoriasUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     * 
    **/
    where?: CategoriasWhereInput
  }


  /**
   * Categorias upsert
   */
  export type CategoriasUpsertArgs = {
    /**
     * Select specific fields to fetch from the Categorias
     * 
    **/
    select?: CategoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriasInclude | null
    /**
     * The filter to search for the Categorias to update in case it exists.
     * 
    **/
    where: CategoriasWhereUniqueInput
    /**
     * In case the Categorias found by the `where` argument doesn't exist, create a new Categorias with this data.
     * 
    **/
    create: XOR<CategoriasCreateInput, CategoriasUncheckedCreateInput>
    /**
     * In case the Categorias was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoriasUpdateInput, CategoriasUncheckedUpdateInput>
  }


  /**
   * Categorias delete
   */
  export type CategoriasDeleteArgs = {
    /**
     * Select specific fields to fetch from the Categorias
     * 
    **/
    select?: CategoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriasInclude | null
    /**
     * Filter which Categorias to delete.
     * 
    **/
    where: CategoriasWhereUniqueInput
  }


  /**
   * Categorias deleteMany
   */
  export type CategoriasDeleteManyArgs = {
    /**
     * Filter which Categorias to delete
     * 
    **/
    where?: CategoriasWhereInput
  }


  /**
   * Categorias without action
   */
  export type CategoriasArgs = {
    /**
     * Select specific fields to fetch from the Categorias
     * 
    **/
    select?: CategoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriasInclude | null
  }



  /**
   * Model Ciudades
   */


  export type AggregateCiudades = {
    _count: CiudadesCountAggregateOutputType | null
    _avg: CiudadesAvgAggregateOutputType | null
    _sum: CiudadesSumAggregateOutputType | null
    _min: CiudadesMinAggregateOutputType | null
    _max: CiudadesMaxAggregateOutputType | null
  }

  export type CiudadesAvgAggregateOutputType = {
    id_ciudad: number | null
    id_departamento: number | null
  }

  export type CiudadesSumAggregateOutputType = {
    id_ciudad: number | null
    id_departamento: number | null
  }

  export type CiudadesMinAggregateOutputType = {
    id_ciudad: number | null
    nombre_ciudad: string | null
    codigoPostal: string | null
    id_departamento: number | null
  }

  export type CiudadesMaxAggregateOutputType = {
    id_ciudad: number | null
    nombre_ciudad: string | null
    codigoPostal: string | null
    id_departamento: number | null
  }

  export type CiudadesCountAggregateOutputType = {
    id_ciudad: number
    nombre_ciudad: number
    codigoPostal: number
    id_departamento: number
    _all: number
  }


  export type CiudadesAvgAggregateInputType = {
    id_ciudad?: true
    id_departamento?: true
  }

  export type CiudadesSumAggregateInputType = {
    id_ciudad?: true
    id_departamento?: true
  }

  export type CiudadesMinAggregateInputType = {
    id_ciudad?: true
    nombre_ciudad?: true
    codigoPostal?: true
    id_departamento?: true
  }

  export type CiudadesMaxAggregateInputType = {
    id_ciudad?: true
    nombre_ciudad?: true
    codigoPostal?: true
    id_departamento?: true
  }

  export type CiudadesCountAggregateInputType = {
    id_ciudad?: true
    nombre_ciudad?: true
    codigoPostal?: true
    id_departamento?: true
    _all?: true
  }

  export type CiudadesAggregateArgs = {
    /**
     * Filter which Ciudades to aggregate.
     * 
    **/
    where?: CiudadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ciudades to fetch.
     * 
    **/
    orderBy?: Enumerable<CiudadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CiudadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ciudades from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ciudades.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ciudades
    **/
    _count?: true | CiudadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CiudadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CiudadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CiudadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CiudadesMaxAggregateInputType
  }

  export type GetCiudadesAggregateType<T extends CiudadesAggregateArgs> = {
        [P in keyof T & keyof AggregateCiudades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCiudades[P]>
      : GetScalarType<T[P], AggregateCiudades[P]>
  }




  export type CiudadesGroupByArgs = {
    where?: CiudadesWhereInput
    orderBy?: Enumerable<CiudadesOrderByWithAggregationInput>
    by: Array<CiudadesScalarFieldEnum>
    having?: CiudadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CiudadesCountAggregateInputType | true
    _avg?: CiudadesAvgAggregateInputType
    _sum?: CiudadesSumAggregateInputType
    _min?: CiudadesMinAggregateInputType
    _max?: CiudadesMaxAggregateInputType
  }


  export type CiudadesGroupByOutputType = {
    id_ciudad: number
    nombre_ciudad: string
    codigoPostal: string
    id_departamento: number
    _count: CiudadesCountAggregateOutputType | null
    _avg: CiudadesAvgAggregateOutputType | null
    _sum: CiudadesSumAggregateOutputType | null
    _min: CiudadesMinAggregateOutputType | null
    _max: CiudadesMaxAggregateOutputType | null
  }

  type GetCiudadesGroupByPayload<T extends CiudadesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CiudadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CiudadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CiudadesGroupByOutputType[P]>
            : GetScalarType<T[P], CiudadesGroupByOutputType[P]>
        }
      >
    >


  export type CiudadesSelect = {
    id_ciudad?: boolean
    nombre_ciudad?: boolean
    codigoPostal?: boolean
    id_departamento?: boolean
    Departamentos?: boolean | DepartamentosArgs
    Clientes?: boolean | ClientesFindManyArgs
    DireccionesEnvio?: boolean | DireccionesEnvioFindManyArgs
    Empleados?: boolean | EmpleadosFindManyArgs
    EmpresasEnvio?: boolean | EmpresasEnvioFindManyArgs
    Proveedores?: boolean | ProveedoresFindManyArgs
    _count?: boolean | CiudadesCountOutputTypeArgs
  }

  export type CiudadesInclude = {
    Departamentos?: boolean | DepartamentosArgs
    Clientes?: boolean | ClientesFindManyArgs
    DireccionesEnvio?: boolean | DireccionesEnvioFindManyArgs
    Empleados?: boolean | EmpleadosFindManyArgs
    EmpresasEnvio?: boolean | EmpresasEnvioFindManyArgs
    Proveedores?: boolean | ProveedoresFindManyArgs
    _count?: boolean | CiudadesCountOutputTypeArgs
  }

  export type CiudadesGetPayload<
    S extends boolean | null | undefined | CiudadesArgs,
    U = keyof S
      > = S extends true
        ? Ciudades
    : S extends undefined
    ? never
    : S extends CiudadesArgs | CiudadesFindManyArgs
    ?'include' extends U
    ? Ciudades  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Departamentos' ? DepartamentosGetPayload<S['include'][P]> :
        P extends 'Clientes' ? Array < ClientesGetPayload<S['include'][P]>>  :
        P extends 'DireccionesEnvio' ? Array < DireccionesEnvioGetPayload<S['include'][P]>>  :
        P extends 'Empleados' ? Array < EmpleadosGetPayload<S['include'][P]>>  :
        P extends 'EmpresasEnvio' ? Array < EmpresasEnvioGetPayload<S['include'][P]>>  :
        P extends 'Proveedores' ? Array < ProveedoresGetPayload<S['include'][P]>>  :
        P extends '_count' ? CiudadesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Departamentos' ? DepartamentosGetPayload<S['select'][P]> :
        P extends 'Clientes' ? Array < ClientesGetPayload<S['select'][P]>>  :
        P extends 'DireccionesEnvio' ? Array < DireccionesEnvioGetPayload<S['select'][P]>>  :
        P extends 'Empleados' ? Array < EmpleadosGetPayload<S['select'][P]>>  :
        P extends 'EmpresasEnvio' ? Array < EmpresasEnvioGetPayload<S['select'][P]>>  :
        P extends 'Proveedores' ? Array < ProveedoresGetPayload<S['select'][P]>>  :
        P extends '_count' ? CiudadesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Ciudades ? Ciudades[P] : never
  } 
    : Ciudades
  : Ciudades


  type CiudadesCountArgs = Merge<
    Omit<CiudadesFindManyArgs, 'select' | 'include'> & {
      select?: CiudadesCountAggregateInputType | true
    }
  >

  export interface CiudadesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Ciudades that matches the filter.
     * @param {CiudadesFindUniqueArgs} args - Arguments to find a Ciudades
     * @example
     * // Get one Ciudades
     * const ciudades = await prisma.ciudades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CiudadesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CiudadesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Ciudades'> extends True ? CheckSelect<T, Prisma__CiudadesClient<Ciudades>, Prisma__CiudadesClient<CiudadesGetPayload<T>>> : CheckSelect<T, Prisma__CiudadesClient<Ciudades | null >, Prisma__CiudadesClient<CiudadesGetPayload<T> | null >>

    /**
     * Find the first Ciudades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadesFindFirstArgs} args - Arguments to find a Ciudades
     * @example
     * // Get one Ciudades
     * const ciudades = await prisma.ciudades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CiudadesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CiudadesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Ciudades'> extends True ? CheckSelect<T, Prisma__CiudadesClient<Ciudades>, Prisma__CiudadesClient<CiudadesGetPayload<T>>> : CheckSelect<T, Prisma__CiudadesClient<Ciudades | null >, Prisma__CiudadesClient<CiudadesGetPayload<T> | null >>

    /**
     * Find zero or more Ciudades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ciudades
     * const ciudades = await prisma.ciudades.findMany()
     * 
     * // Get first 10 Ciudades
     * const ciudades = await prisma.ciudades.findMany({ take: 10 })
     * 
     * // Only select the `id_ciudad`
     * const ciudadesWithId_ciudadOnly = await prisma.ciudades.findMany({ select: { id_ciudad: true } })
     * 
    **/
    findMany<T extends CiudadesFindManyArgs>(
      args?: SelectSubset<T, CiudadesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Ciudades>>, PrismaPromise<Array<CiudadesGetPayload<T>>>>

    /**
     * Create a Ciudades.
     * @param {CiudadesCreateArgs} args - Arguments to create a Ciudades.
     * @example
     * // Create one Ciudades
     * const Ciudades = await prisma.ciudades.create({
     *   data: {
     *     // ... data to create a Ciudades
     *   }
     * })
     * 
    **/
    create<T extends CiudadesCreateArgs>(
      args: SelectSubset<T, CiudadesCreateArgs>
    ): CheckSelect<T, Prisma__CiudadesClient<Ciudades>, Prisma__CiudadesClient<CiudadesGetPayload<T>>>

    /**
     * Create many Ciudades.
     *     @param {CiudadesCreateManyArgs} args - Arguments to create many Ciudades.
     *     @example
     *     // Create many Ciudades
     *     const ciudades = await prisma.ciudades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CiudadesCreateManyArgs>(
      args?: SelectSubset<T, CiudadesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ciudades.
     * @param {CiudadesDeleteArgs} args - Arguments to delete one Ciudades.
     * @example
     * // Delete one Ciudades
     * const Ciudades = await prisma.ciudades.delete({
     *   where: {
     *     // ... filter to delete one Ciudades
     *   }
     * })
     * 
    **/
    delete<T extends CiudadesDeleteArgs>(
      args: SelectSubset<T, CiudadesDeleteArgs>
    ): CheckSelect<T, Prisma__CiudadesClient<Ciudades>, Prisma__CiudadesClient<CiudadesGetPayload<T>>>

    /**
     * Update one Ciudades.
     * @param {CiudadesUpdateArgs} args - Arguments to update one Ciudades.
     * @example
     * // Update one Ciudades
     * const ciudades = await prisma.ciudades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CiudadesUpdateArgs>(
      args: SelectSubset<T, CiudadesUpdateArgs>
    ): CheckSelect<T, Prisma__CiudadesClient<Ciudades>, Prisma__CiudadesClient<CiudadesGetPayload<T>>>

    /**
     * Delete zero or more Ciudades.
     * @param {CiudadesDeleteManyArgs} args - Arguments to filter Ciudades to delete.
     * @example
     * // Delete a few Ciudades
     * const { count } = await prisma.ciudades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CiudadesDeleteManyArgs>(
      args?: SelectSubset<T, CiudadesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ciudades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ciudades
     * const ciudades = await prisma.ciudades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CiudadesUpdateManyArgs>(
      args: SelectSubset<T, CiudadesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ciudades.
     * @param {CiudadesUpsertArgs} args - Arguments to update or create a Ciudades.
     * @example
     * // Update or create a Ciudades
     * const ciudades = await prisma.ciudades.upsert({
     *   create: {
     *     // ... data to create a Ciudades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ciudades we want to update
     *   }
     * })
    **/
    upsert<T extends CiudadesUpsertArgs>(
      args: SelectSubset<T, CiudadesUpsertArgs>
    ): CheckSelect<T, Prisma__CiudadesClient<Ciudades>, Prisma__CiudadesClient<CiudadesGetPayload<T>>>

    /**
     * Count the number of Ciudades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadesCountArgs} args - Arguments to filter Ciudades to count.
     * @example
     * // Count the number of Ciudades
     * const count = await prisma.ciudades.count({
     *   where: {
     *     // ... the filter for the Ciudades we want to count
     *   }
     * })
    **/
    count<T extends CiudadesCountArgs>(
      args?: Subset<T, CiudadesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CiudadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ciudades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CiudadesAggregateArgs>(args: Subset<T, CiudadesAggregateArgs>): PrismaPromise<GetCiudadesAggregateType<T>>

    /**
     * Group by Ciudades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CiudadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CiudadesGroupByArgs['orderBy'] }
        : { orderBy?: CiudadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CiudadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCiudadesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ciudades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CiudadesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Departamentos<T extends DepartamentosArgs = {}>(args?: Subset<T, DepartamentosArgs>): CheckSelect<T, Prisma__DepartamentosClient<Departamentos | null >, Prisma__DepartamentosClient<DepartamentosGetPayload<T> | null >>;

    Clientes<T extends ClientesFindManyArgs = {}>(args?: Subset<T, ClientesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Clientes>>, PrismaPromise<Array<ClientesGetPayload<T>>>>;

    DireccionesEnvio<T extends DireccionesEnvioFindManyArgs = {}>(args?: Subset<T, DireccionesEnvioFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DireccionesEnvio>>, PrismaPromise<Array<DireccionesEnvioGetPayload<T>>>>;

    Empleados<T extends EmpleadosFindManyArgs = {}>(args?: Subset<T, EmpleadosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Empleados>>, PrismaPromise<Array<EmpleadosGetPayload<T>>>>;

    EmpresasEnvio<T extends EmpresasEnvioFindManyArgs = {}>(args?: Subset<T, EmpresasEnvioFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EmpresasEnvio>>, PrismaPromise<Array<EmpresasEnvioGetPayload<T>>>>;

    Proveedores<T extends ProveedoresFindManyArgs = {}>(args?: Subset<T, ProveedoresFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Proveedores>>, PrismaPromise<Array<ProveedoresGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Ciudades findUnique
   */
  export type CiudadesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Ciudades
     * 
    **/
    select?: CiudadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CiudadesInclude | null
    /**
     * Throw an Error if a Ciudades can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Ciudades to fetch.
     * 
    **/
    where: CiudadesWhereUniqueInput
  }


  /**
   * Ciudades findFirst
   */
  export type CiudadesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Ciudades
     * 
    **/
    select?: CiudadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CiudadesInclude | null
    /**
     * Throw an Error if a Ciudades can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Ciudades to fetch.
     * 
    **/
    where?: CiudadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ciudades to fetch.
     * 
    **/
    orderBy?: Enumerable<CiudadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ciudades.
     * 
    **/
    cursor?: CiudadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ciudades from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ciudades.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ciudades.
     * 
    **/
    distinct?: Enumerable<CiudadesScalarFieldEnum>
  }


  /**
   * Ciudades findMany
   */
  export type CiudadesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Ciudades
     * 
    **/
    select?: CiudadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CiudadesInclude | null
    /**
     * Filter, which Ciudades to fetch.
     * 
    **/
    where?: CiudadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ciudades to fetch.
     * 
    **/
    orderBy?: Enumerable<CiudadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ciudades.
     * 
    **/
    cursor?: CiudadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ciudades from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ciudades.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CiudadesScalarFieldEnum>
  }


  /**
   * Ciudades create
   */
  export type CiudadesCreateArgs = {
    /**
     * Select specific fields to fetch from the Ciudades
     * 
    **/
    select?: CiudadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CiudadesInclude | null
    /**
     * The data needed to create a Ciudades.
     * 
    **/
    data: XOR<CiudadesCreateInput, CiudadesUncheckedCreateInput>
  }


  /**
   * Ciudades createMany
   */
  export type CiudadesCreateManyArgs = {
    /**
     * The data used to create many Ciudades.
     * 
    **/
    data: Enumerable<CiudadesCreateManyInput>
  }


  /**
   * Ciudades update
   */
  export type CiudadesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Ciudades
     * 
    **/
    select?: CiudadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CiudadesInclude | null
    /**
     * The data needed to update a Ciudades.
     * 
    **/
    data: XOR<CiudadesUpdateInput, CiudadesUncheckedUpdateInput>
    /**
     * Choose, which Ciudades to update.
     * 
    **/
    where: CiudadesWhereUniqueInput
  }


  /**
   * Ciudades updateMany
   */
  export type CiudadesUpdateManyArgs = {
    /**
     * The data used to update Ciudades.
     * 
    **/
    data: XOR<CiudadesUpdateManyMutationInput, CiudadesUncheckedUpdateManyInput>
    /**
     * Filter which Ciudades to update
     * 
    **/
    where?: CiudadesWhereInput
  }


  /**
   * Ciudades upsert
   */
  export type CiudadesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Ciudades
     * 
    **/
    select?: CiudadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CiudadesInclude | null
    /**
     * The filter to search for the Ciudades to update in case it exists.
     * 
    **/
    where: CiudadesWhereUniqueInput
    /**
     * In case the Ciudades found by the `where` argument doesn't exist, create a new Ciudades with this data.
     * 
    **/
    create: XOR<CiudadesCreateInput, CiudadesUncheckedCreateInput>
    /**
     * In case the Ciudades was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CiudadesUpdateInput, CiudadesUncheckedUpdateInput>
  }


  /**
   * Ciudades delete
   */
  export type CiudadesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Ciudades
     * 
    **/
    select?: CiudadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CiudadesInclude | null
    /**
     * Filter which Ciudades to delete.
     * 
    **/
    where: CiudadesWhereUniqueInput
  }


  /**
   * Ciudades deleteMany
   */
  export type CiudadesDeleteManyArgs = {
    /**
     * Filter which Ciudades to delete
     * 
    **/
    where?: CiudadesWhereInput
  }


  /**
   * Ciudades without action
   */
  export type CiudadesArgs = {
    /**
     * Select specific fields to fetch from the Ciudades
     * 
    **/
    select?: CiudadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CiudadesInclude | null
  }



  /**
   * Model Clientes
   */


  export type AggregateClientes = {
    _count: ClientesCountAggregateOutputType | null
    _avg: ClientesAvgAggregateOutputType | null
    _sum: ClientesSumAggregateOutputType | null
    _min: ClientesMinAggregateOutputType | null
    _max: ClientesMaxAggregateOutputType | null
  }

  export type ClientesAvgAggregateOutputType = {
    id_cliente: number | null
    id_ciudad: number | null
  }

  export type ClientesSumAggregateOutputType = {
    id_cliente: number | null
    id_ciudad: number | null
  }

  export type ClientesMinAggregateOutputType = {
    id_cliente: number | null
    nom_cliente: string | null
    apellido_cliente: string | null
    RTN: string | null
    direccion_cliente: string | null
    id_ciudad: number | null
    tel_cliente: string | null
    estado: boolean | null
    DNI_Cliente: string | null
  }

  export type ClientesMaxAggregateOutputType = {
    id_cliente: number | null
    nom_cliente: string | null
    apellido_cliente: string | null
    RTN: string | null
    direccion_cliente: string | null
    id_ciudad: number | null
    tel_cliente: string | null
    estado: boolean | null
    DNI_Cliente: string | null
  }

  export type ClientesCountAggregateOutputType = {
    id_cliente: number
    nom_cliente: number
    apellido_cliente: number
    RTN: number
    direccion_cliente: number
    id_ciudad: number
    tel_cliente: number
    estado: number
    DNI_Cliente: number
    _all: number
  }


  export type ClientesAvgAggregateInputType = {
    id_cliente?: true
    id_ciudad?: true
  }

  export type ClientesSumAggregateInputType = {
    id_cliente?: true
    id_ciudad?: true
  }

  export type ClientesMinAggregateInputType = {
    id_cliente?: true
    nom_cliente?: true
    apellido_cliente?: true
    RTN?: true
    direccion_cliente?: true
    id_ciudad?: true
    tel_cliente?: true
    estado?: true
    DNI_Cliente?: true
  }

  export type ClientesMaxAggregateInputType = {
    id_cliente?: true
    nom_cliente?: true
    apellido_cliente?: true
    RTN?: true
    direccion_cliente?: true
    id_ciudad?: true
    tel_cliente?: true
    estado?: true
    DNI_Cliente?: true
  }

  export type ClientesCountAggregateInputType = {
    id_cliente?: true
    nom_cliente?: true
    apellido_cliente?: true
    RTN?: true
    direccion_cliente?: true
    id_ciudad?: true
    tel_cliente?: true
    estado?: true
    DNI_Cliente?: true
    _all?: true
  }

  export type ClientesAggregateArgs = {
    /**
     * Filter which Clientes to aggregate.
     * 
    **/
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClientesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientesMaxAggregateInputType
  }

  export type GetClientesAggregateType<T extends ClientesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientes[P]>
      : GetScalarType<T[P], AggregateClientes[P]>
  }




  export type ClientesGroupByArgs = {
    where?: ClientesWhereInput
    orderBy?: Enumerable<ClientesOrderByWithAggregationInput>
    by: Array<ClientesScalarFieldEnum>
    having?: ClientesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientesCountAggregateInputType | true
    _avg?: ClientesAvgAggregateInputType
    _sum?: ClientesSumAggregateInputType
    _min?: ClientesMinAggregateInputType
    _max?: ClientesMaxAggregateInputType
  }


  export type ClientesGroupByOutputType = {
    id_cliente: number
    nom_cliente: string
    apellido_cliente: string
    RTN: string | null
    direccion_cliente: string
    id_ciudad: number
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
    _count: ClientesCountAggregateOutputType | null
    _avg: ClientesAvgAggregateOutputType | null
    _sum: ClientesSumAggregateOutputType | null
    _min: ClientesMinAggregateOutputType | null
    _max: ClientesMaxAggregateOutputType | null
  }

  type GetClientesGroupByPayload<T extends ClientesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClientesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientesGroupByOutputType[P]>
        }
      >
    >


  export type ClientesSelect = {
    id_cliente?: boolean
    nom_cliente?: boolean
    apellido_cliente?: boolean
    RTN?: boolean
    direccion_cliente?: boolean
    id_ciudad?: boolean
    tel_cliente?: boolean
    estado?: boolean
    DNI_Cliente?: boolean
    Ciudades?: boolean | CiudadesArgs
    usuariosClientes?: boolean | usuariosClientesFindManyArgs
    Venta?: boolean | VentaFindManyArgs
    _count?: boolean | ClientesCountOutputTypeArgs
  }

  export type ClientesInclude = {
    Ciudades?: boolean | CiudadesArgs
    usuariosClientes?: boolean | usuariosClientesFindManyArgs
    Venta?: boolean | VentaFindManyArgs
    _count?: boolean | ClientesCountOutputTypeArgs
  }

  export type ClientesGetPayload<
    S extends boolean | null | undefined | ClientesArgs,
    U = keyof S
      > = S extends true
        ? Clientes
    : S extends undefined
    ? never
    : S extends ClientesArgs | ClientesFindManyArgs
    ?'include' extends U
    ? Clientes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Ciudades' ? CiudadesGetPayload<S['include'][P]> :
        P extends 'usuariosClientes' ? Array < usuariosClientesGetPayload<S['include'][P]>>  :
        P extends 'Venta' ? Array < VentaGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClientesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Ciudades' ? CiudadesGetPayload<S['select'][P]> :
        P extends 'usuariosClientes' ? Array < usuariosClientesGetPayload<S['select'][P]>>  :
        P extends 'Venta' ? Array < VentaGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClientesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Clientes ? Clientes[P] : never
  } 
    : Clientes
  : Clientes


  type ClientesCountArgs = Merge<
    Omit<ClientesFindManyArgs, 'select' | 'include'> & {
      select?: ClientesCountAggregateInputType | true
    }
  >

  export interface ClientesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Clientes that matches the filter.
     * @param {ClientesFindUniqueArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClientesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Clientes'> extends True ? CheckSelect<T, Prisma__ClientesClient<Clientes>, Prisma__ClientesClient<ClientesGetPayload<T>>> : CheckSelect<T, Prisma__ClientesClient<Clientes | null >, Prisma__ClientesClient<ClientesGetPayload<T> | null >>

    /**
     * Find the first Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesFindFirstArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClientesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Clientes'> extends True ? CheckSelect<T, Prisma__ClientesClient<Clientes>, Prisma__ClientesClient<ClientesGetPayload<T>>> : CheckSelect<T, Prisma__ClientesClient<Clientes | null >, Prisma__ClientesClient<ClientesGetPayload<T> | null >>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.clientes.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.clientes.findMany({ take: 10 })
     * 
     * // Only select the `id_cliente`
     * const clientesWithId_clienteOnly = await prisma.clientes.findMany({ select: { id_cliente: true } })
     * 
    **/
    findMany<T extends ClientesFindManyArgs>(
      args?: SelectSubset<T, ClientesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Clientes>>, PrismaPromise<Array<ClientesGetPayload<T>>>>

    /**
     * Create a Clientes.
     * @param {ClientesCreateArgs} args - Arguments to create a Clientes.
     * @example
     * // Create one Clientes
     * const Clientes = await prisma.clientes.create({
     *   data: {
     *     // ... data to create a Clientes
     *   }
     * })
     * 
    **/
    create<T extends ClientesCreateArgs>(
      args: SelectSubset<T, ClientesCreateArgs>
    ): CheckSelect<T, Prisma__ClientesClient<Clientes>, Prisma__ClientesClient<ClientesGetPayload<T>>>

    /**
     * Create many Clientes.
     *     @param {ClientesCreateManyArgs} args - Arguments to create many Clientes.
     *     @example
     *     // Create many Clientes
     *     const clientes = await prisma.clientes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClientesCreateManyArgs>(
      args?: SelectSubset<T, ClientesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Clientes.
     * @param {ClientesDeleteArgs} args - Arguments to delete one Clientes.
     * @example
     * // Delete one Clientes
     * const Clientes = await prisma.clientes.delete({
     *   where: {
     *     // ... filter to delete one Clientes
     *   }
     * })
     * 
    **/
    delete<T extends ClientesDeleteArgs>(
      args: SelectSubset<T, ClientesDeleteArgs>
    ): CheckSelect<T, Prisma__ClientesClient<Clientes>, Prisma__ClientesClient<ClientesGetPayload<T>>>

    /**
     * Update one Clientes.
     * @param {ClientesUpdateArgs} args - Arguments to update one Clientes.
     * @example
     * // Update one Clientes
     * const clientes = await prisma.clientes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientesUpdateArgs>(
      args: SelectSubset<T, ClientesUpdateArgs>
    ): CheckSelect<T, Prisma__ClientesClient<Clientes>, Prisma__ClientesClient<ClientesGetPayload<T>>>

    /**
     * Delete zero or more Clientes.
     * @param {ClientesDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.clientes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientesDeleteManyArgs>(
      args?: SelectSubset<T, ClientesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const clientes = await prisma.clientes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientesUpdateManyArgs>(
      args: SelectSubset<T, ClientesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientes.
     * @param {ClientesUpsertArgs} args - Arguments to update or create a Clientes.
     * @example
     * // Update or create a Clientes
     * const clientes = await prisma.clientes.upsert({
     *   create: {
     *     // ... data to create a Clientes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientes we want to update
     *   }
     * })
    **/
    upsert<T extends ClientesUpsertArgs>(
      args: SelectSubset<T, ClientesUpsertArgs>
    ): CheckSelect<T, Prisma__ClientesClient<Clientes>, Prisma__ClientesClient<ClientesGetPayload<T>>>

    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.clientes.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClientesCountArgs>(
      args?: Subset<T, ClientesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientesAggregateArgs>(args: Subset<T, ClientesAggregateArgs>): PrismaPromise<GetClientesAggregateType<T>>

    /**
     * Group by Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientesGroupByArgs['orderBy'] }
        : { orderBy?: ClientesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clientes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClientesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Ciudades<T extends CiudadesArgs = {}>(args?: Subset<T, CiudadesArgs>): CheckSelect<T, Prisma__CiudadesClient<Ciudades | null >, Prisma__CiudadesClient<CiudadesGetPayload<T> | null >>;

    usuariosClientes<T extends usuariosClientesFindManyArgs = {}>(args?: Subset<T, usuariosClientesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<usuariosClientes>>, PrismaPromise<Array<usuariosClientesGetPayload<T>>>>;

    Venta<T extends VentaFindManyArgs = {}>(args?: Subset<T, VentaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Venta>>, PrismaPromise<Array<VentaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Clientes findUnique
   */
  export type ClientesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Clientes
     * 
    **/
    select?: ClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientesInclude | null
    /**
     * Throw an Error if a Clientes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Clientes to fetch.
     * 
    **/
    where: ClientesWhereUniqueInput
  }


  /**
   * Clientes findFirst
   */
  export type ClientesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Clientes
     * 
    **/
    select?: ClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientesInclude | null
    /**
     * Throw an Error if a Clientes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Clientes to fetch.
     * 
    **/
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     * 
    **/
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     * 
    **/
    distinct?: Enumerable<ClientesScalarFieldEnum>
  }


  /**
   * Clientes findMany
   */
  export type ClientesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Clientes
     * 
    **/
    select?: ClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientesInclude | null
    /**
     * Filter, which Clientes to fetch.
     * 
    **/
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     * 
    **/
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientesScalarFieldEnum>
  }


  /**
   * Clientes create
   */
  export type ClientesCreateArgs = {
    /**
     * Select specific fields to fetch from the Clientes
     * 
    **/
    select?: ClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientesInclude | null
    /**
     * The data needed to create a Clientes.
     * 
    **/
    data: XOR<ClientesCreateInput, ClientesUncheckedCreateInput>
  }


  /**
   * Clientes createMany
   */
  export type ClientesCreateManyArgs = {
    /**
     * The data used to create many Clientes.
     * 
    **/
    data: Enumerable<ClientesCreateManyInput>
  }


  /**
   * Clientes update
   */
  export type ClientesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Clientes
     * 
    **/
    select?: ClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientesInclude | null
    /**
     * The data needed to update a Clientes.
     * 
    **/
    data: XOR<ClientesUpdateInput, ClientesUncheckedUpdateInput>
    /**
     * Choose, which Clientes to update.
     * 
    **/
    where: ClientesWhereUniqueInput
  }


  /**
   * Clientes updateMany
   */
  export type ClientesUpdateManyArgs = {
    /**
     * The data used to update Clientes.
     * 
    **/
    data: XOR<ClientesUpdateManyMutationInput, ClientesUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     * 
    **/
    where?: ClientesWhereInput
  }


  /**
   * Clientes upsert
   */
  export type ClientesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Clientes
     * 
    **/
    select?: ClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientesInclude | null
    /**
     * The filter to search for the Clientes to update in case it exists.
     * 
    **/
    where: ClientesWhereUniqueInput
    /**
     * In case the Clientes found by the `where` argument doesn't exist, create a new Clientes with this data.
     * 
    **/
    create: XOR<ClientesCreateInput, ClientesUncheckedCreateInput>
    /**
     * In case the Clientes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ClientesUpdateInput, ClientesUncheckedUpdateInput>
  }


  /**
   * Clientes delete
   */
  export type ClientesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Clientes
     * 
    **/
    select?: ClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientesInclude | null
    /**
     * Filter which Clientes to delete.
     * 
    **/
    where: ClientesWhereUniqueInput
  }


  /**
   * Clientes deleteMany
   */
  export type ClientesDeleteManyArgs = {
    /**
     * Filter which Clientes to delete
     * 
    **/
    where?: ClientesWhereInput
  }


  /**
   * Clientes without action
   */
  export type ClientesArgs = {
    /**
     * Select specific fields to fetch from the Clientes
     * 
    **/
    select?: ClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientesInclude | null
  }



  /**
   * Model Compras
   */


  export type AggregateCompras = {
    _count: ComprasCountAggregateOutputType | null
    _avg: ComprasAvgAggregateOutputType | null
    _sum: ComprasSumAggregateOutputType | null
    _min: ComprasMinAggregateOutputType | null
    _max: ComprasMaxAggregateOutputType | null
  }

  export type ComprasAvgAggregateOutputType = {
    id_compra: number | null
    id_prov: number | null
    id_empleado: number | null
    isv: number | null
    descuento: number | null
  }

  export type ComprasSumAggregateOutputType = {
    id_compra: number | null
    id_prov: number | null
    id_empleado: number | null
    isv: number | null
    descuento: number | null
  }

  export type ComprasMinAggregateOutputType = {
    id_compra: number | null
    fecha_compra: Date | null
    id_prov: number | null
    id_empleado: number | null
    isv: number | null
    descuento: number | null
  }

  export type ComprasMaxAggregateOutputType = {
    id_compra: number | null
    fecha_compra: Date | null
    id_prov: number | null
    id_empleado: number | null
    isv: number | null
    descuento: number | null
  }

  export type ComprasCountAggregateOutputType = {
    id_compra: number
    fecha_compra: number
    id_prov: number
    id_empleado: number
    isv: number
    descuento: number
    _all: number
  }


  export type ComprasAvgAggregateInputType = {
    id_compra?: true
    id_prov?: true
    id_empleado?: true
    isv?: true
    descuento?: true
  }

  export type ComprasSumAggregateInputType = {
    id_compra?: true
    id_prov?: true
    id_empleado?: true
    isv?: true
    descuento?: true
  }

  export type ComprasMinAggregateInputType = {
    id_compra?: true
    fecha_compra?: true
    id_prov?: true
    id_empleado?: true
    isv?: true
    descuento?: true
  }

  export type ComprasMaxAggregateInputType = {
    id_compra?: true
    fecha_compra?: true
    id_prov?: true
    id_empleado?: true
    isv?: true
    descuento?: true
  }

  export type ComprasCountAggregateInputType = {
    id_compra?: true
    fecha_compra?: true
    id_prov?: true
    id_empleado?: true
    isv?: true
    descuento?: true
    _all?: true
  }

  export type ComprasAggregateArgs = {
    /**
     * Filter which Compras to aggregate.
     * 
    **/
    where?: ComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compras to fetch.
     * 
    **/
    orderBy?: Enumerable<ComprasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Compras
    **/
    _count?: true | ComprasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComprasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComprasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComprasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComprasMaxAggregateInputType
  }

  export type GetComprasAggregateType<T extends ComprasAggregateArgs> = {
        [P in keyof T & keyof AggregateCompras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompras[P]>
      : GetScalarType<T[P], AggregateCompras[P]>
  }




  export type ComprasGroupByArgs = {
    where?: ComprasWhereInput
    orderBy?: Enumerable<ComprasOrderByWithAggregationInput>
    by: Array<ComprasScalarFieldEnum>
    having?: ComprasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComprasCountAggregateInputType | true
    _avg?: ComprasAvgAggregateInputType
    _sum?: ComprasSumAggregateInputType
    _min?: ComprasMinAggregateInputType
    _max?: ComprasMaxAggregateInputType
  }


  export type ComprasGroupByOutputType = {
    id_compra: number
    fecha_compra: Date
    id_prov: number
    id_empleado: number
    isv: number
    descuento: number
    _count: ComprasCountAggregateOutputType | null
    _avg: ComprasAvgAggregateOutputType | null
    _sum: ComprasSumAggregateOutputType | null
    _min: ComprasMinAggregateOutputType | null
    _max: ComprasMaxAggregateOutputType | null
  }

  type GetComprasGroupByPayload<T extends ComprasGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ComprasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComprasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComprasGroupByOutputType[P]>
            : GetScalarType<T[P], ComprasGroupByOutputType[P]>
        }
      >
    >


  export type ComprasSelect = {
    id_compra?: boolean
    fecha_compra?: boolean
    id_prov?: boolean
    id_empleado?: boolean
    isv?: boolean
    descuento?: boolean
    Empleados?: boolean | EmpleadosArgs
    Proveedores?: boolean | ProveedoresArgs
    DetalleCompras?: boolean | DetalleComprasFindManyArgs
    _count?: boolean | ComprasCountOutputTypeArgs
  }

  export type ComprasInclude = {
    Empleados?: boolean | EmpleadosArgs
    Proveedores?: boolean | ProveedoresArgs
    DetalleCompras?: boolean | DetalleComprasFindManyArgs
    _count?: boolean | ComprasCountOutputTypeArgs
  }

  export type ComprasGetPayload<
    S extends boolean | null | undefined | ComprasArgs,
    U = keyof S
      > = S extends true
        ? Compras
    : S extends undefined
    ? never
    : S extends ComprasArgs | ComprasFindManyArgs
    ?'include' extends U
    ? Compras  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Empleados' ? EmpleadosGetPayload<S['include'][P]> :
        P extends 'Proveedores' ? ProveedoresGetPayload<S['include'][P]> :
        P extends 'DetalleCompras' ? Array < DetalleComprasGetPayload<S['include'][P]>>  :
        P extends '_count' ? ComprasCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Empleados' ? EmpleadosGetPayload<S['select'][P]> :
        P extends 'Proveedores' ? ProveedoresGetPayload<S['select'][P]> :
        P extends 'DetalleCompras' ? Array < DetalleComprasGetPayload<S['select'][P]>>  :
        P extends '_count' ? ComprasCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Compras ? Compras[P] : never
  } 
    : Compras
  : Compras


  type ComprasCountArgs = Merge<
    Omit<ComprasFindManyArgs, 'select' | 'include'> & {
      select?: ComprasCountAggregateInputType | true
    }
  >

  export interface ComprasDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Compras that matches the filter.
     * @param {ComprasFindUniqueArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ComprasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ComprasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Compras'> extends True ? CheckSelect<T, Prisma__ComprasClient<Compras>, Prisma__ComprasClient<ComprasGetPayload<T>>> : CheckSelect<T, Prisma__ComprasClient<Compras | null >, Prisma__ComprasClient<ComprasGetPayload<T> | null >>

    /**
     * Find the first Compras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasFindFirstArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ComprasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ComprasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Compras'> extends True ? CheckSelect<T, Prisma__ComprasClient<Compras>, Prisma__ComprasClient<ComprasGetPayload<T>>> : CheckSelect<T, Prisma__ComprasClient<Compras | null >, Prisma__ComprasClient<ComprasGetPayload<T> | null >>

    /**
     * Find zero or more Compras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Compras
     * const compras = await prisma.compras.findMany()
     * 
     * // Get first 10 Compras
     * const compras = await prisma.compras.findMany({ take: 10 })
     * 
     * // Only select the `id_compra`
     * const comprasWithId_compraOnly = await prisma.compras.findMany({ select: { id_compra: true } })
     * 
    **/
    findMany<T extends ComprasFindManyArgs>(
      args?: SelectSubset<T, ComprasFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Compras>>, PrismaPromise<Array<ComprasGetPayload<T>>>>

    /**
     * Create a Compras.
     * @param {ComprasCreateArgs} args - Arguments to create a Compras.
     * @example
     * // Create one Compras
     * const Compras = await prisma.compras.create({
     *   data: {
     *     // ... data to create a Compras
     *   }
     * })
     * 
    **/
    create<T extends ComprasCreateArgs>(
      args: SelectSubset<T, ComprasCreateArgs>
    ): CheckSelect<T, Prisma__ComprasClient<Compras>, Prisma__ComprasClient<ComprasGetPayload<T>>>

    /**
     * Create many Compras.
     *     @param {ComprasCreateManyArgs} args - Arguments to create many Compras.
     *     @example
     *     // Create many Compras
     *     const compras = await prisma.compras.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ComprasCreateManyArgs>(
      args?: SelectSubset<T, ComprasCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Compras.
     * @param {ComprasDeleteArgs} args - Arguments to delete one Compras.
     * @example
     * // Delete one Compras
     * const Compras = await prisma.compras.delete({
     *   where: {
     *     // ... filter to delete one Compras
     *   }
     * })
     * 
    **/
    delete<T extends ComprasDeleteArgs>(
      args: SelectSubset<T, ComprasDeleteArgs>
    ): CheckSelect<T, Prisma__ComprasClient<Compras>, Prisma__ComprasClient<ComprasGetPayload<T>>>

    /**
     * Update one Compras.
     * @param {ComprasUpdateArgs} args - Arguments to update one Compras.
     * @example
     * // Update one Compras
     * const compras = await prisma.compras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ComprasUpdateArgs>(
      args: SelectSubset<T, ComprasUpdateArgs>
    ): CheckSelect<T, Prisma__ComprasClient<Compras>, Prisma__ComprasClient<ComprasGetPayload<T>>>

    /**
     * Delete zero or more Compras.
     * @param {ComprasDeleteManyArgs} args - Arguments to filter Compras to delete.
     * @example
     * // Delete a few Compras
     * const { count } = await prisma.compras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ComprasDeleteManyArgs>(
      args?: SelectSubset<T, ComprasDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Compras
     * const compras = await prisma.compras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ComprasUpdateManyArgs>(
      args: SelectSubset<T, ComprasUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Compras.
     * @param {ComprasUpsertArgs} args - Arguments to update or create a Compras.
     * @example
     * // Update or create a Compras
     * const compras = await prisma.compras.upsert({
     *   create: {
     *     // ... data to create a Compras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compras we want to update
     *   }
     * })
    **/
    upsert<T extends ComprasUpsertArgs>(
      args: SelectSubset<T, ComprasUpsertArgs>
    ): CheckSelect<T, Prisma__ComprasClient<Compras>, Prisma__ComprasClient<ComprasGetPayload<T>>>

    /**
     * Count the number of Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasCountArgs} args - Arguments to filter Compras to count.
     * @example
     * // Count the number of Compras
     * const count = await prisma.compras.count({
     *   where: {
     *     // ... the filter for the Compras we want to count
     *   }
     * })
    **/
    count<T extends ComprasCountArgs>(
      args?: Subset<T, ComprasCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComprasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComprasAggregateArgs>(args: Subset<T, ComprasAggregateArgs>): PrismaPromise<GetComprasAggregateType<T>>

    /**
     * Group by Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComprasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComprasGroupByArgs['orderBy'] }
        : { orderBy?: ComprasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComprasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComprasGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Compras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ComprasClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Empleados<T extends EmpleadosArgs = {}>(args?: Subset<T, EmpleadosArgs>): CheckSelect<T, Prisma__EmpleadosClient<Empleados | null >, Prisma__EmpleadosClient<EmpleadosGetPayload<T> | null >>;

    Proveedores<T extends ProveedoresArgs = {}>(args?: Subset<T, ProveedoresArgs>): CheckSelect<T, Prisma__ProveedoresClient<Proveedores | null >, Prisma__ProveedoresClient<ProveedoresGetPayload<T> | null >>;

    DetalleCompras<T extends DetalleComprasFindManyArgs = {}>(args?: Subset<T, DetalleComprasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DetalleCompras>>, PrismaPromise<Array<DetalleComprasGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Compras findUnique
   */
  export type ComprasFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Compras
     * 
    **/
    select?: ComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ComprasInclude | null
    /**
     * Throw an Error if a Compras can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Compras to fetch.
     * 
    **/
    where: ComprasWhereUniqueInput
  }


  /**
   * Compras findFirst
   */
  export type ComprasFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Compras
     * 
    **/
    select?: ComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ComprasInclude | null
    /**
     * Throw an Error if a Compras can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Compras to fetch.
     * 
    **/
    where?: ComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compras to fetch.
     * 
    **/
    orderBy?: Enumerable<ComprasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Compras.
     * 
    **/
    cursor?: ComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Compras.
     * 
    **/
    distinct?: Enumerable<ComprasScalarFieldEnum>
  }


  /**
   * Compras findMany
   */
  export type ComprasFindManyArgs = {
    /**
     * Select specific fields to fetch from the Compras
     * 
    **/
    select?: ComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ComprasInclude | null
    /**
     * Filter, which Compras to fetch.
     * 
    **/
    where?: ComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compras to fetch.
     * 
    **/
    orderBy?: Enumerable<ComprasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Compras.
     * 
    **/
    cursor?: ComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compras.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ComprasScalarFieldEnum>
  }


  /**
   * Compras create
   */
  export type ComprasCreateArgs = {
    /**
     * Select specific fields to fetch from the Compras
     * 
    **/
    select?: ComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ComprasInclude | null
    /**
     * The data needed to create a Compras.
     * 
    **/
    data: XOR<ComprasCreateInput, ComprasUncheckedCreateInput>
  }


  /**
   * Compras createMany
   */
  export type ComprasCreateManyArgs = {
    /**
     * The data used to create many Compras.
     * 
    **/
    data: Enumerable<ComprasCreateManyInput>
  }


  /**
   * Compras update
   */
  export type ComprasUpdateArgs = {
    /**
     * Select specific fields to fetch from the Compras
     * 
    **/
    select?: ComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ComprasInclude | null
    /**
     * The data needed to update a Compras.
     * 
    **/
    data: XOR<ComprasUpdateInput, ComprasUncheckedUpdateInput>
    /**
     * Choose, which Compras to update.
     * 
    **/
    where: ComprasWhereUniqueInput
  }


  /**
   * Compras updateMany
   */
  export type ComprasUpdateManyArgs = {
    /**
     * The data used to update Compras.
     * 
    **/
    data: XOR<ComprasUpdateManyMutationInput, ComprasUncheckedUpdateManyInput>
    /**
     * Filter which Compras to update
     * 
    **/
    where?: ComprasWhereInput
  }


  /**
   * Compras upsert
   */
  export type ComprasUpsertArgs = {
    /**
     * Select specific fields to fetch from the Compras
     * 
    **/
    select?: ComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ComprasInclude | null
    /**
     * The filter to search for the Compras to update in case it exists.
     * 
    **/
    where: ComprasWhereUniqueInput
    /**
     * In case the Compras found by the `where` argument doesn't exist, create a new Compras with this data.
     * 
    **/
    create: XOR<ComprasCreateInput, ComprasUncheckedCreateInput>
    /**
     * In case the Compras was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ComprasUpdateInput, ComprasUncheckedUpdateInput>
  }


  /**
   * Compras delete
   */
  export type ComprasDeleteArgs = {
    /**
     * Select specific fields to fetch from the Compras
     * 
    **/
    select?: ComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ComprasInclude | null
    /**
     * Filter which Compras to delete.
     * 
    **/
    where: ComprasWhereUniqueInput
  }


  /**
   * Compras deleteMany
   */
  export type ComprasDeleteManyArgs = {
    /**
     * Filter which Compras to delete
     * 
    **/
    where?: ComprasWhereInput
  }


  /**
   * Compras without action
   */
  export type ComprasArgs = {
    /**
     * Select specific fields to fetch from the Compras
     * 
    **/
    select?: ComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ComprasInclude | null
  }



  /**
   * Model Departamentos
   */


  export type AggregateDepartamentos = {
    _count: DepartamentosCountAggregateOutputType | null
    _avg: DepartamentosAvgAggregateOutputType | null
    _sum: DepartamentosSumAggregateOutputType | null
    _min: DepartamentosMinAggregateOutputType | null
    _max: DepartamentosMaxAggregateOutputType | null
  }

  export type DepartamentosAvgAggregateOutputType = {
    id_departamento: number | null
  }

  export type DepartamentosSumAggregateOutputType = {
    id_departamento: number | null
  }

  export type DepartamentosMinAggregateOutputType = {
    id_departamento: number | null
    nombreDepartamento: string | null
  }

  export type DepartamentosMaxAggregateOutputType = {
    id_departamento: number | null
    nombreDepartamento: string | null
  }

  export type DepartamentosCountAggregateOutputType = {
    id_departamento: number
    nombreDepartamento: number
    _all: number
  }


  export type DepartamentosAvgAggregateInputType = {
    id_departamento?: true
  }

  export type DepartamentosSumAggregateInputType = {
    id_departamento?: true
  }

  export type DepartamentosMinAggregateInputType = {
    id_departamento?: true
    nombreDepartamento?: true
  }

  export type DepartamentosMaxAggregateInputType = {
    id_departamento?: true
    nombreDepartamento?: true
  }

  export type DepartamentosCountAggregateInputType = {
    id_departamento?: true
    nombreDepartamento?: true
    _all?: true
  }

  export type DepartamentosAggregateArgs = {
    /**
     * Filter which Departamentos to aggregate.
     * 
    **/
    where?: DepartamentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     * 
    **/
    orderBy?: Enumerable<DepartamentosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DepartamentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departamentos
    **/
    _count?: true | DepartamentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartamentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartamentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartamentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartamentosMaxAggregateInputType
  }

  export type GetDepartamentosAggregateType<T extends DepartamentosAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartamentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartamentos[P]>
      : GetScalarType<T[P], AggregateDepartamentos[P]>
  }




  export type DepartamentosGroupByArgs = {
    where?: DepartamentosWhereInput
    orderBy?: Enumerable<DepartamentosOrderByWithAggregationInput>
    by: Array<DepartamentosScalarFieldEnum>
    having?: DepartamentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartamentosCountAggregateInputType | true
    _avg?: DepartamentosAvgAggregateInputType
    _sum?: DepartamentosSumAggregateInputType
    _min?: DepartamentosMinAggregateInputType
    _max?: DepartamentosMaxAggregateInputType
  }


  export type DepartamentosGroupByOutputType = {
    id_departamento: number
    nombreDepartamento: string
    _count: DepartamentosCountAggregateOutputType | null
    _avg: DepartamentosAvgAggregateOutputType | null
    _sum: DepartamentosSumAggregateOutputType | null
    _min: DepartamentosMinAggregateOutputType | null
    _max: DepartamentosMaxAggregateOutputType | null
  }

  type GetDepartamentosGroupByPayload<T extends DepartamentosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DepartamentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartamentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartamentosGroupByOutputType[P]>
            : GetScalarType<T[P], DepartamentosGroupByOutputType[P]>
        }
      >
    >


  export type DepartamentosSelect = {
    id_departamento?: boolean
    nombreDepartamento?: boolean
    Ciudades?: boolean | CiudadesFindManyArgs
    _count?: boolean | DepartamentosCountOutputTypeArgs
  }

  export type DepartamentosInclude = {
    Ciudades?: boolean | CiudadesFindManyArgs
    _count?: boolean | DepartamentosCountOutputTypeArgs
  }

  export type DepartamentosGetPayload<
    S extends boolean | null | undefined | DepartamentosArgs,
    U = keyof S
      > = S extends true
        ? Departamentos
    : S extends undefined
    ? never
    : S extends DepartamentosArgs | DepartamentosFindManyArgs
    ?'include' extends U
    ? Departamentos  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Ciudades' ? Array < CiudadesGetPayload<S['include'][P]>>  :
        P extends '_count' ? DepartamentosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Ciudades' ? Array < CiudadesGetPayload<S['select'][P]>>  :
        P extends '_count' ? DepartamentosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Departamentos ? Departamentos[P] : never
  } 
    : Departamentos
  : Departamentos


  type DepartamentosCountArgs = Merge<
    Omit<DepartamentosFindManyArgs, 'select' | 'include'> & {
      select?: DepartamentosCountAggregateInputType | true
    }
  >

  export interface DepartamentosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Departamentos that matches the filter.
     * @param {DepartamentosFindUniqueArgs} args - Arguments to find a Departamentos
     * @example
     * // Get one Departamentos
     * const departamentos = await prisma.departamentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DepartamentosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DepartamentosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Departamentos'> extends True ? CheckSelect<T, Prisma__DepartamentosClient<Departamentos>, Prisma__DepartamentosClient<DepartamentosGetPayload<T>>> : CheckSelect<T, Prisma__DepartamentosClient<Departamentos | null >, Prisma__DepartamentosClient<DepartamentosGetPayload<T> | null >>

    /**
     * Find the first Departamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentosFindFirstArgs} args - Arguments to find a Departamentos
     * @example
     * // Get one Departamentos
     * const departamentos = await prisma.departamentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DepartamentosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DepartamentosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Departamentos'> extends True ? CheckSelect<T, Prisma__DepartamentosClient<Departamentos>, Prisma__DepartamentosClient<DepartamentosGetPayload<T>>> : CheckSelect<T, Prisma__DepartamentosClient<Departamentos | null >, Prisma__DepartamentosClient<DepartamentosGetPayload<T> | null >>

    /**
     * Find zero or more Departamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departamentos
     * const departamentos = await prisma.departamentos.findMany()
     * 
     * // Get first 10 Departamentos
     * const departamentos = await prisma.departamentos.findMany({ take: 10 })
     * 
     * // Only select the `id_departamento`
     * const departamentosWithId_departamentoOnly = await prisma.departamentos.findMany({ select: { id_departamento: true } })
     * 
    **/
    findMany<T extends DepartamentosFindManyArgs>(
      args?: SelectSubset<T, DepartamentosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Departamentos>>, PrismaPromise<Array<DepartamentosGetPayload<T>>>>

    /**
     * Create a Departamentos.
     * @param {DepartamentosCreateArgs} args - Arguments to create a Departamentos.
     * @example
     * // Create one Departamentos
     * const Departamentos = await prisma.departamentos.create({
     *   data: {
     *     // ... data to create a Departamentos
     *   }
     * })
     * 
    **/
    create<T extends DepartamentosCreateArgs>(
      args: SelectSubset<T, DepartamentosCreateArgs>
    ): CheckSelect<T, Prisma__DepartamentosClient<Departamentos>, Prisma__DepartamentosClient<DepartamentosGetPayload<T>>>

    /**
     * Create many Departamentos.
     *     @param {DepartamentosCreateManyArgs} args - Arguments to create many Departamentos.
     *     @example
     *     // Create many Departamentos
     *     const departamentos = await prisma.departamentos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DepartamentosCreateManyArgs>(
      args?: SelectSubset<T, DepartamentosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Departamentos.
     * @param {DepartamentosDeleteArgs} args - Arguments to delete one Departamentos.
     * @example
     * // Delete one Departamentos
     * const Departamentos = await prisma.departamentos.delete({
     *   where: {
     *     // ... filter to delete one Departamentos
     *   }
     * })
     * 
    **/
    delete<T extends DepartamentosDeleteArgs>(
      args: SelectSubset<T, DepartamentosDeleteArgs>
    ): CheckSelect<T, Prisma__DepartamentosClient<Departamentos>, Prisma__DepartamentosClient<DepartamentosGetPayload<T>>>

    /**
     * Update one Departamentos.
     * @param {DepartamentosUpdateArgs} args - Arguments to update one Departamentos.
     * @example
     * // Update one Departamentos
     * const departamentos = await prisma.departamentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DepartamentosUpdateArgs>(
      args: SelectSubset<T, DepartamentosUpdateArgs>
    ): CheckSelect<T, Prisma__DepartamentosClient<Departamentos>, Prisma__DepartamentosClient<DepartamentosGetPayload<T>>>

    /**
     * Delete zero or more Departamentos.
     * @param {DepartamentosDeleteManyArgs} args - Arguments to filter Departamentos to delete.
     * @example
     * // Delete a few Departamentos
     * const { count } = await prisma.departamentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DepartamentosDeleteManyArgs>(
      args?: SelectSubset<T, DepartamentosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departamentos
     * const departamentos = await prisma.departamentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DepartamentosUpdateManyArgs>(
      args: SelectSubset<T, DepartamentosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Departamentos.
     * @param {DepartamentosUpsertArgs} args - Arguments to update or create a Departamentos.
     * @example
     * // Update or create a Departamentos
     * const departamentos = await prisma.departamentos.upsert({
     *   create: {
     *     // ... data to create a Departamentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departamentos we want to update
     *   }
     * })
    **/
    upsert<T extends DepartamentosUpsertArgs>(
      args: SelectSubset<T, DepartamentosUpsertArgs>
    ): CheckSelect<T, Prisma__DepartamentosClient<Departamentos>, Prisma__DepartamentosClient<DepartamentosGetPayload<T>>>

    /**
     * Count the number of Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentosCountArgs} args - Arguments to filter Departamentos to count.
     * @example
     * // Count the number of Departamentos
     * const count = await prisma.departamentos.count({
     *   where: {
     *     // ... the filter for the Departamentos we want to count
     *   }
     * })
    **/
    count<T extends DepartamentosCountArgs>(
      args?: Subset<T, DepartamentosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartamentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartamentosAggregateArgs>(args: Subset<T, DepartamentosAggregateArgs>): PrismaPromise<GetDepartamentosAggregateType<T>>

    /**
     * Group by Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartamentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartamentosGroupByArgs['orderBy'] }
        : { orderBy?: DepartamentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartamentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartamentosGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Departamentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DepartamentosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Ciudades<T extends CiudadesFindManyArgs = {}>(args?: Subset<T, CiudadesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Ciudades>>, PrismaPromise<Array<CiudadesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Departamentos findUnique
   */
  export type DepartamentosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Departamentos
     * 
    **/
    select?: DepartamentosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartamentosInclude | null
    /**
     * Throw an Error if a Departamentos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Departamentos to fetch.
     * 
    **/
    where: DepartamentosWhereUniqueInput
  }


  /**
   * Departamentos findFirst
   */
  export type DepartamentosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Departamentos
     * 
    **/
    select?: DepartamentosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartamentosInclude | null
    /**
     * Throw an Error if a Departamentos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Departamentos to fetch.
     * 
    **/
    where?: DepartamentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     * 
    **/
    orderBy?: Enumerable<DepartamentosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departamentos.
     * 
    **/
    cursor?: DepartamentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departamentos.
     * 
    **/
    distinct?: Enumerable<DepartamentosScalarFieldEnum>
  }


  /**
   * Departamentos findMany
   */
  export type DepartamentosFindManyArgs = {
    /**
     * Select specific fields to fetch from the Departamentos
     * 
    **/
    select?: DepartamentosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartamentosInclude | null
    /**
     * Filter, which Departamentos to fetch.
     * 
    **/
    where?: DepartamentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     * 
    **/
    orderBy?: Enumerable<DepartamentosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departamentos.
     * 
    **/
    cursor?: DepartamentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DepartamentosScalarFieldEnum>
  }


  /**
   * Departamentos create
   */
  export type DepartamentosCreateArgs = {
    /**
     * Select specific fields to fetch from the Departamentos
     * 
    **/
    select?: DepartamentosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartamentosInclude | null
    /**
     * The data needed to create a Departamentos.
     * 
    **/
    data: XOR<DepartamentosCreateInput, DepartamentosUncheckedCreateInput>
  }


  /**
   * Departamentos createMany
   */
  export type DepartamentosCreateManyArgs = {
    /**
     * The data used to create many Departamentos.
     * 
    **/
    data: Enumerable<DepartamentosCreateManyInput>
  }


  /**
   * Departamentos update
   */
  export type DepartamentosUpdateArgs = {
    /**
     * Select specific fields to fetch from the Departamentos
     * 
    **/
    select?: DepartamentosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartamentosInclude | null
    /**
     * The data needed to update a Departamentos.
     * 
    **/
    data: XOR<DepartamentosUpdateInput, DepartamentosUncheckedUpdateInput>
    /**
     * Choose, which Departamentos to update.
     * 
    **/
    where: DepartamentosWhereUniqueInput
  }


  /**
   * Departamentos updateMany
   */
  export type DepartamentosUpdateManyArgs = {
    /**
     * The data used to update Departamentos.
     * 
    **/
    data: XOR<DepartamentosUpdateManyMutationInput, DepartamentosUncheckedUpdateManyInput>
    /**
     * Filter which Departamentos to update
     * 
    **/
    where?: DepartamentosWhereInput
  }


  /**
   * Departamentos upsert
   */
  export type DepartamentosUpsertArgs = {
    /**
     * Select specific fields to fetch from the Departamentos
     * 
    **/
    select?: DepartamentosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartamentosInclude | null
    /**
     * The filter to search for the Departamentos to update in case it exists.
     * 
    **/
    where: DepartamentosWhereUniqueInput
    /**
     * In case the Departamentos found by the `where` argument doesn't exist, create a new Departamentos with this data.
     * 
    **/
    create: XOR<DepartamentosCreateInput, DepartamentosUncheckedCreateInput>
    /**
     * In case the Departamentos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DepartamentosUpdateInput, DepartamentosUncheckedUpdateInput>
  }


  /**
   * Departamentos delete
   */
  export type DepartamentosDeleteArgs = {
    /**
     * Select specific fields to fetch from the Departamentos
     * 
    **/
    select?: DepartamentosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartamentosInclude | null
    /**
     * Filter which Departamentos to delete.
     * 
    **/
    where: DepartamentosWhereUniqueInput
  }


  /**
   * Departamentos deleteMany
   */
  export type DepartamentosDeleteManyArgs = {
    /**
     * Filter which Departamentos to delete
     * 
    **/
    where?: DepartamentosWhereInput
  }


  /**
   * Departamentos without action
   */
  export type DepartamentosArgs = {
    /**
     * Select specific fields to fetch from the Departamentos
     * 
    **/
    select?: DepartamentosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartamentosInclude | null
  }



  /**
   * Model DetalleCompras
   */


  export type AggregateDetalleCompras = {
    _count: DetalleComprasCountAggregateOutputType | null
    _avg: DetalleComprasAvgAggregateOutputType | null
    _sum: DetalleComprasSumAggregateOutputType | null
    _min: DetalleComprasMinAggregateOutputType | null
    _max: DetalleComprasMaxAggregateOutputType | null
  }

  export type DetalleComprasAvgAggregateOutputType = {
    id_detalleCompra: number | null
    id_producto: number | null
    id_compra: number | null
    precio: number | null
    cantidad: number | null
  }

  export type DetalleComprasSumAggregateOutputType = {
    id_detalleCompra: number | null
    id_producto: number | null
    id_compra: number | null
    precio: number | null
    cantidad: number | null
  }

  export type DetalleComprasMinAggregateOutputType = {
    id_detalleCompra: number | null
    id_producto: number | null
    id_compra: number | null
    precio: number | null
    cantidad: number | null
  }

  export type DetalleComprasMaxAggregateOutputType = {
    id_detalleCompra: number | null
    id_producto: number | null
    id_compra: number | null
    precio: number | null
    cantidad: number | null
  }

  export type DetalleComprasCountAggregateOutputType = {
    id_detalleCompra: number
    id_producto: number
    id_compra: number
    precio: number
    cantidad: number
    _all: number
  }


  export type DetalleComprasAvgAggregateInputType = {
    id_detalleCompra?: true
    id_producto?: true
    id_compra?: true
    precio?: true
    cantidad?: true
  }

  export type DetalleComprasSumAggregateInputType = {
    id_detalleCompra?: true
    id_producto?: true
    id_compra?: true
    precio?: true
    cantidad?: true
  }

  export type DetalleComprasMinAggregateInputType = {
    id_detalleCompra?: true
    id_producto?: true
    id_compra?: true
    precio?: true
    cantidad?: true
  }

  export type DetalleComprasMaxAggregateInputType = {
    id_detalleCompra?: true
    id_producto?: true
    id_compra?: true
    precio?: true
    cantidad?: true
  }

  export type DetalleComprasCountAggregateInputType = {
    id_detalleCompra?: true
    id_producto?: true
    id_compra?: true
    precio?: true
    cantidad?: true
    _all?: true
  }

  export type DetalleComprasAggregateArgs = {
    /**
     * Filter which DetalleCompras to aggregate.
     * 
    **/
    where?: DetalleComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     * 
    **/
    orderBy?: Enumerable<DetalleComprasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DetalleComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetalleCompras
    **/
    _count?: true | DetalleComprasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetalleComprasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetalleComprasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetalleComprasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetalleComprasMaxAggregateInputType
  }

  export type GetDetalleComprasAggregateType<T extends DetalleComprasAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalleCompras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalleCompras[P]>
      : GetScalarType<T[P], AggregateDetalleCompras[P]>
  }




  export type DetalleComprasGroupByArgs = {
    where?: DetalleComprasWhereInput
    orderBy?: Enumerable<DetalleComprasOrderByWithAggregationInput>
    by: Array<DetalleComprasScalarFieldEnum>
    having?: DetalleComprasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetalleComprasCountAggregateInputType | true
    _avg?: DetalleComprasAvgAggregateInputType
    _sum?: DetalleComprasSumAggregateInputType
    _min?: DetalleComprasMinAggregateInputType
    _max?: DetalleComprasMaxAggregateInputType
  }


  export type DetalleComprasGroupByOutputType = {
    id_detalleCompra: number
    id_producto: number
    id_compra: number
    precio: number
    cantidad: number
    _count: DetalleComprasCountAggregateOutputType | null
    _avg: DetalleComprasAvgAggregateOutputType | null
    _sum: DetalleComprasSumAggregateOutputType | null
    _min: DetalleComprasMinAggregateOutputType | null
    _max: DetalleComprasMaxAggregateOutputType | null
  }

  type GetDetalleComprasGroupByPayload<T extends DetalleComprasGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DetalleComprasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetalleComprasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetalleComprasGroupByOutputType[P]>
            : GetScalarType<T[P], DetalleComprasGroupByOutputType[P]>
        }
      >
    >


  export type DetalleComprasSelect = {
    id_detalleCompra?: boolean
    id_producto?: boolean
    id_compra?: boolean
    precio?: boolean
    cantidad?: boolean
    Compras?: boolean | ComprasArgs
    Productos?: boolean | ProductosArgs
  }

  export type DetalleComprasInclude = {
    Compras?: boolean | ComprasArgs
    Productos?: boolean | ProductosArgs
  }

  export type DetalleComprasGetPayload<
    S extends boolean | null | undefined | DetalleComprasArgs,
    U = keyof S
      > = S extends true
        ? DetalleCompras
    : S extends undefined
    ? never
    : S extends DetalleComprasArgs | DetalleComprasFindManyArgs
    ?'include' extends U
    ? DetalleCompras  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Compras' ? ComprasGetPayload<S['include'][P]> :
        P extends 'Productos' ? ProductosGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Compras' ? ComprasGetPayload<S['select'][P]> :
        P extends 'Productos' ? ProductosGetPayload<S['select'][P]> :  P extends keyof DetalleCompras ? DetalleCompras[P] : never
  } 
    : DetalleCompras
  : DetalleCompras


  type DetalleComprasCountArgs = Merge<
    Omit<DetalleComprasFindManyArgs, 'select' | 'include'> & {
      select?: DetalleComprasCountAggregateInputType | true
    }
  >

  export interface DetalleComprasDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DetalleCompras that matches the filter.
     * @param {DetalleComprasFindUniqueArgs} args - Arguments to find a DetalleCompras
     * @example
     * // Get one DetalleCompras
     * const detalleCompras = await prisma.detalleCompras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DetalleComprasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DetalleComprasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DetalleCompras'> extends True ? CheckSelect<T, Prisma__DetalleComprasClient<DetalleCompras>, Prisma__DetalleComprasClient<DetalleComprasGetPayload<T>>> : CheckSelect<T, Prisma__DetalleComprasClient<DetalleCompras | null >, Prisma__DetalleComprasClient<DetalleComprasGetPayload<T> | null >>

    /**
     * Find the first DetalleCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleComprasFindFirstArgs} args - Arguments to find a DetalleCompras
     * @example
     * // Get one DetalleCompras
     * const detalleCompras = await prisma.detalleCompras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DetalleComprasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DetalleComprasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DetalleCompras'> extends True ? CheckSelect<T, Prisma__DetalleComprasClient<DetalleCompras>, Prisma__DetalleComprasClient<DetalleComprasGetPayload<T>>> : CheckSelect<T, Prisma__DetalleComprasClient<DetalleCompras | null >, Prisma__DetalleComprasClient<DetalleComprasGetPayload<T> | null >>

    /**
     * Find zero or more DetalleCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleComprasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetalleCompras
     * const detalleCompras = await prisma.detalleCompras.findMany()
     * 
     * // Get first 10 DetalleCompras
     * const detalleCompras = await prisma.detalleCompras.findMany({ take: 10 })
     * 
     * // Only select the `id_detalleCompra`
     * const detalleComprasWithId_detalleCompraOnly = await prisma.detalleCompras.findMany({ select: { id_detalleCompra: true } })
     * 
    **/
    findMany<T extends DetalleComprasFindManyArgs>(
      args?: SelectSubset<T, DetalleComprasFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DetalleCompras>>, PrismaPromise<Array<DetalleComprasGetPayload<T>>>>

    /**
     * Create a DetalleCompras.
     * @param {DetalleComprasCreateArgs} args - Arguments to create a DetalleCompras.
     * @example
     * // Create one DetalleCompras
     * const DetalleCompras = await prisma.detalleCompras.create({
     *   data: {
     *     // ... data to create a DetalleCompras
     *   }
     * })
     * 
    **/
    create<T extends DetalleComprasCreateArgs>(
      args: SelectSubset<T, DetalleComprasCreateArgs>
    ): CheckSelect<T, Prisma__DetalleComprasClient<DetalleCompras>, Prisma__DetalleComprasClient<DetalleComprasGetPayload<T>>>

    /**
     * Create many DetalleCompras.
     *     @param {DetalleComprasCreateManyArgs} args - Arguments to create many DetalleCompras.
     *     @example
     *     // Create many DetalleCompras
     *     const detalleCompras = await prisma.detalleCompras.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DetalleComprasCreateManyArgs>(
      args?: SelectSubset<T, DetalleComprasCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DetalleCompras.
     * @param {DetalleComprasDeleteArgs} args - Arguments to delete one DetalleCompras.
     * @example
     * // Delete one DetalleCompras
     * const DetalleCompras = await prisma.detalleCompras.delete({
     *   where: {
     *     // ... filter to delete one DetalleCompras
     *   }
     * })
     * 
    **/
    delete<T extends DetalleComprasDeleteArgs>(
      args: SelectSubset<T, DetalleComprasDeleteArgs>
    ): CheckSelect<T, Prisma__DetalleComprasClient<DetalleCompras>, Prisma__DetalleComprasClient<DetalleComprasGetPayload<T>>>

    /**
     * Update one DetalleCompras.
     * @param {DetalleComprasUpdateArgs} args - Arguments to update one DetalleCompras.
     * @example
     * // Update one DetalleCompras
     * const detalleCompras = await prisma.detalleCompras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DetalleComprasUpdateArgs>(
      args: SelectSubset<T, DetalleComprasUpdateArgs>
    ): CheckSelect<T, Prisma__DetalleComprasClient<DetalleCompras>, Prisma__DetalleComprasClient<DetalleComprasGetPayload<T>>>

    /**
     * Delete zero or more DetalleCompras.
     * @param {DetalleComprasDeleteManyArgs} args - Arguments to filter DetalleCompras to delete.
     * @example
     * // Delete a few DetalleCompras
     * const { count } = await prisma.detalleCompras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DetalleComprasDeleteManyArgs>(
      args?: SelectSubset<T, DetalleComprasDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetalleCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleComprasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetalleCompras
     * const detalleCompras = await prisma.detalleCompras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DetalleComprasUpdateManyArgs>(
      args: SelectSubset<T, DetalleComprasUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DetalleCompras.
     * @param {DetalleComprasUpsertArgs} args - Arguments to update or create a DetalleCompras.
     * @example
     * // Update or create a DetalleCompras
     * const detalleCompras = await prisma.detalleCompras.upsert({
     *   create: {
     *     // ... data to create a DetalleCompras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetalleCompras we want to update
     *   }
     * })
    **/
    upsert<T extends DetalleComprasUpsertArgs>(
      args: SelectSubset<T, DetalleComprasUpsertArgs>
    ): CheckSelect<T, Prisma__DetalleComprasClient<DetalleCompras>, Prisma__DetalleComprasClient<DetalleComprasGetPayload<T>>>

    /**
     * Count the number of DetalleCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleComprasCountArgs} args - Arguments to filter DetalleCompras to count.
     * @example
     * // Count the number of DetalleCompras
     * const count = await prisma.detalleCompras.count({
     *   where: {
     *     // ... the filter for the DetalleCompras we want to count
     *   }
     * })
    **/
    count<T extends DetalleComprasCountArgs>(
      args?: Subset<T, DetalleComprasCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetalleComprasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetalleCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleComprasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetalleComprasAggregateArgs>(args: Subset<T, DetalleComprasAggregateArgs>): PrismaPromise<GetDetalleComprasAggregateType<T>>

    /**
     * Group by DetalleCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleComprasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetalleComprasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetalleComprasGroupByArgs['orderBy'] }
        : { orderBy?: DetalleComprasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetalleComprasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalleComprasGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetalleCompras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DetalleComprasClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Compras<T extends ComprasArgs = {}>(args?: Subset<T, ComprasArgs>): CheckSelect<T, Prisma__ComprasClient<Compras | null >, Prisma__ComprasClient<ComprasGetPayload<T> | null >>;

    Productos<T extends ProductosArgs = {}>(args?: Subset<T, ProductosArgs>): CheckSelect<T, Prisma__ProductosClient<Productos | null >, Prisma__ProductosClient<ProductosGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DetalleCompras findUnique
   */
  export type DetalleComprasFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DetalleCompras
     * 
    **/
    select?: DetalleComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetalleComprasInclude | null
    /**
     * Throw an Error if a DetalleCompras can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DetalleCompras to fetch.
     * 
    **/
    where: DetalleComprasWhereUniqueInput
  }


  /**
   * DetalleCompras findFirst
   */
  export type DetalleComprasFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DetalleCompras
     * 
    **/
    select?: DetalleComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetalleComprasInclude | null
    /**
     * Throw an Error if a DetalleCompras can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DetalleCompras to fetch.
     * 
    **/
    where?: DetalleComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     * 
    **/
    orderBy?: Enumerable<DetalleComprasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetalleCompras.
     * 
    **/
    cursor?: DetalleComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetalleCompras.
     * 
    **/
    distinct?: Enumerable<DetalleComprasScalarFieldEnum>
  }


  /**
   * DetalleCompras findMany
   */
  export type DetalleComprasFindManyArgs = {
    /**
     * Select specific fields to fetch from the DetalleCompras
     * 
    **/
    select?: DetalleComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetalleComprasInclude | null
    /**
     * Filter, which DetalleCompras to fetch.
     * 
    **/
    where?: DetalleComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     * 
    **/
    orderBy?: Enumerable<DetalleComprasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetalleCompras.
     * 
    **/
    cursor?: DetalleComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DetalleComprasScalarFieldEnum>
  }


  /**
   * DetalleCompras create
   */
  export type DetalleComprasCreateArgs = {
    /**
     * Select specific fields to fetch from the DetalleCompras
     * 
    **/
    select?: DetalleComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetalleComprasInclude | null
    /**
     * The data needed to create a DetalleCompras.
     * 
    **/
    data: XOR<DetalleComprasCreateInput, DetalleComprasUncheckedCreateInput>
  }


  /**
   * DetalleCompras createMany
   */
  export type DetalleComprasCreateManyArgs = {
    /**
     * The data used to create many DetalleCompras.
     * 
    **/
    data: Enumerable<DetalleComprasCreateManyInput>
  }


  /**
   * DetalleCompras update
   */
  export type DetalleComprasUpdateArgs = {
    /**
     * Select specific fields to fetch from the DetalleCompras
     * 
    **/
    select?: DetalleComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetalleComprasInclude | null
    /**
     * The data needed to update a DetalleCompras.
     * 
    **/
    data: XOR<DetalleComprasUpdateInput, DetalleComprasUncheckedUpdateInput>
    /**
     * Choose, which DetalleCompras to update.
     * 
    **/
    where: DetalleComprasWhereUniqueInput
  }


  /**
   * DetalleCompras updateMany
   */
  export type DetalleComprasUpdateManyArgs = {
    /**
     * The data used to update DetalleCompras.
     * 
    **/
    data: XOR<DetalleComprasUpdateManyMutationInput, DetalleComprasUncheckedUpdateManyInput>
    /**
     * Filter which DetalleCompras to update
     * 
    **/
    where?: DetalleComprasWhereInput
  }


  /**
   * DetalleCompras upsert
   */
  export type DetalleComprasUpsertArgs = {
    /**
     * Select specific fields to fetch from the DetalleCompras
     * 
    **/
    select?: DetalleComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetalleComprasInclude | null
    /**
     * The filter to search for the DetalleCompras to update in case it exists.
     * 
    **/
    where: DetalleComprasWhereUniqueInput
    /**
     * In case the DetalleCompras found by the `where` argument doesn't exist, create a new DetalleCompras with this data.
     * 
    **/
    create: XOR<DetalleComprasCreateInput, DetalleComprasUncheckedCreateInput>
    /**
     * In case the DetalleCompras was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DetalleComprasUpdateInput, DetalleComprasUncheckedUpdateInput>
  }


  /**
   * DetalleCompras delete
   */
  export type DetalleComprasDeleteArgs = {
    /**
     * Select specific fields to fetch from the DetalleCompras
     * 
    **/
    select?: DetalleComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetalleComprasInclude | null
    /**
     * Filter which DetalleCompras to delete.
     * 
    **/
    where: DetalleComprasWhereUniqueInput
  }


  /**
   * DetalleCompras deleteMany
   */
  export type DetalleComprasDeleteManyArgs = {
    /**
     * Filter which DetalleCompras to delete
     * 
    **/
    where?: DetalleComprasWhereInput
  }


  /**
   * DetalleCompras without action
   */
  export type DetalleComprasArgs = {
    /**
     * Select specific fields to fetch from the DetalleCompras
     * 
    **/
    select?: DetalleComprasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetalleComprasInclude | null
  }



  /**
   * Model DetallesVentas
   */


  export type AggregateDetallesVentas = {
    _count: DetallesVentasCountAggregateOutputType | null
    _avg: DetallesVentasAvgAggregateOutputType | null
    _sum: DetallesVentasSumAggregateOutputType | null
    _min: DetallesVentasMinAggregateOutputType | null
    _max: DetallesVentasMaxAggregateOutputType | null
  }

  export type DetallesVentasAvgAggregateOutputType = {
    id_detalleVenta: number | null
    id_producto: number | null
    id_venta: number | null
    precio: number | null
    cantidad: number | null
  }

  export type DetallesVentasSumAggregateOutputType = {
    id_detalleVenta: number | null
    id_producto: number | null
    id_venta: number | null
    precio: number | null
    cantidad: number | null
  }

  export type DetallesVentasMinAggregateOutputType = {
    id_detalleVenta: number | null
    id_producto: number | null
    id_venta: number | null
    precio: number | null
    cantidad: number | null
  }

  export type DetallesVentasMaxAggregateOutputType = {
    id_detalleVenta: number | null
    id_producto: number | null
    id_venta: number | null
    precio: number | null
    cantidad: number | null
  }

  export type DetallesVentasCountAggregateOutputType = {
    id_detalleVenta: number
    id_producto: number
    id_venta: number
    precio: number
    cantidad: number
    _all: number
  }


  export type DetallesVentasAvgAggregateInputType = {
    id_detalleVenta?: true
    id_producto?: true
    id_venta?: true
    precio?: true
    cantidad?: true
  }

  export type DetallesVentasSumAggregateInputType = {
    id_detalleVenta?: true
    id_producto?: true
    id_venta?: true
    precio?: true
    cantidad?: true
  }

  export type DetallesVentasMinAggregateInputType = {
    id_detalleVenta?: true
    id_producto?: true
    id_venta?: true
    precio?: true
    cantidad?: true
  }

  export type DetallesVentasMaxAggregateInputType = {
    id_detalleVenta?: true
    id_producto?: true
    id_venta?: true
    precio?: true
    cantidad?: true
  }

  export type DetallesVentasCountAggregateInputType = {
    id_detalleVenta?: true
    id_producto?: true
    id_venta?: true
    precio?: true
    cantidad?: true
    _all?: true
  }

  export type DetallesVentasAggregateArgs = {
    /**
     * Filter which DetallesVentas to aggregate.
     * 
    **/
    where?: DetallesVentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetallesVentas to fetch.
     * 
    **/
    orderBy?: Enumerable<DetallesVentasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DetallesVentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetallesVentas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetallesVentas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetallesVentas
    **/
    _count?: true | DetallesVentasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetallesVentasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetallesVentasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetallesVentasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetallesVentasMaxAggregateInputType
  }

  export type GetDetallesVentasAggregateType<T extends DetallesVentasAggregateArgs> = {
        [P in keyof T & keyof AggregateDetallesVentas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetallesVentas[P]>
      : GetScalarType<T[P], AggregateDetallesVentas[P]>
  }




  export type DetallesVentasGroupByArgs = {
    where?: DetallesVentasWhereInput
    orderBy?: Enumerable<DetallesVentasOrderByWithAggregationInput>
    by: Array<DetallesVentasScalarFieldEnum>
    having?: DetallesVentasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetallesVentasCountAggregateInputType | true
    _avg?: DetallesVentasAvgAggregateInputType
    _sum?: DetallesVentasSumAggregateInputType
    _min?: DetallesVentasMinAggregateInputType
    _max?: DetallesVentasMaxAggregateInputType
  }


  export type DetallesVentasGroupByOutputType = {
    id_detalleVenta: number
    id_producto: number
    id_venta: number
    precio: number
    cantidad: number
    _count: DetallesVentasCountAggregateOutputType | null
    _avg: DetallesVentasAvgAggregateOutputType | null
    _sum: DetallesVentasSumAggregateOutputType | null
    _min: DetallesVentasMinAggregateOutputType | null
    _max: DetallesVentasMaxAggregateOutputType | null
  }

  type GetDetallesVentasGroupByPayload<T extends DetallesVentasGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DetallesVentasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetallesVentasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetallesVentasGroupByOutputType[P]>
            : GetScalarType<T[P], DetallesVentasGroupByOutputType[P]>
        }
      >
    >


  export type DetallesVentasSelect = {
    id_detalleVenta?: boolean
    id_producto?: boolean
    id_venta?: boolean
    precio?: boolean
    cantidad?: boolean
    Productos?: boolean | ProductosArgs
    Venta?: boolean | VentaArgs
  }

  export type DetallesVentasInclude = {
    Productos?: boolean | ProductosArgs
    Venta?: boolean | VentaArgs
  }

  export type DetallesVentasGetPayload<
    S extends boolean | null | undefined | DetallesVentasArgs,
    U = keyof S
      > = S extends true
        ? DetallesVentas
    : S extends undefined
    ? never
    : S extends DetallesVentasArgs | DetallesVentasFindManyArgs
    ?'include' extends U
    ? DetallesVentas  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Productos' ? ProductosGetPayload<S['include'][P]> :
        P extends 'Venta' ? VentaGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Productos' ? ProductosGetPayload<S['select'][P]> :
        P extends 'Venta' ? VentaGetPayload<S['select'][P]> :  P extends keyof DetallesVentas ? DetallesVentas[P] : never
  } 
    : DetallesVentas
  : DetallesVentas


  type DetallesVentasCountArgs = Merge<
    Omit<DetallesVentasFindManyArgs, 'select' | 'include'> & {
      select?: DetallesVentasCountAggregateInputType | true
    }
  >

  export interface DetallesVentasDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DetallesVentas that matches the filter.
     * @param {DetallesVentasFindUniqueArgs} args - Arguments to find a DetallesVentas
     * @example
     * // Get one DetallesVentas
     * const detallesVentas = await prisma.detallesVentas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DetallesVentasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DetallesVentasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DetallesVentas'> extends True ? CheckSelect<T, Prisma__DetallesVentasClient<DetallesVentas>, Prisma__DetallesVentasClient<DetallesVentasGetPayload<T>>> : CheckSelect<T, Prisma__DetallesVentasClient<DetallesVentas | null >, Prisma__DetallesVentasClient<DetallesVentasGetPayload<T> | null >>

    /**
     * Find the first DetallesVentas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesVentasFindFirstArgs} args - Arguments to find a DetallesVentas
     * @example
     * // Get one DetallesVentas
     * const detallesVentas = await prisma.detallesVentas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DetallesVentasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DetallesVentasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DetallesVentas'> extends True ? CheckSelect<T, Prisma__DetallesVentasClient<DetallesVentas>, Prisma__DetallesVentasClient<DetallesVentasGetPayload<T>>> : CheckSelect<T, Prisma__DetallesVentasClient<DetallesVentas | null >, Prisma__DetallesVentasClient<DetallesVentasGetPayload<T> | null >>

    /**
     * Find zero or more DetallesVentas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesVentasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetallesVentas
     * const detallesVentas = await prisma.detallesVentas.findMany()
     * 
     * // Get first 10 DetallesVentas
     * const detallesVentas = await prisma.detallesVentas.findMany({ take: 10 })
     * 
     * // Only select the `id_detalleVenta`
     * const detallesVentasWithId_detalleVentaOnly = await prisma.detallesVentas.findMany({ select: { id_detalleVenta: true } })
     * 
    **/
    findMany<T extends DetallesVentasFindManyArgs>(
      args?: SelectSubset<T, DetallesVentasFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DetallesVentas>>, PrismaPromise<Array<DetallesVentasGetPayload<T>>>>

    /**
     * Create a DetallesVentas.
     * @param {DetallesVentasCreateArgs} args - Arguments to create a DetallesVentas.
     * @example
     * // Create one DetallesVentas
     * const DetallesVentas = await prisma.detallesVentas.create({
     *   data: {
     *     // ... data to create a DetallesVentas
     *   }
     * })
     * 
    **/
    create<T extends DetallesVentasCreateArgs>(
      args: SelectSubset<T, DetallesVentasCreateArgs>
    ): CheckSelect<T, Prisma__DetallesVentasClient<DetallesVentas>, Prisma__DetallesVentasClient<DetallesVentasGetPayload<T>>>

    /**
     * Create many DetallesVentas.
     *     @param {DetallesVentasCreateManyArgs} args - Arguments to create many DetallesVentas.
     *     @example
     *     // Create many DetallesVentas
     *     const detallesVentas = await prisma.detallesVentas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DetallesVentasCreateManyArgs>(
      args?: SelectSubset<T, DetallesVentasCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DetallesVentas.
     * @param {DetallesVentasDeleteArgs} args - Arguments to delete one DetallesVentas.
     * @example
     * // Delete one DetallesVentas
     * const DetallesVentas = await prisma.detallesVentas.delete({
     *   where: {
     *     // ... filter to delete one DetallesVentas
     *   }
     * })
     * 
    **/
    delete<T extends DetallesVentasDeleteArgs>(
      args: SelectSubset<T, DetallesVentasDeleteArgs>
    ): CheckSelect<T, Prisma__DetallesVentasClient<DetallesVentas>, Prisma__DetallesVentasClient<DetallesVentasGetPayload<T>>>

    /**
     * Update one DetallesVentas.
     * @param {DetallesVentasUpdateArgs} args - Arguments to update one DetallesVentas.
     * @example
     * // Update one DetallesVentas
     * const detallesVentas = await prisma.detallesVentas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DetallesVentasUpdateArgs>(
      args: SelectSubset<T, DetallesVentasUpdateArgs>
    ): CheckSelect<T, Prisma__DetallesVentasClient<DetallesVentas>, Prisma__DetallesVentasClient<DetallesVentasGetPayload<T>>>

    /**
     * Delete zero or more DetallesVentas.
     * @param {DetallesVentasDeleteManyArgs} args - Arguments to filter DetallesVentas to delete.
     * @example
     * // Delete a few DetallesVentas
     * const { count } = await prisma.detallesVentas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DetallesVentasDeleteManyArgs>(
      args?: SelectSubset<T, DetallesVentasDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetallesVentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesVentasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetallesVentas
     * const detallesVentas = await prisma.detallesVentas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DetallesVentasUpdateManyArgs>(
      args: SelectSubset<T, DetallesVentasUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DetallesVentas.
     * @param {DetallesVentasUpsertArgs} args - Arguments to update or create a DetallesVentas.
     * @example
     * // Update or create a DetallesVentas
     * const detallesVentas = await prisma.detallesVentas.upsert({
     *   create: {
     *     // ... data to create a DetallesVentas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetallesVentas we want to update
     *   }
     * })
    **/
    upsert<T extends DetallesVentasUpsertArgs>(
      args: SelectSubset<T, DetallesVentasUpsertArgs>
    ): CheckSelect<T, Prisma__DetallesVentasClient<DetallesVentas>, Prisma__DetallesVentasClient<DetallesVentasGetPayload<T>>>

    /**
     * Count the number of DetallesVentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesVentasCountArgs} args - Arguments to filter DetallesVentas to count.
     * @example
     * // Count the number of DetallesVentas
     * const count = await prisma.detallesVentas.count({
     *   where: {
     *     // ... the filter for the DetallesVentas we want to count
     *   }
     * })
    **/
    count<T extends DetallesVentasCountArgs>(
      args?: Subset<T, DetallesVentasCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetallesVentasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetallesVentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesVentasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetallesVentasAggregateArgs>(args: Subset<T, DetallesVentasAggregateArgs>): PrismaPromise<GetDetallesVentasAggregateType<T>>

    /**
     * Group by DetallesVentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesVentasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetallesVentasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetallesVentasGroupByArgs['orderBy'] }
        : { orderBy?: DetallesVentasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetallesVentasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetallesVentasGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetallesVentas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DetallesVentasClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Productos<T extends ProductosArgs = {}>(args?: Subset<T, ProductosArgs>): CheckSelect<T, Prisma__ProductosClient<Productos | null >, Prisma__ProductosClient<ProductosGetPayload<T> | null >>;

    Venta<T extends VentaArgs = {}>(args?: Subset<T, VentaArgs>): CheckSelect<T, Prisma__VentaClient<Venta | null >, Prisma__VentaClient<VentaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DetallesVentas findUnique
   */
  export type DetallesVentasFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DetallesVentas
     * 
    **/
    select?: DetallesVentasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallesVentasInclude | null
    /**
     * Throw an Error if a DetallesVentas can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DetallesVentas to fetch.
     * 
    **/
    where: DetallesVentasWhereUniqueInput
  }


  /**
   * DetallesVentas findFirst
   */
  export type DetallesVentasFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DetallesVentas
     * 
    **/
    select?: DetallesVentasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallesVentasInclude | null
    /**
     * Throw an Error if a DetallesVentas can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DetallesVentas to fetch.
     * 
    **/
    where?: DetallesVentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetallesVentas to fetch.
     * 
    **/
    orderBy?: Enumerable<DetallesVentasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetallesVentas.
     * 
    **/
    cursor?: DetallesVentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetallesVentas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetallesVentas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetallesVentas.
     * 
    **/
    distinct?: Enumerable<DetallesVentasScalarFieldEnum>
  }


  /**
   * DetallesVentas findMany
   */
  export type DetallesVentasFindManyArgs = {
    /**
     * Select specific fields to fetch from the DetallesVentas
     * 
    **/
    select?: DetallesVentasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallesVentasInclude | null
    /**
     * Filter, which DetallesVentas to fetch.
     * 
    **/
    where?: DetallesVentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetallesVentas to fetch.
     * 
    **/
    orderBy?: Enumerable<DetallesVentasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetallesVentas.
     * 
    **/
    cursor?: DetallesVentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetallesVentas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetallesVentas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DetallesVentasScalarFieldEnum>
  }


  /**
   * DetallesVentas create
   */
  export type DetallesVentasCreateArgs = {
    /**
     * Select specific fields to fetch from the DetallesVentas
     * 
    **/
    select?: DetallesVentasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallesVentasInclude | null
    /**
     * The data needed to create a DetallesVentas.
     * 
    **/
    data: XOR<DetallesVentasCreateInput, DetallesVentasUncheckedCreateInput>
  }


  /**
   * DetallesVentas createMany
   */
  export type DetallesVentasCreateManyArgs = {
    /**
     * The data used to create many DetallesVentas.
     * 
    **/
    data: Enumerable<DetallesVentasCreateManyInput>
  }


  /**
   * DetallesVentas update
   */
  export type DetallesVentasUpdateArgs = {
    /**
     * Select specific fields to fetch from the DetallesVentas
     * 
    **/
    select?: DetallesVentasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallesVentasInclude | null
    /**
     * The data needed to update a DetallesVentas.
     * 
    **/
    data: XOR<DetallesVentasUpdateInput, DetallesVentasUncheckedUpdateInput>
    /**
     * Choose, which DetallesVentas to update.
     * 
    **/
    where: DetallesVentasWhereUniqueInput
  }


  /**
   * DetallesVentas updateMany
   */
  export type DetallesVentasUpdateManyArgs = {
    /**
     * The data used to update DetallesVentas.
     * 
    **/
    data: XOR<DetallesVentasUpdateManyMutationInput, DetallesVentasUncheckedUpdateManyInput>
    /**
     * Filter which DetallesVentas to update
     * 
    **/
    where?: DetallesVentasWhereInput
  }


  /**
   * DetallesVentas upsert
   */
  export type DetallesVentasUpsertArgs = {
    /**
     * Select specific fields to fetch from the DetallesVentas
     * 
    **/
    select?: DetallesVentasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallesVentasInclude | null
    /**
     * The filter to search for the DetallesVentas to update in case it exists.
     * 
    **/
    where: DetallesVentasWhereUniqueInput
    /**
     * In case the DetallesVentas found by the `where` argument doesn't exist, create a new DetallesVentas with this data.
     * 
    **/
    create: XOR<DetallesVentasCreateInput, DetallesVentasUncheckedCreateInput>
    /**
     * In case the DetallesVentas was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DetallesVentasUpdateInput, DetallesVentasUncheckedUpdateInput>
  }


  /**
   * DetallesVentas delete
   */
  export type DetallesVentasDeleteArgs = {
    /**
     * Select specific fields to fetch from the DetallesVentas
     * 
    **/
    select?: DetallesVentasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallesVentasInclude | null
    /**
     * Filter which DetallesVentas to delete.
     * 
    **/
    where: DetallesVentasWhereUniqueInput
  }


  /**
   * DetallesVentas deleteMany
   */
  export type DetallesVentasDeleteManyArgs = {
    /**
     * Filter which DetallesVentas to delete
     * 
    **/
    where?: DetallesVentasWhereInput
  }


  /**
   * DetallesVentas without action
   */
  export type DetallesVentasArgs = {
    /**
     * Select specific fields to fetch from the DetallesVentas
     * 
    **/
    select?: DetallesVentasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallesVentasInclude | null
  }



  /**
   * Model DireccionesEnvio
   */


  export type AggregateDireccionesEnvio = {
    _count: DireccionesEnvioCountAggregateOutputType | null
    _avg: DireccionesEnvioAvgAggregateOutputType | null
    _sum: DireccionesEnvioSumAggregateOutputType | null
    _min: DireccionesEnvioMinAggregateOutputType | null
    _max: DireccionesEnvioMaxAggregateOutputType | null
  }

  export type DireccionesEnvioAvgAggregateOutputType = {
    id_direccionEnvio: number | null
    id_ciudad: number | null
    id_usuarioCliente: number | null
  }

  export type DireccionesEnvioSumAggregateOutputType = {
    id_direccionEnvio: number | null
    id_ciudad: number | null
    id_usuarioCliente: number | null
  }

  export type DireccionesEnvioMinAggregateOutputType = {
    id_direccionEnvio: number | null
    direccion: string | null
    id_ciudad: number | null
    id_usuarioCliente: number | null
    direccion_opcional: string | null
  }

  export type DireccionesEnvioMaxAggregateOutputType = {
    id_direccionEnvio: number | null
    direccion: string | null
    id_ciudad: number | null
    id_usuarioCliente: number | null
    direccion_opcional: string | null
  }

  export type DireccionesEnvioCountAggregateOutputType = {
    id_direccionEnvio: number
    direccion: number
    id_ciudad: number
    id_usuarioCliente: number
    direccion_opcional: number
    _all: number
  }


  export type DireccionesEnvioAvgAggregateInputType = {
    id_direccionEnvio?: true
    id_ciudad?: true
    id_usuarioCliente?: true
  }

  export type DireccionesEnvioSumAggregateInputType = {
    id_direccionEnvio?: true
    id_ciudad?: true
    id_usuarioCliente?: true
  }

  export type DireccionesEnvioMinAggregateInputType = {
    id_direccionEnvio?: true
    direccion?: true
    id_ciudad?: true
    id_usuarioCliente?: true
    direccion_opcional?: true
  }

  export type DireccionesEnvioMaxAggregateInputType = {
    id_direccionEnvio?: true
    direccion?: true
    id_ciudad?: true
    id_usuarioCliente?: true
    direccion_opcional?: true
  }

  export type DireccionesEnvioCountAggregateInputType = {
    id_direccionEnvio?: true
    direccion?: true
    id_ciudad?: true
    id_usuarioCliente?: true
    direccion_opcional?: true
    _all?: true
  }

  export type DireccionesEnvioAggregateArgs = {
    /**
     * Filter which DireccionesEnvio to aggregate.
     * 
    **/
    where?: DireccionesEnvioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DireccionesEnvios to fetch.
     * 
    **/
    orderBy?: Enumerable<DireccionesEnvioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DireccionesEnvioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DireccionesEnvios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DireccionesEnvios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DireccionesEnvios
    **/
    _count?: true | DireccionesEnvioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DireccionesEnvioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DireccionesEnvioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DireccionesEnvioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DireccionesEnvioMaxAggregateInputType
  }

  export type GetDireccionesEnvioAggregateType<T extends DireccionesEnvioAggregateArgs> = {
        [P in keyof T & keyof AggregateDireccionesEnvio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDireccionesEnvio[P]>
      : GetScalarType<T[P], AggregateDireccionesEnvio[P]>
  }




  export type DireccionesEnvioGroupByArgs = {
    where?: DireccionesEnvioWhereInput
    orderBy?: Enumerable<DireccionesEnvioOrderByWithAggregationInput>
    by: Array<DireccionesEnvioScalarFieldEnum>
    having?: DireccionesEnvioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DireccionesEnvioCountAggregateInputType | true
    _avg?: DireccionesEnvioAvgAggregateInputType
    _sum?: DireccionesEnvioSumAggregateInputType
    _min?: DireccionesEnvioMinAggregateInputType
    _max?: DireccionesEnvioMaxAggregateInputType
  }


  export type DireccionesEnvioGroupByOutputType = {
    id_direccionEnvio: number
    direccion: string
    id_ciudad: number
    id_usuarioCliente: number
    direccion_opcional: string
    _count: DireccionesEnvioCountAggregateOutputType | null
    _avg: DireccionesEnvioAvgAggregateOutputType | null
    _sum: DireccionesEnvioSumAggregateOutputType | null
    _min: DireccionesEnvioMinAggregateOutputType | null
    _max: DireccionesEnvioMaxAggregateOutputType | null
  }

  type GetDireccionesEnvioGroupByPayload<T extends DireccionesEnvioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DireccionesEnvioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DireccionesEnvioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DireccionesEnvioGroupByOutputType[P]>
            : GetScalarType<T[P], DireccionesEnvioGroupByOutputType[P]>
        }
      >
    >


  export type DireccionesEnvioSelect = {
    id_direccionEnvio?: boolean
    direccion?: boolean
    id_ciudad?: boolean
    id_usuarioCliente?: boolean
    direccion_opcional?: boolean
    Ciudades?: boolean | CiudadesArgs
    usuariosClientes?: boolean | usuariosClientesArgs
    Venta?: boolean | VentaFindManyArgs
    _count?: boolean | DireccionesEnvioCountOutputTypeArgs
  }

  export type DireccionesEnvioInclude = {
    Ciudades?: boolean | CiudadesArgs
    usuariosClientes?: boolean | usuariosClientesArgs
    Venta?: boolean | VentaFindManyArgs
    _count?: boolean | DireccionesEnvioCountOutputTypeArgs
  }

  export type DireccionesEnvioGetPayload<
    S extends boolean | null | undefined | DireccionesEnvioArgs,
    U = keyof S
      > = S extends true
        ? DireccionesEnvio
    : S extends undefined
    ? never
    : S extends DireccionesEnvioArgs | DireccionesEnvioFindManyArgs
    ?'include' extends U
    ? DireccionesEnvio  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Ciudades' ? CiudadesGetPayload<S['include'][P]> :
        P extends 'usuariosClientes' ? usuariosClientesGetPayload<S['include'][P]> :
        P extends 'Venta' ? Array < VentaGetPayload<S['include'][P]>>  :
        P extends '_count' ? DireccionesEnvioCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Ciudades' ? CiudadesGetPayload<S['select'][P]> :
        P extends 'usuariosClientes' ? usuariosClientesGetPayload<S['select'][P]> :
        P extends 'Venta' ? Array < VentaGetPayload<S['select'][P]>>  :
        P extends '_count' ? DireccionesEnvioCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof DireccionesEnvio ? DireccionesEnvio[P] : never
  } 
    : DireccionesEnvio
  : DireccionesEnvio


  type DireccionesEnvioCountArgs = Merge<
    Omit<DireccionesEnvioFindManyArgs, 'select' | 'include'> & {
      select?: DireccionesEnvioCountAggregateInputType | true
    }
  >

  export interface DireccionesEnvioDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DireccionesEnvio that matches the filter.
     * @param {DireccionesEnvioFindUniqueArgs} args - Arguments to find a DireccionesEnvio
     * @example
     * // Get one DireccionesEnvio
     * const direccionesEnvio = await prisma.direccionesEnvio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DireccionesEnvioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DireccionesEnvioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DireccionesEnvio'> extends True ? CheckSelect<T, Prisma__DireccionesEnvioClient<DireccionesEnvio>, Prisma__DireccionesEnvioClient<DireccionesEnvioGetPayload<T>>> : CheckSelect<T, Prisma__DireccionesEnvioClient<DireccionesEnvio | null >, Prisma__DireccionesEnvioClient<DireccionesEnvioGetPayload<T> | null >>

    /**
     * Find the first DireccionesEnvio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionesEnvioFindFirstArgs} args - Arguments to find a DireccionesEnvio
     * @example
     * // Get one DireccionesEnvio
     * const direccionesEnvio = await prisma.direccionesEnvio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DireccionesEnvioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DireccionesEnvioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DireccionesEnvio'> extends True ? CheckSelect<T, Prisma__DireccionesEnvioClient<DireccionesEnvio>, Prisma__DireccionesEnvioClient<DireccionesEnvioGetPayload<T>>> : CheckSelect<T, Prisma__DireccionesEnvioClient<DireccionesEnvio | null >, Prisma__DireccionesEnvioClient<DireccionesEnvioGetPayload<T> | null >>

    /**
     * Find zero or more DireccionesEnvios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionesEnvioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DireccionesEnvios
     * const direccionesEnvios = await prisma.direccionesEnvio.findMany()
     * 
     * // Get first 10 DireccionesEnvios
     * const direccionesEnvios = await prisma.direccionesEnvio.findMany({ take: 10 })
     * 
     * // Only select the `id_direccionEnvio`
     * const direccionesEnvioWithId_direccionEnvioOnly = await prisma.direccionesEnvio.findMany({ select: { id_direccionEnvio: true } })
     * 
    **/
    findMany<T extends DireccionesEnvioFindManyArgs>(
      args?: SelectSubset<T, DireccionesEnvioFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DireccionesEnvio>>, PrismaPromise<Array<DireccionesEnvioGetPayload<T>>>>

    /**
     * Create a DireccionesEnvio.
     * @param {DireccionesEnvioCreateArgs} args - Arguments to create a DireccionesEnvio.
     * @example
     * // Create one DireccionesEnvio
     * const DireccionesEnvio = await prisma.direccionesEnvio.create({
     *   data: {
     *     // ... data to create a DireccionesEnvio
     *   }
     * })
     * 
    **/
    create<T extends DireccionesEnvioCreateArgs>(
      args: SelectSubset<T, DireccionesEnvioCreateArgs>
    ): CheckSelect<T, Prisma__DireccionesEnvioClient<DireccionesEnvio>, Prisma__DireccionesEnvioClient<DireccionesEnvioGetPayload<T>>>

    /**
     * Create many DireccionesEnvios.
     *     @param {DireccionesEnvioCreateManyArgs} args - Arguments to create many DireccionesEnvios.
     *     @example
     *     // Create many DireccionesEnvios
     *     const direccionesEnvio = await prisma.direccionesEnvio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DireccionesEnvioCreateManyArgs>(
      args?: SelectSubset<T, DireccionesEnvioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DireccionesEnvio.
     * @param {DireccionesEnvioDeleteArgs} args - Arguments to delete one DireccionesEnvio.
     * @example
     * // Delete one DireccionesEnvio
     * const DireccionesEnvio = await prisma.direccionesEnvio.delete({
     *   where: {
     *     // ... filter to delete one DireccionesEnvio
     *   }
     * })
     * 
    **/
    delete<T extends DireccionesEnvioDeleteArgs>(
      args: SelectSubset<T, DireccionesEnvioDeleteArgs>
    ): CheckSelect<T, Prisma__DireccionesEnvioClient<DireccionesEnvio>, Prisma__DireccionesEnvioClient<DireccionesEnvioGetPayload<T>>>

    /**
     * Update one DireccionesEnvio.
     * @param {DireccionesEnvioUpdateArgs} args - Arguments to update one DireccionesEnvio.
     * @example
     * // Update one DireccionesEnvio
     * const direccionesEnvio = await prisma.direccionesEnvio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DireccionesEnvioUpdateArgs>(
      args: SelectSubset<T, DireccionesEnvioUpdateArgs>
    ): CheckSelect<T, Prisma__DireccionesEnvioClient<DireccionesEnvio>, Prisma__DireccionesEnvioClient<DireccionesEnvioGetPayload<T>>>

    /**
     * Delete zero or more DireccionesEnvios.
     * @param {DireccionesEnvioDeleteManyArgs} args - Arguments to filter DireccionesEnvios to delete.
     * @example
     * // Delete a few DireccionesEnvios
     * const { count } = await prisma.direccionesEnvio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DireccionesEnvioDeleteManyArgs>(
      args?: SelectSubset<T, DireccionesEnvioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DireccionesEnvios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionesEnvioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DireccionesEnvios
     * const direccionesEnvio = await prisma.direccionesEnvio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DireccionesEnvioUpdateManyArgs>(
      args: SelectSubset<T, DireccionesEnvioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DireccionesEnvio.
     * @param {DireccionesEnvioUpsertArgs} args - Arguments to update or create a DireccionesEnvio.
     * @example
     * // Update or create a DireccionesEnvio
     * const direccionesEnvio = await prisma.direccionesEnvio.upsert({
     *   create: {
     *     // ... data to create a DireccionesEnvio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DireccionesEnvio we want to update
     *   }
     * })
    **/
    upsert<T extends DireccionesEnvioUpsertArgs>(
      args: SelectSubset<T, DireccionesEnvioUpsertArgs>
    ): CheckSelect<T, Prisma__DireccionesEnvioClient<DireccionesEnvio>, Prisma__DireccionesEnvioClient<DireccionesEnvioGetPayload<T>>>

    /**
     * Count the number of DireccionesEnvios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionesEnvioCountArgs} args - Arguments to filter DireccionesEnvios to count.
     * @example
     * // Count the number of DireccionesEnvios
     * const count = await prisma.direccionesEnvio.count({
     *   where: {
     *     // ... the filter for the DireccionesEnvios we want to count
     *   }
     * })
    **/
    count<T extends DireccionesEnvioCountArgs>(
      args?: Subset<T, DireccionesEnvioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DireccionesEnvioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DireccionesEnvio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionesEnvioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DireccionesEnvioAggregateArgs>(args: Subset<T, DireccionesEnvioAggregateArgs>): PrismaPromise<GetDireccionesEnvioAggregateType<T>>

    /**
     * Group by DireccionesEnvio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionesEnvioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DireccionesEnvioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DireccionesEnvioGroupByArgs['orderBy'] }
        : { orderBy?: DireccionesEnvioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DireccionesEnvioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDireccionesEnvioGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DireccionesEnvio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DireccionesEnvioClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Ciudades<T extends CiudadesArgs = {}>(args?: Subset<T, CiudadesArgs>): CheckSelect<T, Prisma__CiudadesClient<Ciudades | null >, Prisma__CiudadesClient<CiudadesGetPayload<T> | null >>;

    usuariosClientes<T extends usuariosClientesArgs = {}>(args?: Subset<T, usuariosClientesArgs>): CheckSelect<T, Prisma__usuariosClientesClient<usuariosClientes | null >, Prisma__usuariosClientesClient<usuariosClientesGetPayload<T> | null >>;

    Venta<T extends VentaFindManyArgs = {}>(args?: Subset<T, VentaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Venta>>, PrismaPromise<Array<VentaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DireccionesEnvio findUnique
   */
  export type DireccionesEnvioFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DireccionesEnvio
     * 
    **/
    select?: DireccionesEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionesEnvioInclude | null
    /**
     * Throw an Error if a DireccionesEnvio can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DireccionesEnvio to fetch.
     * 
    **/
    where: DireccionesEnvioWhereUniqueInput
  }


  /**
   * DireccionesEnvio findFirst
   */
  export type DireccionesEnvioFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DireccionesEnvio
     * 
    **/
    select?: DireccionesEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionesEnvioInclude | null
    /**
     * Throw an Error if a DireccionesEnvio can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DireccionesEnvio to fetch.
     * 
    **/
    where?: DireccionesEnvioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DireccionesEnvios to fetch.
     * 
    **/
    orderBy?: Enumerable<DireccionesEnvioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DireccionesEnvios.
     * 
    **/
    cursor?: DireccionesEnvioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DireccionesEnvios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DireccionesEnvios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DireccionesEnvios.
     * 
    **/
    distinct?: Enumerable<DireccionesEnvioScalarFieldEnum>
  }


  /**
   * DireccionesEnvio findMany
   */
  export type DireccionesEnvioFindManyArgs = {
    /**
     * Select specific fields to fetch from the DireccionesEnvio
     * 
    **/
    select?: DireccionesEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionesEnvioInclude | null
    /**
     * Filter, which DireccionesEnvios to fetch.
     * 
    **/
    where?: DireccionesEnvioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DireccionesEnvios to fetch.
     * 
    **/
    orderBy?: Enumerable<DireccionesEnvioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DireccionesEnvios.
     * 
    **/
    cursor?: DireccionesEnvioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DireccionesEnvios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DireccionesEnvios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DireccionesEnvioScalarFieldEnum>
  }


  /**
   * DireccionesEnvio create
   */
  export type DireccionesEnvioCreateArgs = {
    /**
     * Select specific fields to fetch from the DireccionesEnvio
     * 
    **/
    select?: DireccionesEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionesEnvioInclude | null
    /**
     * The data needed to create a DireccionesEnvio.
     * 
    **/
    data: XOR<DireccionesEnvioCreateInput, DireccionesEnvioUncheckedCreateInput>
  }


  /**
   * DireccionesEnvio createMany
   */
  export type DireccionesEnvioCreateManyArgs = {
    /**
     * The data used to create many DireccionesEnvios.
     * 
    **/
    data: Enumerable<DireccionesEnvioCreateManyInput>
  }


  /**
   * DireccionesEnvio update
   */
  export type DireccionesEnvioUpdateArgs = {
    /**
     * Select specific fields to fetch from the DireccionesEnvio
     * 
    **/
    select?: DireccionesEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionesEnvioInclude | null
    /**
     * The data needed to update a DireccionesEnvio.
     * 
    **/
    data: XOR<DireccionesEnvioUpdateInput, DireccionesEnvioUncheckedUpdateInput>
    /**
     * Choose, which DireccionesEnvio to update.
     * 
    **/
    where: DireccionesEnvioWhereUniqueInput
  }


  /**
   * DireccionesEnvio updateMany
   */
  export type DireccionesEnvioUpdateManyArgs = {
    /**
     * The data used to update DireccionesEnvios.
     * 
    **/
    data: XOR<DireccionesEnvioUpdateManyMutationInput, DireccionesEnvioUncheckedUpdateManyInput>
    /**
     * Filter which DireccionesEnvios to update
     * 
    **/
    where?: DireccionesEnvioWhereInput
  }


  /**
   * DireccionesEnvio upsert
   */
  export type DireccionesEnvioUpsertArgs = {
    /**
     * Select specific fields to fetch from the DireccionesEnvio
     * 
    **/
    select?: DireccionesEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionesEnvioInclude | null
    /**
     * The filter to search for the DireccionesEnvio to update in case it exists.
     * 
    **/
    where: DireccionesEnvioWhereUniqueInput
    /**
     * In case the DireccionesEnvio found by the `where` argument doesn't exist, create a new DireccionesEnvio with this data.
     * 
    **/
    create: XOR<DireccionesEnvioCreateInput, DireccionesEnvioUncheckedCreateInput>
    /**
     * In case the DireccionesEnvio was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DireccionesEnvioUpdateInput, DireccionesEnvioUncheckedUpdateInput>
  }


  /**
   * DireccionesEnvio delete
   */
  export type DireccionesEnvioDeleteArgs = {
    /**
     * Select specific fields to fetch from the DireccionesEnvio
     * 
    **/
    select?: DireccionesEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionesEnvioInclude | null
    /**
     * Filter which DireccionesEnvio to delete.
     * 
    **/
    where: DireccionesEnvioWhereUniqueInput
  }


  /**
   * DireccionesEnvio deleteMany
   */
  export type DireccionesEnvioDeleteManyArgs = {
    /**
     * Filter which DireccionesEnvios to delete
     * 
    **/
    where?: DireccionesEnvioWhereInput
  }


  /**
   * DireccionesEnvio without action
   */
  export type DireccionesEnvioArgs = {
    /**
     * Select specific fields to fetch from the DireccionesEnvio
     * 
    **/
    select?: DireccionesEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionesEnvioInclude | null
  }



  /**
   * Model Empleados
   */


  export type AggregateEmpleados = {
    _count: EmpleadosCountAggregateOutputType | null
    _avg: EmpleadosAvgAggregateOutputType | null
    _sum: EmpleadosSumAggregateOutputType | null
    _min: EmpleadosMinAggregateOutputType | null
    _max: EmpleadosMaxAggregateOutputType | null
  }

  export type EmpleadosAvgAggregateOutputType = {
    id_empleado: number | null
    id_ciudad: number | null
    id_rol: number | null
    fnacimiento_empleado: number | null
  }

  export type EmpleadosSumAggregateOutputType = {
    id_empleado: number | null
    id_ciudad: number | null
    id_rol: number | null
    fnacimiento_empleado: number | null
  }

  export type EmpleadosMinAggregateOutputType = {
    id_empleado: number | null
    nom_empleado: string | null
    apellido_empleado: string | null
    telefono_empleado: string | null
    direccion_empleado: string | null
    id_ciudad: number | null
    id_rol: number | null
    fnacimiento_empleado: number | null
    Estado: boolean | null
  }

  export type EmpleadosMaxAggregateOutputType = {
    id_empleado: number | null
    nom_empleado: string | null
    apellido_empleado: string | null
    telefono_empleado: string | null
    direccion_empleado: string | null
    id_ciudad: number | null
    id_rol: number | null
    fnacimiento_empleado: number | null
    Estado: boolean | null
  }

  export type EmpleadosCountAggregateOutputType = {
    id_empleado: number
    nom_empleado: number
    apellido_empleado: number
    telefono_empleado: number
    direccion_empleado: number
    id_ciudad: number
    id_rol: number
    fnacimiento_empleado: number
    Estado: number
    _all: number
  }


  export type EmpleadosAvgAggregateInputType = {
    id_empleado?: true
    id_ciudad?: true
    id_rol?: true
    fnacimiento_empleado?: true
  }

  export type EmpleadosSumAggregateInputType = {
    id_empleado?: true
    id_ciudad?: true
    id_rol?: true
    fnacimiento_empleado?: true
  }

  export type EmpleadosMinAggregateInputType = {
    id_empleado?: true
    nom_empleado?: true
    apellido_empleado?: true
    telefono_empleado?: true
    direccion_empleado?: true
    id_ciudad?: true
    id_rol?: true
    fnacimiento_empleado?: true
    Estado?: true
  }

  export type EmpleadosMaxAggregateInputType = {
    id_empleado?: true
    nom_empleado?: true
    apellido_empleado?: true
    telefono_empleado?: true
    direccion_empleado?: true
    id_ciudad?: true
    id_rol?: true
    fnacimiento_empleado?: true
    Estado?: true
  }

  export type EmpleadosCountAggregateInputType = {
    id_empleado?: true
    nom_empleado?: true
    apellido_empleado?: true
    telefono_empleado?: true
    direccion_empleado?: true
    id_ciudad?: true
    id_rol?: true
    fnacimiento_empleado?: true
    Estado?: true
    _all?: true
  }

  export type EmpleadosAggregateArgs = {
    /**
     * Filter which Empleados to aggregate.
     * 
    **/
    where?: EmpleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     * 
    **/
    orderBy?: Enumerable<EmpleadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EmpleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empleados
    **/
    _count?: true | EmpleadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpleadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpleadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadosMaxAggregateInputType
  }

  export type GetEmpleadosAggregateType<T extends EmpleadosAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleados[P]>
      : GetScalarType<T[P], AggregateEmpleados[P]>
  }




  export type EmpleadosGroupByArgs = {
    where?: EmpleadosWhereInput
    orderBy?: Enumerable<EmpleadosOrderByWithAggregationInput>
    by: Array<EmpleadosScalarFieldEnum>
    having?: EmpleadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadosCountAggregateInputType | true
    _avg?: EmpleadosAvgAggregateInputType
    _sum?: EmpleadosSumAggregateInputType
    _min?: EmpleadosMinAggregateInputType
    _max?: EmpleadosMaxAggregateInputType
  }


  export type EmpleadosGroupByOutputType = {
    id_empleado: number
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    id_ciudad: number
    id_rol: number
    fnacimiento_empleado: number
    Estado: boolean
    _count: EmpleadosCountAggregateOutputType | null
    _avg: EmpleadosAvgAggregateOutputType | null
    _sum: EmpleadosSumAggregateOutputType | null
    _min: EmpleadosMinAggregateOutputType | null
    _max: EmpleadosMaxAggregateOutputType | null
  }

  type GetEmpleadosGroupByPayload<T extends EmpleadosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EmpleadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpleadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpleadosGroupByOutputType[P]>
            : GetScalarType<T[P], EmpleadosGroupByOutputType[P]>
        }
      >
    >


  export type EmpleadosSelect = {
    id_empleado?: boolean
    nom_empleado?: boolean
    apellido_empleado?: boolean
    telefono_empleado?: boolean
    direccion_empleado?: boolean
    id_ciudad?: boolean
    id_rol?: boolean
    fnacimiento_empleado?: boolean
    Estado?: boolean
    Ciudades?: boolean | CiudadesArgs
    RolesEmpleados?: boolean | RolesEmpleadosArgs
    Compras?: boolean | ComprasFindManyArgs
    UsuarioEmpleados?: boolean | UsuarioEmpleadosFindManyArgs
    _count?: boolean | EmpleadosCountOutputTypeArgs
  }

  export type EmpleadosInclude = {
    Ciudades?: boolean | CiudadesArgs
    RolesEmpleados?: boolean | RolesEmpleadosArgs
    Compras?: boolean | ComprasFindManyArgs
    UsuarioEmpleados?: boolean | UsuarioEmpleadosFindManyArgs
    _count?: boolean | EmpleadosCountOutputTypeArgs
  }

  export type EmpleadosGetPayload<
    S extends boolean | null | undefined | EmpleadosArgs,
    U = keyof S
      > = S extends true
        ? Empleados
    : S extends undefined
    ? never
    : S extends EmpleadosArgs | EmpleadosFindManyArgs
    ?'include' extends U
    ? Empleados  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Ciudades' ? CiudadesGetPayload<S['include'][P]> :
        P extends 'RolesEmpleados' ? RolesEmpleadosGetPayload<S['include'][P]> :
        P extends 'Compras' ? Array < ComprasGetPayload<S['include'][P]>>  :
        P extends 'UsuarioEmpleados' ? Array < UsuarioEmpleadosGetPayload<S['include'][P]>>  :
        P extends '_count' ? EmpleadosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Ciudades' ? CiudadesGetPayload<S['select'][P]> :
        P extends 'RolesEmpleados' ? RolesEmpleadosGetPayload<S['select'][P]> :
        P extends 'Compras' ? Array < ComprasGetPayload<S['select'][P]>>  :
        P extends 'UsuarioEmpleados' ? Array < UsuarioEmpleadosGetPayload<S['select'][P]>>  :
        P extends '_count' ? EmpleadosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Empleados ? Empleados[P] : never
  } 
    : Empleados
  : Empleados


  type EmpleadosCountArgs = Merge<
    Omit<EmpleadosFindManyArgs, 'select' | 'include'> & {
      select?: EmpleadosCountAggregateInputType | true
    }
  >

  export interface EmpleadosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Empleados that matches the filter.
     * @param {EmpleadosFindUniqueArgs} args - Arguments to find a Empleados
     * @example
     * // Get one Empleados
     * const empleados = await prisma.empleados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmpleadosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EmpleadosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Empleados'> extends True ? CheckSelect<T, Prisma__EmpleadosClient<Empleados>, Prisma__EmpleadosClient<EmpleadosGetPayload<T>>> : CheckSelect<T, Prisma__EmpleadosClient<Empleados | null >, Prisma__EmpleadosClient<EmpleadosGetPayload<T> | null >>

    /**
     * Find the first Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadosFindFirstArgs} args - Arguments to find a Empleados
     * @example
     * // Get one Empleados
     * const empleados = await prisma.empleados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmpleadosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EmpleadosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Empleados'> extends True ? CheckSelect<T, Prisma__EmpleadosClient<Empleados>, Prisma__EmpleadosClient<EmpleadosGetPayload<T>>> : CheckSelect<T, Prisma__EmpleadosClient<Empleados | null >, Prisma__EmpleadosClient<EmpleadosGetPayload<T> | null >>

    /**
     * Find zero or more Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleados
     * const empleados = await prisma.empleados.findMany()
     * 
     * // Get first 10 Empleados
     * const empleados = await prisma.empleados.findMany({ take: 10 })
     * 
     * // Only select the `id_empleado`
     * const empleadosWithId_empleadoOnly = await prisma.empleados.findMany({ select: { id_empleado: true } })
     * 
    **/
    findMany<T extends EmpleadosFindManyArgs>(
      args?: SelectSubset<T, EmpleadosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Empleados>>, PrismaPromise<Array<EmpleadosGetPayload<T>>>>

    /**
     * Create a Empleados.
     * @param {EmpleadosCreateArgs} args - Arguments to create a Empleados.
     * @example
     * // Create one Empleados
     * const Empleados = await prisma.empleados.create({
     *   data: {
     *     // ... data to create a Empleados
     *   }
     * })
     * 
    **/
    create<T extends EmpleadosCreateArgs>(
      args: SelectSubset<T, EmpleadosCreateArgs>
    ): CheckSelect<T, Prisma__EmpleadosClient<Empleados>, Prisma__EmpleadosClient<EmpleadosGetPayload<T>>>

    /**
     * Create many Empleados.
     *     @param {EmpleadosCreateManyArgs} args - Arguments to create many Empleados.
     *     @example
     *     // Create many Empleados
     *     const empleados = await prisma.empleados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmpleadosCreateManyArgs>(
      args?: SelectSubset<T, EmpleadosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Empleados.
     * @param {EmpleadosDeleteArgs} args - Arguments to delete one Empleados.
     * @example
     * // Delete one Empleados
     * const Empleados = await prisma.empleados.delete({
     *   where: {
     *     // ... filter to delete one Empleados
     *   }
     * })
     * 
    **/
    delete<T extends EmpleadosDeleteArgs>(
      args: SelectSubset<T, EmpleadosDeleteArgs>
    ): CheckSelect<T, Prisma__EmpleadosClient<Empleados>, Prisma__EmpleadosClient<EmpleadosGetPayload<T>>>

    /**
     * Update one Empleados.
     * @param {EmpleadosUpdateArgs} args - Arguments to update one Empleados.
     * @example
     * // Update one Empleados
     * const empleados = await prisma.empleados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmpleadosUpdateArgs>(
      args: SelectSubset<T, EmpleadosUpdateArgs>
    ): CheckSelect<T, Prisma__EmpleadosClient<Empleados>, Prisma__EmpleadosClient<EmpleadosGetPayload<T>>>

    /**
     * Delete zero or more Empleados.
     * @param {EmpleadosDeleteManyArgs} args - Arguments to filter Empleados to delete.
     * @example
     * // Delete a few Empleados
     * const { count } = await prisma.empleados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmpleadosDeleteManyArgs>(
      args?: SelectSubset<T, EmpleadosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleados
     * const empleados = await prisma.empleados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmpleadosUpdateManyArgs>(
      args: SelectSubset<T, EmpleadosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Empleados.
     * @param {EmpleadosUpsertArgs} args - Arguments to update or create a Empleados.
     * @example
     * // Update or create a Empleados
     * const empleados = await prisma.empleados.upsert({
     *   create: {
     *     // ... data to create a Empleados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleados we want to update
     *   }
     * })
    **/
    upsert<T extends EmpleadosUpsertArgs>(
      args: SelectSubset<T, EmpleadosUpsertArgs>
    ): CheckSelect<T, Prisma__EmpleadosClient<Empleados>, Prisma__EmpleadosClient<EmpleadosGetPayload<T>>>

    /**
     * Count the number of Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadosCountArgs} args - Arguments to filter Empleados to count.
     * @example
     * // Count the number of Empleados
     * const count = await prisma.empleados.count({
     *   where: {
     *     // ... the filter for the Empleados we want to count
     *   }
     * })
    **/
    count<T extends EmpleadosCountArgs>(
      args?: Subset<T, EmpleadosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadosAggregateArgs>(args: Subset<T, EmpleadosAggregateArgs>): PrismaPromise<GetEmpleadosAggregateType<T>>

    /**
     * Group by Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpleadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpleadosGroupByArgs['orderBy'] }
        : { orderBy?: EmpleadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpleadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadosGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empleados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmpleadosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Ciudades<T extends CiudadesArgs = {}>(args?: Subset<T, CiudadesArgs>): CheckSelect<T, Prisma__CiudadesClient<Ciudades | null >, Prisma__CiudadesClient<CiudadesGetPayload<T> | null >>;

    RolesEmpleados<T extends RolesEmpleadosArgs = {}>(args?: Subset<T, RolesEmpleadosArgs>): CheckSelect<T, Prisma__RolesEmpleadosClient<RolesEmpleados | null >, Prisma__RolesEmpleadosClient<RolesEmpleadosGetPayload<T> | null >>;

    Compras<T extends ComprasFindManyArgs = {}>(args?: Subset<T, ComprasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Compras>>, PrismaPromise<Array<ComprasGetPayload<T>>>>;

    UsuarioEmpleados<T extends UsuarioEmpleadosFindManyArgs = {}>(args?: Subset<T, UsuarioEmpleadosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UsuarioEmpleados>>, PrismaPromise<Array<UsuarioEmpleadosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Empleados findUnique
   */
  export type EmpleadosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Empleados
     * 
    **/
    select?: EmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpleadosInclude | null
    /**
     * Throw an Error if a Empleados can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Empleados to fetch.
     * 
    **/
    where: EmpleadosWhereUniqueInput
  }


  /**
   * Empleados findFirst
   */
  export type EmpleadosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Empleados
     * 
    **/
    select?: EmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpleadosInclude | null
    /**
     * Throw an Error if a Empleados can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Empleados to fetch.
     * 
    **/
    where?: EmpleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     * 
    **/
    orderBy?: Enumerable<EmpleadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empleados.
     * 
    **/
    cursor?: EmpleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empleados.
     * 
    **/
    distinct?: Enumerable<EmpleadosScalarFieldEnum>
  }


  /**
   * Empleados findMany
   */
  export type EmpleadosFindManyArgs = {
    /**
     * Select specific fields to fetch from the Empleados
     * 
    **/
    select?: EmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpleadosInclude | null
    /**
     * Filter, which Empleados to fetch.
     * 
    **/
    where?: EmpleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     * 
    **/
    orderBy?: Enumerable<EmpleadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empleados.
     * 
    **/
    cursor?: EmpleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmpleadosScalarFieldEnum>
  }


  /**
   * Empleados create
   */
  export type EmpleadosCreateArgs = {
    /**
     * Select specific fields to fetch from the Empleados
     * 
    **/
    select?: EmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpleadosInclude | null
    /**
     * The data needed to create a Empleados.
     * 
    **/
    data: XOR<EmpleadosCreateInput, EmpleadosUncheckedCreateInput>
  }


  /**
   * Empleados createMany
   */
  export type EmpleadosCreateManyArgs = {
    /**
     * The data used to create many Empleados.
     * 
    **/
    data: Enumerable<EmpleadosCreateManyInput>
  }


  /**
   * Empleados update
   */
  export type EmpleadosUpdateArgs = {
    /**
     * Select specific fields to fetch from the Empleados
     * 
    **/
    select?: EmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpleadosInclude | null
    /**
     * The data needed to update a Empleados.
     * 
    **/
    data: XOR<EmpleadosUpdateInput, EmpleadosUncheckedUpdateInput>
    /**
     * Choose, which Empleados to update.
     * 
    **/
    where: EmpleadosWhereUniqueInput
  }


  /**
   * Empleados updateMany
   */
  export type EmpleadosUpdateManyArgs = {
    /**
     * The data used to update Empleados.
     * 
    **/
    data: XOR<EmpleadosUpdateManyMutationInput, EmpleadosUncheckedUpdateManyInput>
    /**
     * Filter which Empleados to update
     * 
    **/
    where?: EmpleadosWhereInput
  }


  /**
   * Empleados upsert
   */
  export type EmpleadosUpsertArgs = {
    /**
     * Select specific fields to fetch from the Empleados
     * 
    **/
    select?: EmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpleadosInclude | null
    /**
     * The filter to search for the Empleados to update in case it exists.
     * 
    **/
    where: EmpleadosWhereUniqueInput
    /**
     * In case the Empleados found by the `where` argument doesn't exist, create a new Empleados with this data.
     * 
    **/
    create: XOR<EmpleadosCreateInput, EmpleadosUncheckedCreateInput>
    /**
     * In case the Empleados was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EmpleadosUpdateInput, EmpleadosUncheckedUpdateInput>
  }


  /**
   * Empleados delete
   */
  export type EmpleadosDeleteArgs = {
    /**
     * Select specific fields to fetch from the Empleados
     * 
    **/
    select?: EmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpleadosInclude | null
    /**
     * Filter which Empleados to delete.
     * 
    **/
    where: EmpleadosWhereUniqueInput
  }


  /**
   * Empleados deleteMany
   */
  export type EmpleadosDeleteManyArgs = {
    /**
     * Filter which Empleados to delete
     * 
    **/
    where?: EmpleadosWhereInput
  }


  /**
   * Empleados without action
   */
  export type EmpleadosArgs = {
    /**
     * Select specific fields to fetch from the Empleados
     * 
    **/
    select?: EmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpleadosInclude | null
  }



  /**
   * Model EmpresasEnvio
   */


  export type AggregateEmpresasEnvio = {
    _count: EmpresasEnvioCountAggregateOutputType | null
    _avg: EmpresasEnvioAvgAggregateOutputType | null
    _sum: EmpresasEnvioSumAggregateOutputType | null
    _min: EmpresasEnvioMinAggregateOutputType | null
    _max: EmpresasEnvioMaxAggregateOutputType | null
  }

  export type EmpresasEnvioAvgAggregateOutputType = {
    id_empresaEnvio: number | null
    id_ciudad: number | null
  }

  export type EmpresasEnvioSumAggregateOutputType = {
    id_empresaEnvio: number | null
    id_ciudad: number | null
  }

  export type EmpresasEnvioMinAggregateOutputType = {
    id_empresaEnvio: number | null
    nombre_empresa: string | null
    direccion_empresa: string | null
    telefono_empresa: string | null
    id_ciudad: number | null
    estado: boolean | null
    correo_empresa: string | null
  }

  export type EmpresasEnvioMaxAggregateOutputType = {
    id_empresaEnvio: number | null
    nombre_empresa: string | null
    direccion_empresa: string | null
    telefono_empresa: string | null
    id_ciudad: number | null
    estado: boolean | null
    correo_empresa: string | null
  }

  export type EmpresasEnvioCountAggregateOutputType = {
    id_empresaEnvio: number
    nombre_empresa: number
    direccion_empresa: number
    telefono_empresa: number
    id_ciudad: number
    estado: number
    correo_empresa: number
    _all: number
  }


  export type EmpresasEnvioAvgAggregateInputType = {
    id_empresaEnvio?: true
    id_ciudad?: true
  }

  export type EmpresasEnvioSumAggregateInputType = {
    id_empresaEnvio?: true
    id_ciudad?: true
  }

  export type EmpresasEnvioMinAggregateInputType = {
    id_empresaEnvio?: true
    nombre_empresa?: true
    direccion_empresa?: true
    telefono_empresa?: true
    id_ciudad?: true
    estado?: true
    correo_empresa?: true
  }

  export type EmpresasEnvioMaxAggregateInputType = {
    id_empresaEnvio?: true
    nombre_empresa?: true
    direccion_empresa?: true
    telefono_empresa?: true
    id_ciudad?: true
    estado?: true
    correo_empresa?: true
  }

  export type EmpresasEnvioCountAggregateInputType = {
    id_empresaEnvio?: true
    nombre_empresa?: true
    direccion_empresa?: true
    telefono_empresa?: true
    id_ciudad?: true
    estado?: true
    correo_empresa?: true
    _all?: true
  }

  export type EmpresasEnvioAggregateArgs = {
    /**
     * Filter which EmpresasEnvio to aggregate.
     * 
    **/
    where?: EmpresasEnvioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresasEnvios to fetch.
     * 
    **/
    orderBy?: Enumerable<EmpresasEnvioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EmpresasEnvioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresasEnvios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresasEnvios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmpresasEnvios
    **/
    _count?: true | EmpresasEnvioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpresasEnvioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpresasEnvioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresasEnvioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresasEnvioMaxAggregateInputType
  }

  export type GetEmpresasEnvioAggregateType<T extends EmpresasEnvioAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresasEnvio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresasEnvio[P]>
      : GetScalarType<T[P], AggregateEmpresasEnvio[P]>
  }




  export type EmpresasEnvioGroupByArgs = {
    where?: EmpresasEnvioWhereInput
    orderBy?: Enumerable<EmpresasEnvioOrderByWithAggregationInput>
    by: Array<EmpresasEnvioScalarFieldEnum>
    having?: EmpresasEnvioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresasEnvioCountAggregateInputType | true
    _avg?: EmpresasEnvioAvgAggregateInputType
    _sum?: EmpresasEnvioSumAggregateInputType
    _min?: EmpresasEnvioMinAggregateInputType
    _max?: EmpresasEnvioMaxAggregateInputType
  }


  export type EmpresasEnvioGroupByOutputType = {
    id_empresaEnvio: number
    nombre_empresa: string
    direccion_empresa: string
    telefono_empresa: string
    id_ciudad: number
    estado: boolean
    correo_empresa: string
    _count: EmpresasEnvioCountAggregateOutputType | null
    _avg: EmpresasEnvioAvgAggregateOutputType | null
    _sum: EmpresasEnvioSumAggregateOutputType | null
    _min: EmpresasEnvioMinAggregateOutputType | null
    _max: EmpresasEnvioMaxAggregateOutputType | null
  }

  type GetEmpresasEnvioGroupByPayload<T extends EmpresasEnvioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EmpresasEnvioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresasEnvioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresasEnvioGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresasEnvioGroupByOutputType[P]>
        }
      >
    >


  export type EmpresasEnvioSelect = {
    id_empresaEnvio?: boolean
    nombre_empresa?: boolean
    direccion_empresa?: boolean
    telefono_empresa?: boolean
    id_ciudad?: boolean
    estado?: boolean
    correo_empresa?: boolean
    Ciudades?: boolean | CiudadesArgs
    Envios?: boolean | EnviosFindManyArgs
    _count?: boolean | EmpresasEnvioCountOutputTypeArgs
  }

  export type EmpresasEnvioInclude = {
    Ciudades?: boolean | CiudadesArgs
    Envios?: boolean | EnviosFindManyArgs
    _count?: boolean | EmpresasEnvioCountOutputTypeArgs
  }

  export type EmpresasEnvioGetPayload<
    S extends boolean | null | undefined | EmpresasEnvioArgs,
    U = keyof S
      > = S extends true
        ? EmpresasEnvio
    : S extends undefined
    ? never
    : S extends EmpresasEnvioArgs | EmpresasEnvioFindManyArgs
    ?'include' extends U
    ? EmpresasEnvio  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Ciudades' ? CiudadesGetPayload<S['include'][P]> :
        P extends 'Envios' ? Array < EnviosGetPayload<S['include'][P]>>  :
        P extends '_count' ? EmpresasEnvioCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Ciudades' ? CiudadesGetPayload<S['select'][P]> :
        P extends 'Envios' ? Array < EnviosGetPayload<S['select'][P]>>  :
        P extends '_count' ? EmpresasEnvioCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof EmpresasEnvio ? EmpresasEnvio[P] : never
  } 
    : EmpresasEnvio
  : EmpresasEnvio


  type EmpresasEnvioCountArgs = Merge<
    Omit<EmpresasEnvioFindManyArgs, 'select' | 'include'> & {
      select?: EmpresasEnvioCountAggregateInputType | true
    }
  >

  export interface EmpresasEnvioDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one EmpresasEnvio that matches the filter.
     * @param {EmpresasEnvioFindUniqueArgs} args - Arguments to find a EmpresasEnvio
     * @example
     * // Get one EmpresasEnvio
     * const empresasEnvio = await prisma.empresasEnvio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmpresasEnvioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EmpresasEnvioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EmpresasEnvio'> extends True ? CheckSelect<T, Prisma__EmpresasEnvioClient<EmpresasEnvio>, Prisma__EmpresasEnvioClient<EmpresasEnvioGetPayload<T>>> : CheckSelect<T, Prisma__EmpresasEnvioClient<EmpresasEnvio | null >, Prisma__EmpresasEnvioClient<EmpresasEnvioGetPayload<T> | null >>

    /**
     * Find the first EmpresasEnvio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresasEnvioFindFirstArgs} args - Arguments to find a EmpresasEnvio
     * @example
     * // Get one EmpresasEnvio
     * const empresasEnvio = await prisma.empresasEnvio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmpresasEnvioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EmpresasEnvioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EmpresasEnvio'> extends True ? CheckSelect<T, Prisma__EmpresasEnvioClient<EmpresasEnvio>, Prisma__EmpresasEnvioClient<EmpresasEnvioGetPayload<T>>> : CheckSelect<T, Prisma__EmpresasEnvioClient<EmpresasEnvio | null >, Prisma__EmpresasEnvioClient<EmpresasEnvioGetPayload<T> | null >>

    /**
     * Find zero or more EmpresasEnvios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresasEnvioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmpresasEnvios
     * const empresasEnvios = await prisma.empresasEnvio.findMany()
     * 
     * // Get first 10 EmpresasEnvios
     * const empresasEnvios = await prisma.empresasEnvio.findMany({ take: 10 })
     * 
     * // Only select the `id_empresaEnvio`
     * const empresasEnvioWithId_empresaEnvioOnly = await prisma.empresasEnvio.findMany({ select: { id_empresaEnvio: true } })
     * 
    **/
    findMany<T extends EmpresasEnvioFindManyArgs>(
      args?: SelectSubset<T, EmpresasEnvioFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EmpresasEnvio>>, PrismaPromise<Array<EmpresasEnvioGetPayload<T>>>>

    /**
     * Create a EmpresasEnvio.
     * @param {EmpresasEnvioCreateArgs} args - Arguments to create a EmpresasEnvio.
     * @example
     * // Create one EmpresasEnvio
     * const EmpresasEnvio = await prisma.empresasEnvio.create({
     *   data: {
     *     // ... data to create a EmpresasEnvio
     *   }
     * })
     * 
    **/
    create<T extends EmpresasEnvioCreateArgs>(
      args: SelectSubset<T, EmpresasEnvioCreateArgs>
    ): CheckSelect<T, Prisma__EmpresasEnvioClient<EmpresasEnvio>, Prisma__EmpresasEnvioClient<EmpresasEnvioGetPayload<T>>>

    /**
     * Create many EmpresasEnvios.
     *     @param {EmpresasEnvioCreateManyArgs} args - Arguments to create many EmpresasEnvios.
     *     @example
     *     // Create many EmpresasEnvios
     *     const empresasEnvio = await prisma.empresasEnvio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmpresasEnvioCreateManyArgs>(
      args?: SelectSubset<T, EmpresasEnvioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EmpresasEnvio.
     * @param {EmpresasEnvioDeleteArgs} args - Arguments to delete one EmpresasEnvio.
     * @example
     * // Delete one EmpresasEnvio
     * const EmpresasEnvio = await prisma.empresasEnvio.delete({
     *   where: {
     *     // ... filter to delete one EmpresasEnvio
     *   }
     * })
     * 
    **/
    delete<T extends EmpresasEnvioDeleteArgs>(
      args: SelectSubset<T, EmpresasEnvioDeleteArgs>
    ): CheckSelect<T, Prisma__EmpresasEnvioClient<EmpresasEnvio>, Prisma__EmpresasEnvioClient<EmpresasEnvioGetPayload<T>>>

    /**
     * Update one EmpresasEnvio.
     * @param {EmpresasEnvioUpdateArgs} args - Arguments to update one EmpresasEnvio.
     * @example
     * // Update one EmpresasEnvio
     * const empresasEnvio = await prisma.empresasEnvio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmpresasEnvioUpdateArgs>(
      args: SelectSubset<T, EmpresasEnvioUpdateArgs>
    ): CheckSelect<T, Prisma__EmpresasEnvioClient<EmpresasEnvio>, Prisma__EmpresasEnvioClient<EmpresasEnvioGetPayload<T>>>

    /**
     * Delete zero or more EmpresasEnvios.
     * @param {EmpresasEnvioDeleteManyArgs} args - Arguments to filter EmpresasEnvios to delete.
     * @example
     * // Delete a few EmpresasEnvios
     * const { count } = await prisma.empresasEnvio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmpresasEnvioDeleteManyArgs>(
      args?: SelectSubset<T, EmpresasEnvioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmpresasEnvios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresasEnvioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmpresasEnvios
     * const empresasEnvio = await prisma.empresasEnvio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmpresasEnvioUpdateManyArgs>(
      args: SelectSubset<T, EmpresasEnvioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EmpresasEnvio.
     * @param {EmpresasEnvioUpsertArgs} args - Arguments to update or create a EmpresasEnvio.
     * @example
     * // Update or create a EmpresasEnvio
     * const empresasEnvio = await prisma.empresasEnvio.upsert({
     *   create: {
     *     // ... data to create a EmpresasEnvio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmpresasEnvio we want to update
     *   }
     * })
    **/
    upsert<T extends EmpresasEnvioUpsertArgs>(
      args: SelectSubset<T, EmpresasEnvioUpsertArgs>
    ): CheckSelect<T, Prisma__EmpresasEnvioClient<EmpresasEnvio>, Prisma__EmpresasEnvioClient<EmpresasEnvioGetPayload<T>>>

    /**
     * Count the number of EmpresasEnvios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresasEnvioCountArgs} args - Arguments to filter EmpresasEnvios to count.
     * @example
     * // Count the number of EmpresasEnvios
     * const count = await prisma.empresasEnvio.count({
     *   where: {
     *     // ... the filter for the EmpresasEnvios we want to count
     *   }
     * })
    **/
    count<T extends EmpresasEnvioCountArgs>(
      args?: Subset<T, EmpresasEnvioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresasEnvioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmpresasEnvio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresasEnvioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresasEnvioAggregateArgs>(args: Subset<T, EmpresasEnvioAggregateArgs>): PrismaPromise<GetEmpresasEnvioAggregateType<T>>

    /**
     * Group by EmpresasEnvio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresasEnvioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresasEnvioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresasEnvioGroupByArgs['orderBy'] }
        : { orderBy?: EmpresasEnvioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresasEnvioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresasEnvioGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmpresasEnvio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmpresasEnvioClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Ciudades<T extends CiudadesArgs = {}>(args?: Subset<T, CiudadesArgs>): CheckSelect<T, Prisma__CiudadesClient<Ciudades | null >, Prisma__CiudadesClient<CiudadesGetPayload<T> | null >>;

    Envios<T extends EnviosFindManyArgs = {}>(args?: Subset<T, EnviosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Envios>>, PrismaPromise<Array<EnviosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * EmpresasEnvio findUnique
   */
  export type EmpresasEnvioFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the EmpresasEnvio
     * 
    **/
    select?: EmpresasEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpresasEnvioInclude | null
    /**
     * Throw an Error if a EmpresasEnvio can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EmpresasEnvio to fetch.
     * 
    **/
    where: EmpresasEnvioWhereUniqueInput
  }


  /**
   * EmpresasEnvio findFirst
   */
  export type EmpresasEnvioFindFirstArgs = {
    /**
     * Select specific fields to fetch from the EmpresasEnvio
     * 
    **/
    select?: EmpresasEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpresasEnvioInclude | null
    /**
     * Throw an Error if a EmpresasEnvio can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EmpresasEnvio to fetch.
     * 
    **/
    where?: EmpresasEnvioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresasEnvios to fetch.
     * 
    **/
    orderBy?: Enumerable<EmpresasEnvioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmpresasEnvios.
     * 
    **/
    cursor?: EmpresasEnvioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresasEnvios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresasEnvios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmpresasEnvios.
     * 
    **/
    distinct?: Enumerable<EmpresasEnvioScalarFieldEnum>
  }


  /**
   * EmpresasEnvio findMany
   */
  export type EmpresasEnvioFindManyArgs = {
    /**
     * Select specific fields to fetch from the EmpresasEnvio
     * 
    **/
    select?: EmpresasEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpresasEnvioInclude | null
    /**
     * Filter, which EmpresasEnvios to fetch.
     * 
    **/
    where?: EmpresasEnvioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresasEnvios to fetch.
     * 
    **/
    orderBy?: Enumerable<EmpresasEnvioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmpresasEnvios.
     * 
    **/
    cursor?: EmpresasEnvioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresasEnvios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresasEnvios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmpresasEnvioScalarFieldEnum>
  }


  /**
   * EmpresasEnvio create
   */
  export type EmpresasEnvioCreateArgs = {
    /**
     * Select specific fields to fetch from the EmpresasEnvio
     * 
    **/
    select?: EmpresasEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpresasEnvioInclude | null
    /**
     * The data needed to create a EmpresasEnvio.
     * 
    **/
    data: XOR<EmpresasEnvioCreateInput, EmpresasEnvioUncheckedCreateInput>
  }


  /**
   * EmpresasEnvio createMany
   */
  export type EmpresasEnvioCreateManyArgs = {
    /**
     * The data used to create many EmpresasEnvios.
     * 
    **/
    data: Enumerable<EmpresasEnvioCreateManyInput>
  }


  /**
   * EmpresasEnvio update
   */
  export type EmpresasEnvioUpdateArgs = {
    /**
     * Select specific fields to fetch from the EmpresasEnvio
     * 
    **/
    select?: EmpresasEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpresasEnvioInclude | null
    /**
     * The data needed to update a EmpresasEnvio.
     * 
    **/
    data: XOR<EmpresasEnvioUpdateInput, EmpresasEnvioUncheckedUpdateInput>
    /**
     * Choose, which EmpresasEnvio to update.
     * 
    **/
    where: EmpresasEnvioWhereUniqueInput
  }


  /**
   * EmpresasEnvio updateMany
   */
  export type EmpresasEnvioUpdateManyArgs = {
    /**
     * The data used to update EmpresasEnvios.
     * 
    **/
    data: XOR<EmpresasEnvioUpdateManyMutationInput, EmpresasEnvioUncheckedUpdateManyInput>
    /**
     * Filter which EmpresasEnvios to update
     * 
    **/
    where?: EmpresasEnvioWhereInput
  }


  /**
   * EmpresasEnvio upsert
   */
  export type EmpresasEnvioUpsertArgs = {
    /**
     * Select specific fields to fetch from the EmpresasEnvio
     * 
    **/
    select?: EmpresasEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpresasEnvioInclude | null
    /**
     * The filter to search for the EmpresasEnvio to update in case it exists.
     * 
    **/
    where: EmpresasEnvioWhereUniqueInput
    /**
     * In case the EmpresasEnvio found by the `where` argument doesn't exist, create a new EmpresasEnvio with this data.
     * 
    **/
    create: XOR<EmpresasEnvioCreateInput, EmpresasEnvioUncheckedCreateInput>
    /**
     * In case the EmpresasEnvio was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EmpresasEnvioUpdateInput, EmpresasEnvioUncheckedUpdateInput>
  }


  /**
   * EmpresasEnvio delete
   */
  export type EmpresasEnvioDeleteArgs = {
    /**
     * Select specific fields to fetch from the EmpresasEnvio
     * 
    **/
    select?: EmpresasEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpresasEnvioInclude | null
    /**
     * Filter which EmpresasEnvio to delete.
     * 
    **/
    where: EmpresasEnvioWhereUniqueInput
  }


  /**
   * EmpresasEnvio deleteMany
   */
  export type EmpresasEnvioDeleteManyArgs = {
    /**
     * Filter which EmpresasEnvios to delete
     * 
    **/
    where?: EmpresasEnvioWhereInput
  }


  /**
   * EmpresasEnvio without action
   */
  export type EmpresasEnvioArgs = {
    /**
     * Select specific fields to fetch from the EmpresasEnvio
     * 
    **/
    select?: EmpresasEnvioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmpresasEnvioInclude | null
  }



  /**
   * Model Envios
   */


  export type AggregateEnvios = {
    _count: EnviosCountAggregateOutputType | null
    _avg: EnviosAvgAggregateOutputType | null
    _sum: EnviosSumAggregateOutputType | null
    _min: EnviosMinAggregateOutputType | null
    _max: EnviosMaxAggregateOutputType | null
  }

  export type EnviosAvgAggregateOutputType = {
    id_envio: number | null
    id_venta: number | null
    id_empresaEnvio: number | null
  }

  export type EnviosSumAggregateOutputType = {
    id_envio: number | null
    id_venta: number | null
    id_empresaEnvio: number | null
  }

  export type EnviosMinAggregateOutputType = {
    id_envio: number | null
    num_rastreo: string | null
    id_venta: number | null
    id_empresaEnvio: number | null
  }

  export type EnviosMaxAggregateOutputType = {
    id_envio: number | null
    num_rastreo: string | null
    id_venta: number | null
    id_empresaEnvio: number | null
  }

  export type EnviosCountAggregateOutputType = {
    id_envio: number
    num_rastreo: number
    id_venta: number
    id_empresaEnvio: number
    _all: number
  }


  export type EnviosAvgAggregateInputType = {
    id_envio?: true
    id_venta?: true
    id_empresaEnvio?: true
  }

  export type EnviosSumAggregateInputType = {
    id_envio?: true
    id_venta?: true
    id_empresaEnvio?: true
  }

  export type EnviosMinAggregateInputType = {
    id_envio?: true
    num_rastreo?: true
    id_venta?: true
    id_empresaEnvio?: true
  }

  export type EnviosMaxAggregateInputType = {
    id_envio?: true
    num_rastreo?: true
    id_venta?: true
    id_empresaEnvio?: true
  }

  export type EnviosCountAggregateInputType = {
    id_envio?: true
    num_rastreo?: true
    id_venta?: true
    id_empresaEnvio?: true
    _all?: true
  }

  export type EnviosAggregateArgs = {
    /**
     * Filter which Envios to aggregate.
     * 
    **/
    where?: EnviosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envios to fetch.
     * 
    **/
    orderBy?: Enumerable<EnviosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EnviosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Envios
    **/
    _count?: true | EnviosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnviosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnviosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnviosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnviosMaxAggregateInputType
  }

  export type GetEnviosAggregateType<T extends EnviosAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvios[P]>
      : GetScalarType<T[P], AggregateEnvios[P]>
  }




  export type EnviosGroupByArgs = {
    where?: EnviosWhereInput
    orderBy?: Enumerable<EnviosOrderByWithAggregationInput>
    by: Array<EnviosScalarFieldEnum>
    having?: EnviosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnviosCountAggregateInputType | true
    _avg?: EnviosAvgAggregateInputType
    _sum?: EnviosSumAggregateInputType
    _min?: EnviosMinAggregateInputType
    _max?: EnviosMaxAggregateInputType
  }


  export type EnviosGroupByOutputType = {
    id_envio: number
    num_rastreo: string
    id_venta: number
    id_empresaEnvio: number
    _count: EnviosCountAggregateOutputType | null
    _avg: EnviosAvgAggregateOutputType | null
    _sum: EnviosSumAggregateOutputType | null
    _min: EnviosMinAggregateOutputType | null
    _max: EnviosMaxAggregateOutputType | null
  }

  type GetEnviosGroupByPayload<T extends EnviosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EnviosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnviosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnviosGroupByOutputType[P]>
            : GetScalarType<T[P], EnviosGroupByOutputType[P]>
        }
      >
    >


  export type EnviosSelect = {
    id_envio?: boolean
    num_rastreo?: boolean
    id_venta?: boolean
    id_empresaEnvio?: boolean
    EmpresasEnvio?: boolean | EmpresasEnvioArgs
    Venta?: boolean | VentaArgs
  }

  export type EnviosInclude = {
    EmpresasEnvio?: boolean | EmpresasEnvioArgs
    Venta?: boolean | VentaArgs
  }

  export type EnviosGetPayload<
    S extends boolean | null | undefined | EnviosArgs,
    U = keyof S
      > = S extends true
        ? Envios
    : S extends undefined
    ? never
    : S extends EnviosArgs | EnviosFindManyArgs
    ?'include' extends U
    ? Envios  & {
    [P in TrueKeys<S['include']>]:
        P extends 'EmpresasEnvio' ? EmpresasEnvioGetPayload<S['include'][P]> :
        P extends 'Venta' ? VentaGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'EmpresasEnvio' ? EmpresasEnvioGetPayload<S['select'][P]> :
        P extends 'Venta' ? VentaGetPayload<S['select'][P]> :  P extends keyof Envios ? Envios[P] : never
  } 
    : Envios
  : Envios


  type EnviosCountArgs = Merge<
    Omit<EnviosFindManyArgs, 'select' | 'include'> & {
      select?: EnviosCountAggregateInputType | true
    }
  >

  export interface EnviosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Envios that matches the filter.
     * @param {EnviosFindUniqueArgs} args - Arguments to find a Envios
     * @example
     * // Get one Envios
     * const envios = await prisma.envios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnviosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EnviosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Envios'> extends True ? CheckSelect<T, Prisma__EnviosClient<Envios>, Prisma__EnviosClient<EnviosGetPayload<T>>> : CheckSelect<T, Prisma__EnviosClient<Envios | null >, Prisma__EnviosClient<EnviosGetPayload<T> | null >>

    /**
     * Find the first Envios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnviosFindFirstArgs} args - Arguments to find a Envios
     * @example
     * // Get one Envios
     * const envios = await prisma.envios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnviosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EnviosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Envios'> extends True ? CheckSelect<T, Prisma__EnviosClient<Envios>, Prisma__EnviosClient<EnviosGetPayload<T>>> : CheckSelect<T, Prisma__EnviosClient<Envios | null >, Prisma__EnviosClient<EnviosGetPayload<T> | null >>

    /**
     * Find zero or more Envios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnviosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Envios
     * const envios = await prisma.envios.findMany()
     * 
     * // Get first 10 Envios
     * const envios = await prisma.envios.findMany({ take: 10 })
     * 
     * // Only select the `id_envio`
     * const enviosWithId_envioOnly = await prisma.envios.findMany({ select: { id_envio: true } })
     * 
    **/
    findMany<T extends EnviosFindManyArgs>(
      args?: SelectSubset<T, EnviosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Envios>>, PrismaPromise<Array<EnviosGetPayload<T>>>>

    /**
     * Create a Envios.
     * @param {EnviosCreateArgs} args - Arguments to create a Envios.
     * @example
     * // Create one Envios
     * const Envios = await prisma.envios.create({
     *   data: {
     *     // ... data to create a Envios
     *   }
     * })
     * 
    **/
    create<T extends EnviosCreateArgs>(
      args: SelectSubset<T, EnviosCreateArgs>
    ): CheckSelect<T, Prisma__EnviosClient<Envios>, Prisma__EnviosClient<EnviosGetPayload<T>>>

    /**
     * Create many Envios.
     *     @param {EnviosCreateManyArgs} args - Arguments to create many Envios.
     *     @example
     *     // Create many Envios
     *     const envios = await prisma.envios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnviosCreateManyArgs>(
      args?: SelectSubset<T, EnviosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Envios.
     * @param {EnviosDeleteArgs} args - Arguments to delete one Envios.
     * @example
     * // Delete one Envios
     * const Envios = await prisma.envios.delete({
     *   where: {
     *     // ... filter to delete one Envios
     *   }
     * })
     * 
    **/
    delete<T extends EnviosDeleteArgs>(
      args: SelectSubset<T, EnviosDeleteArgs>
    ): CheckSelect<T, Prisma__EnviosClient<Envios>, Prisma__EnviosClient<EnviosGetPayload<T>>>

    /**
     * Update one Envios.
     * @param {EnviosUpdateArgs} args - Arguments to update one Envios.
     * @example
     * // Update one Envios
     * const envios = await prisma.envios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnviosUpdateArgs>(
      args: SelectSubset<T, EnviosUpdateArgs>
    ): CheckSelect<T, Prisma__EnviosClient<Envios>, Prisma__EnviosClient<EnviosGetPayload<T>>>

    /**
     * Delete zero or more Envios.
     * @param {EnviosDeleteManyArgs} args - Arguments to filter Envios to delete.
     * @example
     * // Delete a few Envios
     * const { count } = await prisma.envios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnviosDeleteManyArgs>(
      args?: SelectSubset<T, EnviosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Envios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnviosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Envios
     * const envios = await prisma.envios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnviosUpdateManyArgs>(
      args: SelectSubset<T, EnviosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Envios.
     * @param {EnviosUpsertArgs} args - Arguments to update or create a Envios.
     * @example
     * // Update or create a Envios
     * const envios = await prisma.envios.upsert({
     *   create: {
     *     // ... data to create a Envios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Envios we want to update
     *   }
     * })
    **/
    upsert<T extends EnviosUpsertArgs>(
      args: SelectSubset<T, EnviosUpsertArgs>
    ): CheckSelect<T, Prisma__EnviosClient<Envios>, Prisma__EnviosClient<EnviosGetPayload<T>>>

    /**
     * Count the number of Envios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnviosCountArgs} args - Arguments to filter Envios to count.
     * @example
     * // Count the number of Envios
     * const count = await prisma.envios.count({
     *   where: {
     *     // ... the filter for the Envios we want to count
     *   }
     * })
    **/
    count<T extends EnviosCountArgs>(
      args?: Subset<T, EnviosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnviosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Envios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnviosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnviosAggregateArgs>(args: Subset<T, EnviosAggregateArgs>): PrismaPromise<GetEnviosAggregateType<T>>

    /**
     * Group by Envios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnviosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnviosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnviosGroupByArgs['orderBy'] }
        : { orderBy?: EnviosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnviosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnviosGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Envios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EnviosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    EmpresasEnvio<T extends EmpresasEnvioArgs = {}>(args?: Subset<T, EmpresasEnvioArgs>): CheckSelect<T, Prisma__EmpresasEnvioClient<EmpresasEnvio | null >, Prisma__EmpresasEnvioClient<EmpresasEnvioGetPayload<T> | null >>;

    Venta<T extends VentaArgs = {}>(args?: Subset<T, VentaArgs>): CheckSelect<T, Prisma__VentaClient<Venta | null >, Prisma__VentaClient<VentaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Envios findUnique
   */
  export type EnviosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Envios
     * 
    **/
    select?: EnviosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnviosInclude | null
    /**
     * Throw an Error if a Envios can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Envios to fetch.
     * 
    **/
    where: EnviosWhereUniqueInput
  }


  /**
   * Envios findFirst
   */
  export type EnviosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Envios
     * 
    **/
    select?: EnviosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnviosInclude | null
    /**
     * Throw an Error if a Envios can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Envios to fetch.
     * 
    **/
    where?: EnviosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envios to fetch.
     * 
    **/
    orderBy?: Enumerable<EnviosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Envios.
     * 
    **/
    cursor?: EnviosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Envios.
     * 
    **/
    distinct?: Enumerable<EnviosScalarFieldEnum>
  }


  /**
   * Envios findMany
   */
  export type EnviosFindManyArgs = {
    /**
     * Select specific fields to fetch from the Envios
     * 
    **/
    select?: EnviosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnviosInclude | null
    /**
     * Filter, which Envios to fetch.
     * 
    **/
    where?: EnviosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envios to fetch.
     * 
    **/
    orderBy?: Enumerable<EnviosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Envios.
     * 
    **/
    cursor?: EnviosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EnviosScalarFieldEnum>
  }


  /**
   * Envios create
   */
  export type EnviosCreateArgs = {
    /**
     * Select specific fields to fetch from the Envios
     * 
    **/
    select?: EnviosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnviosInclude | null
    /**
     * The data needed to create a Envios.
     * 
    **/
    data: XOR<EnviosCreateInput, EnviosUncheckedCreateInput>
  }


  /**
   * Envios createMany
   */
  export type EnviosCreateManyArgs = {
    /**
     * The data used to create many Envios.
     * 
    **/
    data: Enumerable<EnviosCreateManyInput>
  }


  /**
   * Envios update
   */
  export type EnviosUpdateArgs = {
    /**
     * Select specific fields to fetch from the Envios
     * 
    **/
    select?: EnviosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnviosInclude | null
    /**
     * The data needed to update a Envios.
     * 
    **/
    data: XOR<EnviosUpdateInput, EnviosUncheckedUpdateInput>
    /**
     * Choose, which Envios to update.
     * 
    **/
    where: EnviosWhereUniqueInput
  }


  /**
   * Envios updateMany
   */
  export type EnviosUpdateManyArgs = {
    /**
     * The data used to update Envios.
     * 
    **/
    data: XOR<EnviosUpdateManyMutationInput, EnviosUncheckedUpdateManyInput>
    /**
     * Filter which Envios to update
     * 
    **/
    where?: EnviosWhereInput
  }


  /**
   * Envios upsert
   */
  export type EnviosUpsertArgs = {
    /**
     * Select specific fields to fetch from the Envios
     * 
    **/
    select?: EnviosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnviosInclude | null
    /**
     * The filter to search for the Envios to update in case it exists.
     * 
    **/
    where: EnviosWhereUniqueInput
    /**
     * In case the Envios found by the `where` argument doesn't exist, create a new Envios with this data.
     * 
    **/
    create: XOR<EnviosCreateInput, EnviosUncheckedCreateInput>
    /**
     * In case the Envios was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EnviosUpdateInput, EnviosUncheckedUpdateInput>
  }


  /**
   * Envios delete
   */
  export type EnviosDeleteArgs = {
    /**
     * Select specific fields to fetch from the Envios
     * 
    **/
    select?: EnviosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnviosInclude | null
    /**
     * Filter which Envios to delete.
     * 
    **/
    where: EnviosWhereUniqueInput
  }


  /**
   * Envios deleteMany
   */
  export type EnviosDeleteManyArgs = {
    /**
     * Filter which Envios to delete
     * 
    **/
    where?: EnviosWhereInput
  }


  /**
   * Envios without action
   */
  export type EnviosArgs = {
    /**
     * Select specific fields to fetch from the Envios
     * 
    **/
    select?: EnviosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnviosInclude | null
  }



  /**
   * Model Marcas
   */


  export type AggregateMarcas = {
    _count: MarcasCountAggregateOutputType | null
    _avg: MarcasAvgAggregateOutputType | null
    _sum: MarcasSumAggregateOutputType | null
    _min: MarcasMinAggregateOutputType | null
    _max: MarcasMaxAggregateOutputType | null
  }

  export type MarcasAvgAggregateOutputType = {
    id_marca: number | null
  }

  export type MarcasSumAggregateOutputType = {
    id_marca: number | null
  }

  export type MarcasMinAggregateOutputType = {
    id_marca: number | null
    descripcion_marca: string | null
    estado: boolean | null
  }

  export type MarcasMaxAggregateOutputType = {
    id_marca: number | null
    descripcion_marca: string | null
    estado: boolean | null
  }

  export type MarcasCountAggregateOutputType = {
    id_marca: number
    descripcion_marca: number
    estado: number
    _all: number
  }


  export type MarcasAvgAggregateInputType = {
    id_marca?: true
  }

  export type MarcasSumAggregateInputType = {
    id_marca?: true
  }

  export type MarcasMinAggregateInputType = {
    id_marca?: true
    descripcion_marca?: true
    estado?: true
  }

  export type MarcasMaxAggregateInputType = {
    id_marca?: true
    descripcion_marca?: true
    estado?: true
  }

  export type MarcasCountAggregateInputType = {
    id_marca?: true
    descripcion_marca?: true
    estado?: true
    _all?: true
  }

  export type MarcasAggregateArgs = {
    /**
     * Filter which Marcas to aggregate.
     * 
    **/
    where?: MarcasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marcas to fetch.
     * 
    **/
    orderBy?: Enumerable<MarcasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MarcasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marcas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marcas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Marcas
    **/
    _count?: true | MarcasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarcasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarcasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarcasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarcasMaxAggregateInputType
  }

  export type GetMarcasAggregateType<T extends MarcasAggregateArgs> = {
        [P in keyof T & keyof AggregateMarcas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarcas[P]>
      : GetScalarType<T[P], AggregateMarcas[P]>
  }




  export type MarcasGroupByArgs = {
    where?: MarcasWhereInput
    orderBy?: Enumerable<MarcasOrderByWithAggregationInput>
    by: Array<MarcasScalarFieldEnum>
    having?: MarcasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarcasCountAggregateInputType | true
    _avg?: MarcasAvgAggregateInputType
    _sum?: MarcasSumAggregateInputType
    _min?: MarcasMinAggregateInputType
    _max?: MarcasMaxAggregateInputType
  }


  export type MarcasGroupByOutputType = {
    id_marca: number
    descripcion_marca: string
    estado: boolean
    _count: MarcasCountAggregateOutputType | null
    _avg: MarcasAvgAggregateOutputType | null
    _sum: MarcasSumAggregateOutputType | null
    _min: MarcasMinAggregateOutputType | null
    _max: MarcasMaxAggregateOutputType | null
  }

  type GetMarcasGroupByPayload<T extends MarcasGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MarcasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarcasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarcasGroupByOutputType[P]>
            : GetScalarType<T[P], MarcasGroupByOutputType[P]>
        }
      >
    >


  export type MarcasSelect = {
    id_marca?: boolean
    descripcion_marca?: boolean
    estado?: boolean
    Productos?: boolean | ProductosFindManyArgs
    _count?: boolean | MarcasCountOutputTypeArgs
  }

  export type MarcasInclude = {
    Productos?: boolean | ProductosFindManyArgs
    _count?: boolean | MarcasCountOutputTypeArgs
  }

  export type MarcasGetPayload<
    S extends boolean | null | undefined | MarcasArgs,
    U = keyof S
      > = S extends true
        ? Marcas
    : S extends undefined
    ? never
    : S extends MarcasArgs | MarcasFindManyArgs
    ?'include' extends U
    ? Marcas  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Productos' ? Array < ProductosGetPayload<S['include'][P]>>  :
        P extends '_count' ? MarcasCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Productos' ? Array < ProductosGetPayload<S['select'][P]>>  :
        P extends '_count' ? MarcasCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Marcas ? Marcas[P] : never
  } 
    : Marcas
  : Marcas


  type MarcasCountArgs = Merge<
    Omit<MarcasFindManyArgs, 'select' | 'include'> & {
      select?: MarcasCountAggregateInputType | true
    }
  >

  export interface MarcasDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Marcas that matches the filter.
     * @param {MarcasFindUniqueArgs} args - Arguments to find a Marcas
     * @example
     * // Get one Marcas
     * const marcas = await prisma.marcas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarcasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarcasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Marcas'> extends True ? CheckSelect<T, Prisma__MarcasClient<Marcas>, Prisma__MarcasClient<MarcasGetPayload<T>>> : CheckSelect<T, Prisma__MarcasClient<Marcas | null >, Prisma__MarcasClient<MarcasGetPayload<T> | null >>

    /**
     * Find the first Marcas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcasFindFirstArgs} args - Arguments to find a Marcas
     * @example
     * // Get one Marcas
     * const marcas = await prisma.marcas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarcasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarcasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Marcas'> extends True ? CheckSelect<T, Prisma__MarcasClient<Marcas>, Prisma__MarcasClient<MarcasGetPayload<T>>> : CheckSelect<T, Prisma__MarcasClient<Marcas | null >, Prisma__MarcasClient<MarcasGetPayload<T> | null >>

    /**
     * Find zero or more Marcas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marcas
     * const marcas = await prisma.marcas.findMany()
     * 
     * // Get first 10 Marcas
     * const marcas = await prisma.marcas.findMany({ take: 10 })
     * 
     * // Only select the `id_marca`
     * const marcasWithId_marcaOnly = await prisma.marcas.findMany({ select: { id_marca: true } })
     * 
    **/
    findMany<T extends MarcasFindManyArgs>(
      args?: SelectSubset<T, MarcasFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Marcas>>, PrismaPromise<Array<MarcasGetPayload<T>>>>

    /**
     * Create a Marcas.
     * @param {MarcasCreateArgs} args - Arguments to create a Marcas.
     * @example
     * // Create one Marcas
     * const Marcas = await prisma.marcas.create({
     *   data: {
     *     // ... data to create a Marcas
     *   }
     * })
     * 
    **/
    create<T extends MarcasCreateArgs>(
      args: SelectSubset<T, MarcasCreateArgs>
    ): CheckSelect<T, Prisma__MarcasClient<Marcas>, Prisma__MarcasClient<MarcasGetPayload<T>>>

    /**
     * Create many Marcas.
     *     @param {MarcasCreateManyArgs} args - Arguments to create many Marcas.
     *     @example
     *     // Create many Marcas
     *     const marcas = await prisma.marcas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarcasCreateManyArgs>(
      args?: SelectSubset<T, MarcasCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Marcas.
     * @param {MarcasDeleteArgs} args - Arguments to delete one Marcas.
     * @example
     * // Delete one Marcas
     * const Marcas = await prisma.marcas.delete({
     *   where: {
     *     // ... filter to delete one Marcas
     *   }
     * })
     * 
    **/
    delete<T extends MarcasDeleteArgs>(
      args: SelectSubset<T, MarcasDeleteArgs>
    ): CheckSelect<T, Prisma__MarcasClient<Marcas>, Prisma__MarcasClient<MarcasGetPayload<T>>>

    /**
     * Update one Marcas.
     * @param {MarcasUpdateArgs} args - Arguments to update one Marcas.
     * @example
     * // Update one Marcas
     * const marcas = await prisma.marcas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarcasUpdateArgs>(
      args: SelectSubset<T, MarcasUpdateArgs>
    ): CheckSelect<T, Prisma__MarcasClient<Marcas>, Prisma__MarcasClient<MarcasGetPayload<T>>>

    /**
     * Delete zero or more Marcas.
     * @param {MarcasDeleteManyArgs} args - Arguments to filter Marcas to delete.
     * @example
     * // Delete a few Marcas
     * const { count } = await prisma.marcas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarcasDeleteManyArgs>(
      args?: SelectSubset<T, MarcasDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marcas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marcas
     * const marcas = await prisma.marcas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarcasUpdateManyArgs>(
      args: SelectSubset<T, MarcasUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Marcas.
     * @param {MarcasUpsertArgs} args - Arguments to update or create a Marcas.
     * @example
     * // Update or create a Marcas
     * const marcas = await prisma.marcas.upsert({
     *   create: {
     *     // ... data to create a Marcas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marcas we want to update
     *   }
     * })
    **/
    upsert<T extends MarcasUpsertArgs>(
      args: SelectSubset<T, MarcasUpsertArgs>
    ): CheckSelect<T, Prisma__MarcasClient<Marcas>, Prisma__MarcasClient<MarcasGetPayload<T>>>

    /**
     * Count the number of Marcas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcasCountArgs} args - Arguments to filter Marcas to count.
     * @example
     * // Count the number of Marcas
     * const count = await prisma.marcas.count({
     *   where: {
     *     // ... the filter for the Marcas we want to count
     *   }
     * })
    **/
    count<T extends MarcasCountArgs>(
      args?: Subset<T, MarcasCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarcasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marcas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarcasAggregateArgs>(args: Subset<T, MarcasAggregateArgs>): PrismaPromise<GetMarcasAggregateType<T>>

    /**
     * Group by Marcas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarcasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarcasGroupByArgs['orderBy'] }
        : { orderBy?: MarcasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarcasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarcasGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Marcas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarcasClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Productos<T extends ProductosFindManyArgs = {}>(args?: Subset<T, ProductosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Productos>>, PrismaPromise<Array<ProductosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Marcas findUnique
   */
  export type MarcasFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Marcas
     * 
    **/
    select?: MarcasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarcasInclude | null
    /**
     * Throw an Error if a Marcas can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Marcas to fetch.
     * 
    **/
    where: MarcasWhereUniqueInput
  }


  /**
   * Marcas findFirst
   */
  export type MarcasFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Marcas
     * 
    **/
    select?: MarcasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarcasInclude | null
    /**
     * Throw an Error if a Marcas can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Marcas to fetch.
     * 
    **/
    where?: MarcasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marcas to fetch.
     * 
    **/
    orderBy?: Enumerable<MarcasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marcas.
     * 
    **/
    cursor?: MarcasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marcas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marcas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marcas.
     * 
    **/
    distinct?: Enumerable<MarcasScalarFieldEnum>
  }


  /**
   * Marcas findMany
   */
  export type MarcasFindManyArgs = {
    /**
     * Select specific fields to fetch from the Marcas
     * 
    **/
    select?: MarcasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarcasInclude | null
    /**
     * Filter, which Marcas to fetch.
     * 
    **/
    where?: MarcasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marcas to fetch.
     * 
    **/
    orderBy?: Enumerable<MarcasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Marcas.
     * 
    **/
    cursor?: MarcasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marcas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marcas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MarcasScalarFieldEnum>
  }


  /**
   * Marcas create
   */
  export type MarcasCreateArgs = {
    /**
     * Select specific fields to fetch from the Marcas
     * 
    **/
    select?: MarcasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarcasInclude | null
    /**
     * The data needed to create a Marcas.
     * 
    **/
    data: XOR<MarcasCreateInput, MarcasUncheckedCreateInput>
  }


  /**
   * Marcas createMany
   */
  export type MarcasCreateManyArgs = {
    /**
     * The data used to create many Marcas.
     * 
    **/
    data: Enumerable<MarcasCreateManyInput>
  }


  /**
   * Marcas update
   */
  export type MarcasUpdateArgs = {
    /**
     * Select specific fields to fetch from the Marcas
     * 
    **/
    select?: MarcasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarcasInclude | null
    /**
     * The data needed to update a Marcas.
     * 
    **/
    data: XOR<MarcasUpdateInput, MarcasUncheckedUpdateInput>
    /**
     * Choose, which Marcas to update.
     * 
    **/
    where: MarcasWhereUniqueInput
  }


  /**
   * Marcas updateMany
   */
  export type MarcasUpdateManyArgs = {
    /**
     * The data used to update Marcas.
     * 
    **/
    data: XOR<MarcasUpdateManyMutationInput, MarcasUncheckedUpdateManyInput>
    /**
     * Filter which Marcas to update
     * 
    **/
    where?: MarcasWhereInput
  }


  /**
   * Marcas upsert
   */
  export type MarcasUpsertArgs = {
    /**
     * Select specific fields to fetch from the Marcas
     * 
    **/
    select?: MarcasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarcasInclude | null
    /**
     * The filter to search for the Marcas to update in case it exists.
     * 
    **/
    where: MarcasWhereUniqueInput
    /**
     * In case the Marcas found by the `where` argument doesn't exist, create a new Marcas with this data.
     * 
    **/
    create: XOR<MarcasCreateInput, MarcasUncheckedCreateInput>
    /**
     * In case the Marcas was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MarcasUpdateInput, MarcasUncheckedUpdateInput>
  }


  /**
   * Marcas delete
   */
  export type MarcasDeleteArgs = {
    /**
     * Select specific fields to fetch from the Marcas
     * 
    **/
    select?: MarcasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarcasInclude | null
    /**
     * Filter which Marcas to delete.
     * 
    **/
    where: MarcasWhereUniqueInput
  }


  /**
   * Marcas deleteMany
   */
  export type MarcasDeleteManyArgs = {
    /**
     * Filter which Marcas to delete
     * 
    **/
    where?: MarcasWhereInput
  }


  /**
   * Marcas without action
   */
  export type MarcasArgs = {
    /**
     * Select specific fields to fetch from the Marcas
     * 
    **/
    select?: MarcasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarcasInclude | null
  }



  /**
   * Model Productos
   */


  export type AggregateProductos = {
    _count: ProductosCountAggregateOutputType | null
    _avg: ProductosAvgAggregateOutputType | null
    _sum: ProductosSumAggregateOutputType | null
    _min: ProductosMinAggregateOutputType | null
    _max: ProductosMaxAggregateOutputType | null
  }

  export type ProductosAvgAggregateOutputType = {
    id_producto: number | null
    id_marca: number | null
    id_categoria: number | null
    id_proveedor: number | null
    costo_producto: number | null
    precio_actual: number | null
    stock: number | null
    descuento: number | null
  }

  export type ProductosSumAggregateOutputType = {
    id_producto: number | null
    id_marca: number | null
    id_categoria: number | null
    id_proveedor: number | null
    costo_producto: number | null
    precio_actual: number | null
    stock: number | null
    descuento: number | null
  }

  export type ProductosMinAggregateOutputType = {
    id_producto: number | null
    descripcion_producto: string | null
    id_marca: number | null
    id_categoria: number | null
    id_proveedor: number | null
    cantidad_por_unidad: string | null
    costo_producto: number | null
    precio_actual: number | null
    stock: number | null
    descuento: number | null
    estado: boolean | null
    imagen: string | null
  }

  export type ProductosMaxAggregateOutputType = {
    id_producto: number | null
    descripcion_producto: string | null
    id_marca: number | null
    id_categoria: number | null
    id_proveedor: number | null
    cantidad_por_unidad: string | null
    costo_producto: number | null
    precio_actual: number | null
    stock: number | null
    descuento: number | null
    estado: boolean | null
    imagen: string | null
  }

  export type ProductosCountAggregateOutputType = {
    id_producto: number
    descripcion_producto: number
    id_marca: number
    id_categoria: number
    id_proveedor: number
    cantidad_por_unidad: number
    costo_producto: number
    precio_actual: number
    stock: number
    descuento: number
    estado: number
    imagen: number
    _all: number
  }


  export type ProductosAvgAggregateInputType = {
    id_producto?: true
    id_marca?: true
    id_categoria?: true
    id_proveedor?: true
    costo_producto?: true
    precio_actual?: true
    stock?: true
    descuento?: true
  }

  export type ProductosSumAggregateInputType = {
    id_producto?: true
    id_marca?: true
    id_categoria?: true
    id_proveedor?: true
    costo_producto?: true
    precio_actual?: true
    stock?: true
    descuento?: true
  }

  export type ProductosMinAggregateInputType = {
    id_producto?: true
    descripcion_producto?: true
    id_marca?: true
    id_categoria?: true
    id_proveedor?: true
    cantidad_por_unidad?: true
    costo_producto?: true
    precio_actual?: true
    stock?: true
    descuento?: true
    estado?: true
    imagen?: true
  }

  export type ProductosMaxAggregateInputType = {
    id_producto?: true
    descripcion_producto?: true
    id_marca?: true
    id_categoria?: true
    id_proveedor?: true
    cantidad_por_unidad?: true
    costo_producto?: true
    precio_actual?: true
    stock?: true
    descuento?: true
    estado?: true
    imagen?: true
  }

  export type ProductosCountAggregateInputType = {
    id_producto?: true
    descripcion_producto?: true
    id_marca?: true
    id_categoria?: true
    id_proveedor?: true
    cantidad_por_unidad?: true
    costo_producto?: true
    precio_actual?: true
    stock?: true
    descuento?: true
    estado?: true
    imagen?: true
    _all?: true
  }

  export type ProductosAggregateArgs = {
    /**
     * Filter which Productos to aggregate.
     * 
    **/
    where?: ProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductosMaxAggregateInputType
  }

  export type GetProductosAggregateType<T extends ProductosAggregateArgs> = {
        [P in keyof T & keyof AggregateProductos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductos[P]>
      : GetScalarType<T[P], AggregateProductos[P]>
  }




  export type ProductosGroupByArgs = {
    where?: ProductosWhereInput
    orderBy?: Enumerable<ProductosOrderByWithAggregationInput>
    by: Array<ProductosScalarFieldEnum>
    having?: ProductosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductosCountAggregateInputType | true
    _avg?: ProductosAvgAggregateInputType
    _sum?: ProductosSumAggregateInputType
    _min?: ProductosMinAggregateInputType
    _max?: ProductosMaxAggregateInputType
  }


  export type ProductosGroupByOutputType = {
    id_producto: number
    descripcion_producto: string
    id_marca: number
    id_categoria: number
    id_proveedor: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento: number | null
    estado: boolean
    imagen: string | null
    _count: ProductosCountAggregateOutputType | null
    _avg: ProductosAvgAggregateOutputType | null
    _sum: ProductosSumAggregateOutputType | null
    _min: ProductosMinAggregateOutputType | null
    _max: ProductosMaxAggregateOutputType | null
  }

  type GetProductosGroupByPayload<T extends ProductosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductosGroupByOutputType[P]>
            : GetScalarType<T[P], ProductosGroupByOutputType[P]>
        }
      >
    >


  export type ProductosSelect = {
    id_producto?: boolean
    descripcion_producto?: boolean
    id_marca?: boolean
    id_categoria?: boolean
    id_proveedor?: boolean
    cantidad_por_unidad?: boolean
    costo_producto?: boolean
    precio_actual?: boolean
    stock?: boolean
    descuento?: boolean
    estado?: boolean
    imagen?: boolean
    Categorias?: boolean | CategoriasArgs
    Marcas?: boolean | MarcasArgs
    Proveedores?: boolean | ProveedoresArgs
    CarritoItem?: boolean | CarritoItemFindManyArgs
    DetalleCompras?: boolean | DetalleComprasFindManyArgs
    DetallesVentas?: boolean | DetallesVentasFindManyArgs
    _count?: boolean | ProductosCountOutputTypeArgs
  }

  export type ProductosInclude = {
    Categorias?: boolean | CategoriasArgs
    Marcas?: boolean | MarcasArgs
    Proveedores?: boolean | ProveedoresArgs
    CarritoItem?: boolean | CarritoItemFindManyArgs
    DetalleCompras?: boolean | DetalleComprasFindManyArgs
    DetallesVentas?: boolean | DetallesVentasFindManyArgs
    _count?: boolean | ProductosCountOutputTypeArgs
  }

  export type ProductosGetPayload<
    S extends boolean | null | undefined | ProductosArgs,
    U = keyof S
      > = S extends true
        ? Productos
    : S extends undefined
    ? never
    : S extends ProductosArgs | ProductosFindManyArgs
    ?'include' extends U
    ? Productos  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Categorias' ? CategoriasGetPayload<S['include'][P]> :
        P extends 'Marcas' ? MarcasGetPayload<S['include'][P]> :
        P extends 'Proveedores' ? ProveedoresGetPayload<S['include'][P]> :
        P extends 'CarritoItem' ? Array < CarritoItemGetPayload<S['include'][P]>>  :
        P extends 'DetalleCompras' ? Array < DetalleComprasGetPayload<S['include'][P]>>  :
        P extends 'DetallesVentas' ? Array < DetallesVentasGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Categorias' ? CategoriasGetPayload<S['select'][P]> :
        P extends 'Marcas' ? MarcasGetPayload<S['select'][P]> :
        P extends 'Proveedores' ? ProveedoresGetPayload<S['select'][P]> :
        P extends 'CarritoItem' ? Array < CarritoItemGetPayload<S['select'][P]>>  :
        P extends 'DetalleCompras' ? Array < DetalleComprasGetPayload<S['select'][P]>>  :
        P extends 'DetallesVentas' ? Array < DetallesVentasGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Productos ? Productos[P] : never
  } 
    : Productos
  : Productos


  type ProductosCountArgs = Merge<
    Omit<ProductosFindManyArgs, 'select' | 'include'> & {
      select?: ProductosCountAggregateInputType | true
    }
  >

  export interface ProductosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Productos that matches the filter.
     * @param {ProductosFindUniqueArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Productos'> extends True ? CheckSelect<T, Prisma__ProductosClient<Productos>, Prisma__ProductosClient<ProductosGetPayload<T>>> : CheckSelect<T, Prisma__ProductosClient<Productos | null >, Prisma__ProductosClient<ProductosGetPayload<T> | null >>

    /**
     * Find the first Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosFindFirstArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Productos'> extends True ? CheckSelect<T, Prisma__ProductosClient<Productos>, Prisma__ProductosClient<ProductosGetPayload<T>>> : CheckSelect<T, Prisma__ProductosClient<Productos | null >, Prisma__ProductosClient<ProductosGetPayload<T> | null >>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.productos.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.productos.findMany({ take: 10 })
     * 
     * // Only select the `id_producto`
     * const productosWithId_productoOnly = await prisma.productos.findMany({ select: { id_producto: true } })
     * 
    **/
    findMany<T extends ProductosFindManyArgs>(
      args?: SelectSubset<T, ProductosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Productos>>, PrismaPromise<Array<ProductosGetPayload<T>>>>

    /**
     * Create a Productos.
     * @param {ProductosCreateArgs} args - Arguments to create a Productos.
     * @example
     * // Create one Productos
     * const Productos = await prisma.productos.create({
     *   data: {
     *     // ... data to create a Productos
     *   }
     * })
     * 
    **/
    create<T extends ProductosCreateArgs>(
      args: SelectSubset<T, ProductosCreateArgs>
    ): CheckSelect<T, Prisma__ProductosClient<Productos>, Prisma__ProductosClient<ProductosGetPayload<T>>>

    /**
     * Create many Productos.
     *     @param {ProductosCreateManyArgs} args - Arguments to create many Productos.
     *     @example
     *     // Create many Productos
     *     const productos = await prisma.productos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductosCreateManyArgs>(
      args?: SelectSubset<T, ProductosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Productos.
     * @param {ProductosDeleteArgs} args - Arguments to delete one Productos.
     * @example
     * // Delete one Productos
     * const Productos = await prisma.productos.delete({
     *   where: {
     *     // ... filter to delete one Productos
     *   }
     * })
     * 
    **/
    delete<T extends ProductosDeleteArgs>(
      args: SelectSubset<T, ProductosDeleteArgs>
    ): CheckSelect<T, Prisma__ProductosClient<Productos>, Prisma__ProductosClient<ProductosGetPayload<T>>>

    /**
     * Update one Productos.
     * @param {ProductosUpdateArgs} args - Arguments to update one Productos.
     * @example
     * // Update one Productos
     * const productos = await prisma.productos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductosUpdateArgs>(
      args: SelectSubset<T, ProductosUpdateArgs>
    ): CheckSelect<T, Prisma__ProductosClient<Productos>, Prisma__ProductosClient<ProductosGetPayload<T>>>

    /**
     * Delete zero or more Productos.
     * @param {ProductosDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.productos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductosDeleteManyArgs>(
      args?: SelectSubset<T, ProductosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const productos = await prisma.productos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductosUpdateManyArgs>(
      args: SelectSubset<T, ProductosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Productos.
     * @param {ProductosUpsertArgs} args - Arguments to update or create a Productos.
     * @example
     * // Update or create a Productos
     * const productos = await prisma.productos.upsert({
     *   create: {
     *     // ... data to create a Productos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Productos we want to update
     *   }
     * })
    **/
    upsert<T extends ProductosUpsertArgs>(
      args: SelectSubset<T, ProductosUpsertArgs>
    ): CheckSelect<T, Prisma__ProductosClient<Productos>, Prisma__ProductosClient<ProductosGetPayload<T>>>

    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.productos.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductosCountArgs>(
      args?: Subset<T, ProductosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductosAggregateArgs>(args: Subset<T, ProductosAggregateArgs>): PrismaPromise<GetProductosAggregateType<T>>

    /**
     * Group by Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductosGroupByArgs['orderBy'] }
        : { orderBy?: ProductosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductosGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Productos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Categorias<T extends CategoriasArgs = {}>(args?: Subset<T, CategoriasArgs>): CheckSelect<T, Prisma__CategoriasClient<Categorias | null >, Prisma__CategoriasClient<CategoriasGetPayload<T> | null >>;

    Marcas<T extends MarcasArgs = {}>(args?: Subset<T, MarcasArgs>): CheckSelect<T, Prisma__MarcasClient<Marcas | null >, Prisma__MarcasClient<MarcasGetPayload<T> | null >>;

    Proveedores<T extends ProveedoresArgs = {}>(args?: Subset<T, ProveedoresArgs>): CheckSelect<T, Prisma__ProveedoresClient<Proveedores | null >, Prisma__ProveedoresClient<ProveedoresGetPayload<T> | null >>;

    CarritoItem<T extends CarritoItemFindManyArgs = {}>(args?: Subset<T, CarritoItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CarritoItem>>, PrismaPromise<Array<CarritoItemGetPayload<T>>>>;

    DetalleCompras<T extends DetalleComprasFindManyArgs = {}>(args?: Subset<T, DetalleComprasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DetalleCompras>>, PrismaPromise<Array<DetalleComprasGetPayload<T>>>>;

    DetallesVentas<T extends DetallesVentasFindManyArgs = {}>(args?: Subset<T, DetallesVentasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DetallesVentas>>, PrismaPromise<Array<DetallesVentasGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Productos findUnique
   */
  export type ProductosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Productos
     * 
    **/
    select?: ProductosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductosInclude | null
    /**
     * Throw an Error if a Productos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Productos to fetch.
     * 
    **/
    where: ProductosWhereUniqueInput
  }


  /**
   * Productos findFirst
   */
  export type ProductosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Productos
     * 
    **/
    select?: ProductosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductosInclude | null
    /**
     * Throw an Error if a Productos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Productos to fetch.
     * 
    **/
    where?: ProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     * 
    **/
    cursor?: ProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     * 
    **/
    distinct?: Enumerable<ProductosScalarFieldEnum>
  }


  /**
   * Productos findMany
   */
  export type ProductosFindManyArgs = {
    /**
     * Select specific fields to fetch from the Productos
     * 
    **/
    select?: ProductosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductosInclude | null
    /**
     * Filter, which Productos to fetch.
     * 
    **/
    where?: ProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     * 
    **/
    cursor?: ProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductosScalarFieldEnum>
  }


  /**
   * Productos create
   */
  export type ProductosCreateArgs = {
    /**
     * Select specific fields to fetch from the Productos
     * 
    **/
    select?: ProductosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductosInclude | null
    /**
     * The data needed to create a Productos.
     * 
    **/
    data: XOR<ProductosCreateInput, ProductosUncheckedCreateInput>
  }


  /**
   * Productos createMany
   */
  export type ProductosCreateManyArgs = {
    /**
     * The data used to create many Productos.
     * 
    **/
    data: Enumerable<ProductosCreateManyInput>
  }


  /**
   * Productos update
   */
  export type ProductosUpdateArgs = {
    /**
     * Select specific fields to fetch from the Productos
     * 
    **/
    select?: ProductosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductosInclude | null
    /**
     * The data needed to update a Productos.
     * 
    **/
    data: XOR<ProductosUpdateInput, ProductosUncheckedUpdateInput>
    /**
     * Choose, which Productos to update.
     * 
    **/
    where: ProductosWhereUniqueInput
  }


  /**
   * Productos updateMany
   */
  export type ProductosUpdateManyArgs = {
    /**
     * The data used to update Productos.
     * 
    **/
    data: XOR<ProductosUpdateManyMutationInput, ProductosUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     * 
    **/
    where?: ProductosWhereInput
  }


  /**
   * Productos upsert
   */
  export type ProductosUpsertArgs = {
    /**
     * Select specific fields to fetch from the Productos
     * 
    **/
    select?: ProductosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductosInclude | null
    /**
     * The filter to search for the Productos to update in case it exists.
     * 
    **/
    where: ProductosWhereUniqueInput
    /**
     * In case the Productos found by the `where` argument doesn't exist, create a new Productos with this data.
     * 
    **/
    create: XOR<ProductosCreateInput, ProductosUncheckedCreateInput>
    /**
     * In case the Productos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductosUpdateInput, ProductosUncheckedUpdateInput>
  }


  /**
   * Productos delete
   */
  export type ProductosDeleteArgs = {
    /**
     * Select specific fields to fetch from the Productos
     * 
    **/
    select?: ProductosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductosInclude | null
    /**
     * Filter which Productos to delete.
     * 
    **/
    where: ProductosWhereUniqueInput
  }


  /**
   * Productos deleteMany
   */
  export type ProductosDeleteManyArgs = {
    /**
     * Filter which Productos to delete
     * 
    **/
    where?: ProductosWhereInput
  }


  /**
   * Productos without action
   */
  export type ProductosArgs = {
    /**
     * Select specific fields to fetch from the Productos
     * 
    **/
    select?: ProductosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductosInclude | null
  }



  /**
   * Model Proveedores
   */


  export type AggregateProveedores = {
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  export type ProveedoresAvgAggregateOutputType = {
    id_prov: number | null
    id_ciudad: number | null
  }

  export type ProveedoresSumAggregateOutputType = {
    id_prov: number | null
    id_ciudad: number | null
  }

  export type ProveedoresMinAggregateOutputType = {
    id_prov: number | null
    nom_prov: string | null
    telefono_prov: string | null
    correo_prov: string | null
    direccion_prov: string | null
    id_ciudad: number | null
    Estado: boolean | null
  }

  export type ProveedoresMaxAggregateOutputType = {
    id_prov: number | null
    nom_prov: string | null
    telefono_prov: string | null
    correo_prov: string | null
    direccion_prov: string | null
    id_ciudad: number | null
    Estado: boolean | null
  }

  export type ProveedoresCountAggregateOutputType = {
    id_prov: number
    nom_prov: number
    telefono_prov: number
    correo_prov: number
    direccion_prov: number
    id_ciudad: number
    Estado: number
    _all: number
  }


  export type ProveedoresAvgAggregateInputType = {
    id_prov?: true
    id_ciudad?: true
  }

  export type ProveedoresSumAggregateInputType = {
    id_prov?: true
    id_ciudad?: true
  }

  export type ProveedoresMinAggregateInputType = {
    id_prov?: true
    nom_prov?: true
    telefono_prov?: true
    correo_prov?: true
    direccion_prov?: true
    id_ciudad?: true
    Estado?: true
  }

  export type ProveedoresMaxAggregateInputType = {
    id_prov?: true
    nom_prov?: true
    telefono_prov?: true
    correo_prov?: true
    direccion_prov?: true
    id_ciudad?: true
    Estado?: true
  }

  export type ProveedoresCountAggregateInputType = {
    id_prov?: true
    nom_prov?: true
    telefono_prov?: true
    correo_prov?: true
    direccion_prov?: true
    id_ciudad?: true
    Estado?: true
    _all?: true
  }

  export type ProveedoresAggregateArgs = {
    /**
     * Filter which Proveedores to aggregate.
     * 
    **/
    where?: ProveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedores to fetch.
     * 
    **/
    orderBy?: Enumerable<ProveedoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedores from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedores.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proveedores
    **/
    _count?: true | ProveedoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedoresMaxAggregateInputType
  }

  export type GetProveedoresAggregateType<T extends ProveedoresAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedores[P]>
      : GetScalarType<T[P], AggregateProveedores[P]>
  }




  export type ProveedoresGroupByArgs = {
    where?: ProveedoresWhereInput
    orderBy?: Enumerable<ProveedoresOrderByWithAggregationInput>
    by: Array<ProveedoresScalarFieldEnum>
    having?: ProveedoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedoresCountAggregateInputType | true
    _avg?: ProveedoresAvgAggregateInputType
    _sum?: ProveedoresSumAggregateInputType
    _min?: ProveedoresMinAggregateInputType
    _max?: ProveedoresMaxAggregateInputType
  }


  export type ProveedoresGroupByOutputType = {
    id_prov: number
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    id_ciudad: number
    Estado: boolean
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  type GetProveedoresGroupByPayload<T extends ProveedoresGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProveedoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
        }
      >
    >


  export type ProveedoresSelect = {
    id_prov?: boolean
    nom_prov?: boolean
    telefono_prov?: boolean
    correo_prov?: boolean
    direccion_prov?: boolean
    id_ciudad?: boolean
    Estado?: boolean
    Ciudades?: boolean | CiudadesArgs
    Compras?: boolean | ComprasFindManyArgs
    Productos?: boolean | ProductosFindManyArgs
    _count?: boolean | ProveedoresCountOutputTypeArgs
  }

  export type ProveedoresInclude = {
    Ciudades?: boolean | CiudadesArgs
    Compras?: boolean | ComprasFindManyArgs
    Productos?: boolean | ProductosFindManyArgs
    _count?: boolean | ProveedoresCountOutputTypeArgs
  }

  export type ProveedoresGetPayload<
    S extends boolean | null | undefined | ProveedoresArgs,
    U = keyof S
      > = S extends true
        ? Proveedores
    : S extends undefined
    ? never
    : S extends ProveedoresArgs | ProveedoresFindManyArgs
    ?'include' extends U
    ? Proveedores  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Ciudades' ? CiudadesGetPayload<S['include'][P]> :
        P extends 'Compras' ? Array < ComprasGetPayload<S['include'][P]>>  :
        P extends 'Productos' ? Array < ProductosGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProveedoresCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Ciudades' ? CiudadesGetPayload<S['select'][P]> :
        P extends 'Compras' ? Array < ComprasGetPayload<S['select'][P]>>  :
        P extends 'Productos' ? Array < ProductosGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProveedoresCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Proveedores ? Proveedores[P] : never
  } 
    : Proveedores
  : Proveedores


  type ProveedoresCountArgs = Merge<
    Omit<ProveedoresFindManyArgs, 'select' | 'include'> & {
      select?: ProveedoresCountAggregateInputType | true
    }
  >

  export interface ProveedoresDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Proveedores that matches the filter.
     * @param {ProveedoresFindUniqueArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProveedoresFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProveedoresFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Proveedores'> extends True ? CheckSelect<T, Prisma__ProveedoresClient<Proveedores>, Prisma__ProveedoresClient<ProveedoresGetPayload<T>>> : CheckSelect<T, Prisma__ProveedoresClient<Proveedores | null >, Prisma__ProveedoresClient<ProveedoresGetPayload<T> | null >>

    /**
     * Find the first Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresFindFirstArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProveedoresFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProveedoresFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Proveedores'> extends True ? CheckSelect<T, Prisma__ProveedoresClient<Proveedores>, Prisma__ProveedoresClient<ProveedoresGetPayload<T>>> : CheckSelect<T, Prisma__ProveedoresClient<Proveedores | null >, Prisma__ProveedoresClient<ProveedoresGetPayload<T> | null >>

    /**
     * Find zero or more Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedores
     * const proveedores = await prisma.proveedores.findMany()
     * 
     * // Get first 10 Proveedores
     * const proveedores = await prisma.proveedores.findMany({ take: 10 })
     * 
     * // Only select the `id_prov`
     * const proveedoresWithId_provOnly = await prisma.proveedores.findMany({ select: { id_prov: true } })
     * 
    **/
    findMany<T extends ProveedoresFindManyArgs>(
      args?: SelectSubset<T, ProveedoresFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Proveedores>>, PrismaPromise<Array<ProveedoresGetPayload<T>>>>

    /**
     * Create a Proveedores.
     * @param {ProveedoresCreateArgs} args - Arguments to create a Proveedores.
     * @example
     * // Create one Proveedores
     * const Proveedores = await prisma.proveedores.create({
     *   data: {
     *     // ... data to create a Proveedores
     *   }
     * })
     * 
    **/
    create<T extends ProveedoresCreateArgs>(
      args: SelectSubset<T, ProveedoresCreateArgs>
    ): CheckSelect<T, Prisma__ProveedoresClient<Proveedores>, Prisma__ProveedoresClient<ProveedoresGetPayload<T>>>

    /**
     * Create many Proveedores.
     *     @param {ProveedoresCreateManyArgs} args - Arguments to create many Proveedores.
     *     @example
     *     // Create many Proveedores
     *     const proveedores = await prisma.proveedores.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProveedoresCreateManyArgs>(
      args?: SelectSubset<T, ProveedoresCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Proveedores.
     * @param {ProveedoresDeleteArgs} args - Arguments to delete one Proveedores.
     * @example
     * // Delete one Proveedores
     * const Proveedores = await prisma.proveedores.delete({
     *   where: {
     *     // ... filter to delete one Proveedores
     *   }
     * })
     * 
    **/
    delete<T extends ProveedoresDeleteArgs>(
      args: SelectSubset<T, ProveedoresDeleteArgs>
    ): CheckSelect<T, Prisma__ProveedoresClient<Proveedores>, Prisma__ProveedoresClient<ProveedoresGetPayload<T>>>

    /**
     * Update one Proveedores.
     * @param {ProveedoresUpdateArgs} args - Arguments to update one Proveedores.
     * @example
     * // Update one Proveedores
     * const proveedores = await prisma.proveedores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProveedoresUpdateArgs>(
      args: SelectSubset<T, ProveedoresUpdateArgs>
    ): CheckSelect<T, Prisma__ProveedoresClient<Proveedores>, Prisma__ProveedoresClient<ProveedoresGetPayload<T>>>

    /**
     * Delete zero or more Proveedores.
     * @param {ProveedoresDeleteManyArgs} args - Arguments to filter Proveedores to delete.
     * @example
     * // Delete a few Proveedores
     * const { count } = await prisma.proveedores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProveedoresDeleteManyArgs>(
      args?: SelectSubset<T, ProveedoresDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedores
     * const proveedores = await prisma.proveedores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProveedoresUpdateManyArgs>(
      args: SelectSubset<T, ProveedoresUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Proveedores.
     * @param {ProveedoresUpsertArgs} args - Arguments to update or create a Proveedores.
     * @example
     * // Update or create a Proveedores
     * const proveedores = await prisma.proveedores.upsert({
     *   create: {
     *     // ... data to create a Proveedores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedores we want to update
     *   }
     * })
    **/
    upsert<T extends ProveedoresUpsertArgs>(
      args: SelectSubset<T, ProveedoresUpsertArgs>
    ): CheckSelect<T, Prisma__ProveedoresClient<Proveedores>, Prisma__ProveedoresClient<ProveedoresGetPayload<T>>>

    /**
     * Count the number of Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresCountArgs} args - Arguments to filter Proveedores to count.
     * @example
     * // Count the number of Proveedores
     * const count = await prisma.proveedores.count({
     *   where: {
     *     // ... the filter for the Proveedores we want to count
     *   }
     * })
    **/
    count<T extends ProveedoresCountArgs>(
      args?: Subset<T, ProveedoresCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedoresAggregateArgs>(args: Subset<T, ProveedoresAggregateArgs>): PrismaPromise<GetProveedoresAggregateType<T>>

    /**
     * Group by Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProveedoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProveedoresGroupByArgs['orderBy'] }
        : { orderBy?: ProveedoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProveedoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedoresGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proveedores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProveedoresClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Ciudades<T extends CiudadesArgs = {}>(args?: Subset<T, CiudadesArgs>): CheckSelect<T, Prisma__CiudadesClient<Ciudades | null >, Prisma__CiudadesClient<CiudadesGetPayload<T> | null >>;

    Compras<T extends ComprasFindManyArgs = {}>(args?: Subset<T, ComprasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Compras>>, PrismaPromise<Array<ComprasGetPayload<T>>>>;

    Productos<T extends ProductosFindManyArgs = {}>(args?: Subset<T, ProductosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Productos>>, PrismaPromise<Array<ProductosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Proveedores findUnique
   */
  export type ProveedoresFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Proveedores
     * 
    **/
    select?: ProveedoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProveedoresInclude | null
    /**
     * Throw an Error if a Proveedores can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Proveedores to fetch.
     * 
    **/
    where: ProveedoresWhereUniqueInput
  }


  /**
   * Proveedores findFirst
   */
  export type ProveedoresFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Proveedores
     * 
    **/
    select?: ProveedoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProveedoresInclude | null
    /**
     * Throw an Error if a Proveedores can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Proveedores to fetch.
     * 
    **/
    where?: ProveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedores to fetch.
     * 
    **/
    orderBy?: Enumerable<ProveedoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proveedores.
     * 
    **/
    cursor?: ProveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedores from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedores.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proveedores.
     * 
    **/
    distinct?: Enumerable<ProveedoresScalarFieldEnum>
  }


  /**
   * Proveedores findMany
   */
  export type ProveedoresFindManyArgs = {
    /**
     * Select specific fields to fetch from the Proveedores
     * 
    **/
    select?: ProveedoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProveedoresInclude | null
    /**
     * Filter, which Proveedores to fetch.
     * 
    **/
    where?: ProveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedores to fetch.
     * 
    **/
    orderBy?: Enumerable<ProveedoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proveedores.
     * 
    **/
    cursor?: ProveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedores from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedores.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProveedoresScalarFieldEnum>
  }


  /**
   * Proveedores create
   */
  export type ProveedoresCreateArgs = {
    /**
     * Select specific fields to fetch from the Proveedores
     * 
    **/
    select?: ProveedoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProveedoresInclude | null
    /**
     * The data needed to create a Proveedores.
     * 
    **/
    data: XOR<ProveedoresCreateInput, ProveedoresUncheckedCreateInput>
  }


  /**
   * Proveedores createMany
   */
  export type ProveedoresCreateManyArgs = {
    /**
     * The data used to create many Proveedores.
     * 
    **/
    data: Enumerable<ProveedoresCreateManyInput>
  }


  /**
   * Proveedores update
   */
  export type ProveedoresUpdateArgs = {
    /**
     * Select specific fields to fetch from the Proveedores
     * 
    **/
    select?: ProveedoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProveedoresInclude | null
    /**
     * The data needed to update a Proveedores.
     * 
    **/
    data: XOR<ProveedoresUpdateInput, ProveedoresUncheckedUpdateInput>
    /**
     * Choose, which Proveedores to update.
     * 
    **/
    where: ProveedoresWhereUniqueInput
  }


  /**
   * Proveedores updateMany
   */
  export type ProveedoresUpdateManyArgs = {
    /**
     * The data used to update Proveedores.
     * 
    **/
    data: XOR<ProveedoresUpdateManyMutationInput, ProveedoresUncheckedUpdateManyInput>
    /**
     * Filter which Proveedores to update
     * 
    **/
    where?: ProveedoresWhereInput
  }


  /**
   * Proveedores upsert
   */
  export type ProveedoresUpsertArgs = {
    /**
     * Select specific fields to fetch from the Proveedores
     * 
    **/
    select?: ProveedoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProveedoresInclude | null
    /**
     * The filter to search for the Proveedores to update in case it exists.
     * 
    **/
    where: ProveedoresWhereUniqueInput
    /**
     * In case the Proveedores found by the `where` argument doesn't exist, create a new Proveedores with this data.
     * 
    **/
    create: XOR<ProveedoresCreateInput, ProveedoresUncheckedCreateInput>
    /**
     * In case the Proveedores was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProveedoresUpdateInput, ProveedoresUncheckedUpdateInput>
  }


  /**
   * Proveedores delete
   */
  export type ProveedoresDeleteArgs = {
    /**
     * Select specific fields to fetch from the Proveedores
     * 
    **/
    select?: ProveedoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProveedoresInclude | null
    /**
     * Filter which Proveedores to delete.
     * 
    **/
    where: ProveedoresWhereUniqueInput
  }


  /**
   * Proveedores deleteMany
   */
  export type ProveedoresDeleteManyArgs = {
    /**
     * Filter which Proveedores to delete
     * 
    **/
    where?: ProveedoresWhereInput
  }


  /**
   * Proveedores without action
   */
  export type ProveedoresArgs = {
    /**
     * Select specific fields to fetch from the Proveedores
     * 
    **/
    select?: ProveedoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProveedoresInclude | null
  }



  /**
   * Model RolesEmpleados
   */


  export type AggregateRolesEmpleados = {
    _count: RolesEmpleadosCountAggregateOutputType | null
    _avg: RolesEmpleadosAvgAggregateOutputType | null
    _sum: RolesEmpleadosSumAggregateOutputType | null
    _min: RolesEmpleadosMinAggregateOutputType | null
    _max: RolesEmpleadosMaxAggregateOutputType | null
  }

  export type RolesEmpleadosAvgAggregateOutputType = {
    id_rol: number | null
  }

  export type RolesEmpleadosSumAggregateOutputType = {
    id_rol: number | null
  }

  export type RolesEmpleadosMinAggregateOutputType = {
    id_rol: number | null
    descripcion: string | null
  }

  export type RolesEmpleadosMaxAggregateOutputType = {
    id_rol: number | null
    descripcion: string | null
  }

  export type RolesEmpleadosCountAggregateOutputType = {
    id_rol: number
    descripcion: number
    _all: number
  }


  export type RolesEmpleadosAvgAggregateInputType = {
    id_rol?: true
  }

  export type RolesEmpleadosSumAggregateInputType = {
    id_rol?: true
  }

  export type RolesEmpleadosMinAggregateInputType = {
    id_rol?: true
    descripcion?: true
  }

  export type RolesEmpleadosMaxAggregateInputType = {
    id_rol?: true
    descripcion?: true
  }

  export type RolesEmpleadosCountAggregateInputType = {
    id_rol?: true
    descripcion?: true
    _all?: true
  }

  export type RolesEmpleadosAggregateArgs = {
    /**
     * Filter which RolesEmpleados to aggregate.
     * 
    **/
    where?: RolesEmpleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesEmpleados to fetch.
     * 
    **/
    orderBy?: Enumerable<RolesEmpleadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RolesEmpleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesEmpleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesEmpleados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolesEmpleados
    **/
    _count?: true | RolesEmpleadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesEmpleadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesEmpleadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesEmpleadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesEmpleadosMaxAggregateInputType
  }

  export type GetRolesEmpleadosAggregateType<T extends RolesEmpleadosAggregateArgs> = {
        [P in keyof T & keyof AggregateRolesEmpleados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolesEmpleados[P]>
      : GetScalarType<T[P], AggregateRolesEmpleados[P]>
  }




  export type RolesEmpleadosGroupByArgs = {
    where?: RolesEmpleadosWhereInput
    orderBy?: Enumerable<RolesEmpleadosOrderByWithAggregationInput>
    by: Array<RolesEmpleadosScalarFieldEnum>
    having?: RolesEmpleadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesEmpleadosCountAggregateInputType | true
    _avg?: RolesEmpleadosAvgAggregateInputType
    _sum?: RolesEmpleadosSumAggregateInputType
    _min?: RolesEmpleadosMinAggregateInputType
    _max?: RolesEmpleadosMaxAggregateInputType
  }


  export type RolesEmpleadosGroupByOutputType = {
    id_rol: number
    descripcion: string
    _count: RolesEmpleadosCountAggregateOutputType | null
    _avg: RolesEmpleadosAvgAggregateOutputType | null
    _sum: RolesEmpleadosSumAggregateOutputType | null
    _min: RolesEmpleadosMinAggregateOutputType | null
    _max: RolesEmpleadosMaxAggregateOutputType | null
  }

  type GetRolesEmpleadosGroupByPayload<T extends RolesEmpleadosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RolesEmpleadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesEmpleadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesEmpleadosGroupByOutputType[P]>
            : GetScalarType<T[P], RolesEmpleadosGroupByOutputType[P]>
        }
      >
    >


  export type RolesEmpleadosSelect = {
    id_rol?: boolean
    descripcion?: boolean
    Empleados?: boolean | EmpleadosFindManyArgs
    _count?: boolean | RolesEmpleadosCountOutputTypeArgs
  }

  export type RolesEmpleadosInclude = {
    Empleados?: boolean | EmpleadosFindManyArgs
    _count?: boolean | RolesEmpleadosCountOutputTypeArgs
  }

  export type RolesEmpleadosGetPayload<
    S extends boolean | null | undefined | RolesEmpleadosArgs,
    U = keyof S
      > = S extends true
        ? RolesEmpleados
    : S extends undefined
    ? never
    : S extends RolesEmpleadosArgs | RolesEmpleadosFindManyArgs
    ?'include' extends U
    ? RolesEmpleados  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Empleados' ? Array < EmpleadosGetPayload<S['include'][P]>>  :
        P extends '_count' ? RolesEmpleadosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Empleados' ? Array < EmpleadosGetPayload<S['select'][P]>>  :
        P extends '_count' ? RolesEmpleadosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof RolesEmpleados ? RolesEmpleados[P] : never
  } 
    : RolesEmpleados
  : RolesEmpleados


  type RolesEmpleadosCountArgs = Merge<
    Omit<RolesEmpleadosFindManyArgs, 'select' | 'include'> & {
      select?: RolesEmpleadosCountAggregateInputType | true
    }
  >

  export interface RolesEmpleadosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RolesEmpleados that matches the filter.
     * @param {RolesEmpleadosFindUniqueArgs} args - Arguments to find a RolesEmpleados
     * @example
     * // Get one RolesEmpleados
     * const rolesEmpleados = await prisma.rolesEmpleados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolesEmpleadosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RolesEmpleadosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RolesEmpleados'> extends True ? CheckSelect<T, Prisma__RolesEmpleadosClient<RolesEmpleados>, Prisma__RolesEmpleadosClient<RolesEmpleadosGetPayload<T>>> : CheckSelect<T, Prisma__RolesEmpleadosClient<RolesEmpleados | null >, Prisma__RolesEmpleadosClient<RolesEmpleadosGetPayload<T> | null >>

    /**
     * Find the first RolesEmpleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesEmpleadosFindFirstArgs} args - Arguments to find a RolesEmpleados
     * @example
     * // Get one RolesEmpleados
     * const rolesEmpleados = await prisma.rolesEmpleados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolesEmpleadosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RolesEmpleadosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RolesEmpleados'> extends True ? CheckSelect<T, Prisma__RolesEmpleadosClient<RolesEmpleados>, Prisma__RolesEmpleadosClient<RolesEmpleadosGetPayload<T>>> : CheckSelect<T, Prisma__RolesEmpleadosClient<RolesEmpleados | null >, Prisma__RolesEmpleadosClient<RolesEmpleadosGetPayload<T> | null >>

    /**
     * Find zero or more RolesEmpleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesEmpleadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolesEmpleados
     * const rolesEmpleados = await prisma.rolesEmpleados.findMany()
     * 
     * // Get first 10 RolesEmpleados
     * const rolesEmpleados = await prisma.rolesEmpleados.findMany({ take: 10 })
     * 
     * // Only select the `id_rol`
     * const rolesEmpleadosWithId_rolOnly = await prisma.rolesEmpleados.findMany({ select: { id_rol: true } })
     * 
    **/
    findMany<T extends RolesEmpleadosFindManyArgs>(
      args?: SelectSubset<T, RolesEmpleadosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RolesEmpleados>>, PrismaPromise<Array<RolesEmpleadosGetPayload<T>>>>

    /**
     * Create a RolesEmpleados.
     * @param {RolesEmpleadosCreateArgs} args - Arguments to create a RolesEmpleados.
     * @example
     * // Create one RolesEmpleados
     * const RolesEmpleados = await prisma.rolesEmpleados.create({
     *   data: {
     *     // ... data to create a RolesEmpleados
     *   }
     * })
     * 
    **/
    create<T extends RolesEmpleadosCreateArgs>(
      args: SelectSubset<T, RolesEmpleadosCreateArgs>
    ): CheckSelect<T, Prisma__RolesEmpleadosClient<RolesEmpleados>, Prisma__RolesEmpleadosClient<RolesEmpleadosGetPayload<T>>>

    /**
     * Create many RolesEmpleados.
     *     @param {RolesEmpleadosCreateManyArgs} args - Arguments to create many RolesEmpleados.
     *     @example
     *     // Create many RolesEmpleados
     *     const rolesEmpleados = await prisma.rolesEmpleados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolesEmpleadosCreateManyArgs>(
      args?: SelectSubset<T, RolesEmpleadosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RolesEmpleados.
     * @param {RolesEmpleadosDeleteArgs} args - Arguments to delete one RolesEmpleados.
     * @example
     * // Delete one RolesEmpleados
     * const RolesEmpleados = await prisma.rolesEmpleados.delete({
     *   where: {
     *     // ... filter to delete one RolesEmpleados
     *   }
     * })
     * 
    **/
    delete<T extends RolesEmpleadosDeleteArgs>(
      args: SelectSubset<T, RolesEmpleadosDeleteArgs>
    ): CheckSelect<T, Prisma__RolesEmpleadosClient<RolesEmpleados>, Prisma__RolesEmpleadosClient<RolesEmpleadosGetPayload<T>>>

    /**
     * Update one RolesEmpleados.
     * @param {RolesEmpleadosUpdateArgs} args - Arguments to update one RolesEmpleados.
     * @example
     * // Update one RolesEmpleados
     * const rolesEmpleados = await prisma.rolesEmpleados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolesEmpleadosUpdateArgs>(
      args: SelectSubset<T, RolesEmpleadosUpdateArgs>
    ): CheckSelect<T, Prisma__RolesEmpleadosClient<RolesEmpleados>, Prisma__RolesEmpleadosClient<RolesEmpleadosGetPayload<T>>>

    /**
     * Delete zero or more RolesEmpleados.
     * @param {RolesEmpleadosDeleteManyArgs} args - Arguments to filter RolesEmpleados to delete.
     * @example
     * // Delete a few RolesEmpleados
     * const { count } = await prisma.rolesEmpleados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolesEmpleadosDeleteManyArgs>(
      args?: SelectSubset<T, RolesEmpleadosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolesEmpleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesEmpleadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolesEmpleados
     * const rolesEmpleados = await prisma.rolesEmpleados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolesEmpleadosUpdateManyArgs>(
      args: SelectSubset<T, RolesEmpleadosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RolesEmpleados.
     * @param {RolesEmpleadosUpsertArgs} args - Arguments to update or create a RolesEmpleados.
     * @example
     * // Update or create a RolesEmpleados
     * const rolesEmpleados = await prisma.rolesEmpleados.upsert({
     *   create: {
     *     // ... data to create a RolesEmpleados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolesEmpleados we want to update
     *   }
     * })
    **/
    upsert<T extends RolesEmpleadosUpsertArgs>(
      args: SelectSubset<T, RolesEmpleadosUpsertArgs>
    ): CheckSelect<T, Prisma__RolesEmpleadosClient<RolesEmpleados>, Prisma__RolesEmpleadosClient<RolesEmpleadosGetPayload<T>>>

    /**
     * Count the number of RolesEmpleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesEmpleadosCountArgs} args - Arguments to filter RolesEmpleados to count.
     * @example
     * // Count the number of RolesEmpleados
     * const count = await prisma.rolesEmpleados.count({
     *   where: {
     *     // ... the filter for the RolesEmpleados we want to count
     *   }
     * })
    **/
    count<T extends RolesEmpleadosCountArgs>(
      args?: Subset<T, RolesEmpleadosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesEmpleadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolesEmpleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesEmpleadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesEmpleadosAggregateArgs>(args: Subset<T, RolesEmpleadosAggregateArgs>): PrismaPromise<GetRolesEmpleadosAggregateType<T>>

    /**
     * Group by RolesEmpleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesEmpleadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesEmpleadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesEmpleadosGroupByArgs['orderBy'] }
        : { orderBy?: RolesEmpleadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesEmpleadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesEmpleadosGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolesEmpleados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RolesEmpleadosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Empleados<T extends EmpleadosFindManyArgs = {}>(args?: Subset<T, EmpleadosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Empleados>>, PrismaPromise<Array<EmpleadosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RolesEmpleados findUnique
   */
  export type RolesEmpleadosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RolesEmpleados
     * 
    **/
    select?: RolesEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesEmpleadosInclude | null
    /**
     * Throw an Error if a RolesEmpleados can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RolesEmpleados to fetch.
     * 
    **/
    where: RolesEmpleadosWhereUniqueInput
  }


  /**
   * RolesEmpleados findFirst
   */
  export type RolesEmpleadosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RolesEmpleados
     * 
    **/
    select?: RolesEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesEmpleadosInclude | null
    /**
     * Throw an Error if a RolesEmpleados can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RolesEmpleados to fetch.
     * 
    **/
    where?: RolesEmpleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesEmpleados to fetch.
     * 
    **/
    orderBy?: Enumerable<RolesEmpleadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolesEmpleados.
     * 
    **/
    cursor?: RolesEmpleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesEmpleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesEmpleados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolesEmpleados.
     * 
    **/
    distinct?: Enumerable<RolesEmpleadosScalarFieldEnum>
  }


  /**
   * RolesEmpleados findMany
   */
  export type RolesEmpleadosFindManyArgs = {
    /**
     * Select specific fields to fetch from the RolesEmpleados
     * 
    **/
    select?: RolesEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesEmpleadosInclude | null
    /**
     * Filter, which RolesEmpleados to fetch.
     * 
    **/
    where?: RolesEmpleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesEmpleados to fetch.
     * 
    **/
    orderBy?: Enumerable<RolesEmpleadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolesEmpleados.
     * 
    **/
    cursor?: RolesEmpleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesEmpleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesEmpleados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RolesEmpleadosScalarFieldEnum>
  }


  /**
   * RolesEmpleados create
   */
  export type RolesEmpleadosCreateArgs = {
    /**
     * Select specific fields to fetch from the RolesEmpleados
     * 
    **/
    select?: RolesEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesEmpleadosInclude | null
    /**
     * The data needed to create a RolesEmpleados.
     * 
    **/
    data: XOR<RolesEmpleadosCreateInput, RolesEmpleadosUncheckedCreateInput>
  }


  /**
   * RolesEmpleados createMany
   */
  export type RolesEmpleadosCreateManyArgs = {
    /**
     * The data used to create many RolesEmpleados.
     * 
    **/
    data: Enumerable<RolesEmpleadosCreateManyInput>
  }


  /**
   * RolesEmpleados update
   */
  export type RolesEmpleadosUpdateArgs = {
    /**
     * Select specific fields to fetch from the RolesEmpleados
     * 
    **/
    select?: RolesEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesEmpleadosInclude | null
    /**
     * The data needed to update a RolesEmpleados.
     * 
    **/
    data: XOR<RolesEmpleadosUpdateInput, RolesEmpleadosUncheckedUpdateInput>
    /**
     * Choose, which RolesEmpleados to update.
     * 
    **/
    where: RolesEmpleadosWhereUniqueInput
  }


  /**
   * RolesEmpleados updateMany
   */
  export type RolesEmpleadosUpdateManyArgs = {
    /**
     * The data used to update RolesEmpleados.
     * 
    **/
    data: XOR<RolesEmpleadosUpdateManyMutationInput, RolesEmpleadosUncheckedUpdateManyInput>
    /**
     * Filter which RolesEmpleados to update
     * 
    **/
    where?: RolesEmpleadosWhereInput
  }


  /**
   * RolesEmpleados upsert
   */
  export type RolesEmpleadosUpsertArgs = {
    /**
     * Select specific fields to fetch from the RolesEmpleados
     * 
    **/
    select?: RolesEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesEmpleadosInclude | null
    /**
     * The filter to search for the RolesEmpleados to update in case it exists.
     * 
    **/
    where: RolesEmpleadosWhereUniqueInput
    /**
     * In case the RolesEmpleados found by the `where` argument doesn't exist, create a new RolesEmpleados with this data.
     * 
    **/
    create: XOR<RolesEmpleadosCreateInput, RolesEmpleadosUncheckedCreateInput>
    /**
     * In case the RolesEmpleados was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RolesEmpleadosUpdateInput, RolesEmpleadosUncheckedUpdateInput>
  }


  /**
   * RolesEmpleados delete
   */
  export type RolesEmpleadosDeleteArgs = {
    /**
     * Select specific fields to fetch from the RolesEmpleados
     * 
    **/
    select?: RolesEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesEmpleadosInclude | null
    /**
     * Filter which RolesEmpleados to delete.
     * 
    **/
    where: RolesEmpleadosWhereUniqueInput
  }


  /**
   * RolesEmpleados deleteMany
   */
  export type RolesEmpleadosDeleteManyArgs = {
    /**
     * Filter which RolesEmpleados to delete
     * 
    **/
    where?: RolesEmpleadosWhereInput
  }


  /**
   * RolesEmpleados without action
   */
  export type RolesEmpleadosArgs = {
    /**
     * Select specific fields to fetch from the RolesEmpleados
     * 
    **/
    select?: RolesEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesEmpleadosInclude | null
  }



  /**
   * Model sysdiagrams
   */


  export type AggregateSysdiagrams = {
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  export type SysdiagramsAvgAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsSumAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsMinAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Buffer | null
  }

  export type SysdiagramsMaxAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Buffer | null
  }

  export type SysdiagramsCountAggregateOutputType = {
    name: number
    principal_id: number
    diagram_id: number
    version: number
    definition: number
    _all: number
  }


  export type SysdiagramsAvgAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsSumAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsMinAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsMaxAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsCountAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
    _all?: true
  }

  export type SysdiagramsAggregateArgs = {
    /**
     * Filter which sysdiagrams to aggregate.
     * 
    **/
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     * 
    **/
    orderBy?: Enumerable<sysdiagramsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sysdiagrams
    **/
    _count?: true | SysdiagramsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SysdiagramsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SysdiagramsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SysdiagramsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type GetSysdiagramsAggregateType<T extends SysdiagramsAggregateArgs> = {
        [P in keyof T & keyof AggregateSysdiagrams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSysdiagrams[P]>
      : GetScalarType<T[P], AggregateSysdiagrams[P]>
  }




  export type SysdiagramsGroupByArgs = {
    where?: sysdiagramsWhereInput
    orderBy?: Enumerable<sysdiagramsOrderByWithAggregationInput>
    by: Array<SysdiagramsScalarFieldEnum>
    having?: sysdiagramsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SysdiagramsCountAggregateInputType | true
    _avg?: SysdiagramsAvgAggregateInputType
    _sum?: SysdiagramsSumAggregateInputType
    _min?: SysdiagramsMinAggregateInputType
    _max?: SysdiagramsMaxAggregateInputType
  }


  export type SysdiagramsGroupByOutputType = {
    name: string
    principal_id: number
    diagram_id: number
    version: number | null
    definition: Buffer | null
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  type GetSysdiagramsGroupByPayload<T extends SysdiagramsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SysdiagramsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SysdiagramsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
            : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
        }
      >
    >


  export type sysdiagramsSelect = {
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }

  export type sysdiagramsGetPayload<
    S extends boolean | null | undefined | sysdiagramsArgs,
    U = keyof S
      > = S extends true
        ? sysdiagrams
    : S extends undefined
    ? never
    : S extends sysdiagramsArgs | sysdiagramsFindManyArgs
    ?'include' extends U
    ? sysdiagrams 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof sysdiagrams ? sysdiagrams[P] : never
  } 
    : sysdiagrams
  : sysdiagrams


  type sysdiagramsCountArgs = Merge<
    Omit<sysdiagramsFindManyArgs, 'select' | 'include'> & {
      select?: SysdiagramsCountAggregateInputType | true
    }
  >

  export interface sysdiagramsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Sysdiagrams that matches the filter.
     * @param {sysdiagramsFindUniqueArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sysdiagramsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sysdiagramsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sysdiagrams'> extends True ? CheckSelect<T, Prisma__sysdiagramsClient<sysdiagrams>, Prisma__sysdiagramsClient<sysdiagramsGetPayload<T>>> : CheckSelect<T, Prisma__sysdiagramsClient<sysdiagrams | null >, Prisma__sysdiagramsClient<sysdiagramsGetPayload<T> | null >>

    /**
     * Find the first Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sysdiagramsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sysdiagramsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sysdiagrams'> extends True ? CheckSelect<T, Prisma__sysdiagramsClient<sysdiagrams>, Prisma__sysdiagramsClient<sysdiagramsGetPayload<T>>> : CheckSelect<T, Prisma__sysdiagramsClient<sysdiagrams | null >, Prisma__sysdiagramsClient<sysdiagramsGetPayload<T> | null >>

    /**
     * Find zero or more Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany()
     * 
     * // Get first 10 Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sysdiagramsWithNameOnly = await prisma.sysdiagrams.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends sysdiagramsFindManyArgs>(
      args?: SelectSubset<T, sysdiagramsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<sysdiagrams>>, PrismaPromise<Array<sysdiagramsGetPayload<T>>>>

    /**
     * Create a Sysdiagrams.
     * @param {sysdiagramsCreateArgs} args - Arguments to create a Sysdiagrams.
     * @example
     * // Create one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.create({
     *   data: {
     *     // ... data to create a Sysdiagrams
     *   }
     * })
     * 
    **/
    create<T extends sysdiagramsCreateArgs>(
      args: SelectSubset<T, sysdiagramsCreateArgs>
    ): CheckSelect<T, Prisma__sysdiagramsClient<sysdiagrams>, Prisma__sysdiagramsClient<sysdiagramsGetPayload<T>>>

    /**
     * Create many Sysdiagrams.
     *     @param {sysdiagramsCreateManyArgs} args - Arguments to create many Sysdiagrams.
     *     @example
     *     // Create many Sysdiagrams
     *     const sysdiagrams = await prisma.sysdiagrams.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sysdiagramsCreateManyArgs>(
      args?: SelectSubset<T, sysdiagramsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sysdiagrams.
     * @param {sysdiagramsDeleteArgs} args - Arguments to delete one Sysdiagrams.
     * @example
     * // Delete one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.delete({
     *   where: {
     *     // ... filter to delete one Sysdiagrams
     *   }
     * })
     * 
    **/
    delete<T extends sysdiagramsDeleteArgs>(
      args: SelectSubset<T, sysdiagramsDeleteArgs>
    ): CheckSelect<T, Prisma__sysdiagramsClient<sysdiagrams>, Prisma__sysdiagramsClient<sysdiagramsGetPayload<T>>>

    /**
     * Update one Sysdiagrams.
     * @param {sysdiagramsUpdateArgs} args - Arguments to update one Sysdiagrams.
     * @example
     * // Update one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sysdiagramsUpdateArgs>(
      args: SelectSubset<T, sysdiagramsUpdateArgs>
    ): CheckSelect<T, Prisma__sysdiagramsClient<sysdiagrams>, Prisma__sysdiagramsClient<sysdiagramsGetPayload<T>>>

    /**
     * Delete zero or more Sysdiagrams.
     * @param {sysdiagramsDeleteManyArgs} args - Arguments to filter Sysdiagrams to delete.
     * @example
     * // Delete a few Sysdiagrams
     * const { count } = await prisma.sysdiagrams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sysdiagramsDeleteManyArgs>(
      args?: SelectSubset<T, sysdiagramsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sysdiagramsUpdateManyArgs>(
      args: SelectSubset<T, sysdiagramsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sysdiagrams.
     * @param {sysdiagramsUpsertArgs} args - Arguments to update or create a Sysdiagrams.
     * @example
     * // Update or create a Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.upsert({
     *   create: {
     *     // ... data to create a Sysdiagrams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to update
     *   }
     * })
    **/
    upsert<T extends sysdiagramsUpsertArgs>(
      args: SelectSubset<T, sysdiagramsUpsertArgs>
    ): CheckSelect<T, Prisma__sysdiagramsClient<sysdiagrams>, Prisma__sysdiagramsClient<sysdiagramsGetPayload<T>>>

    /**
     * Count the number of Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsCountArgs} args - Arguments to filter Sysdiagrams to count.
     * @example
     * // Count the number of Sysdiagrams
     * const count = await prisma.sysdiagrams.count({
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to count
     *   }
     * })
    **/
    count<T extends sysdiagramsCountArgs>(
      args?: Subset<T, sysdiagramsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SysdiagramsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysdiagramsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SysdiagramsAggregateArgs>(args: Subset<T, SysdiagramsAggregateArgs>): PrismaPromise<GetSysdiagramsAggregateType<T>>

    /**
     * Group by Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysdiagramsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SysdiagramsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SysdiagramsGroupByArgs['orderBy'] }
        : { orderBy?: SysdiagramsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SysdiagramsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSysdiagramsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for sysdiagrams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sysdiagramsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * sysdiagrams findUnique
   */
  export type sysdiagramsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     * 
    **/
    select?: sysdiagramsSelect | null
    /**
     * Throw an Error if a sysdiagrams can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which sysdiagrams to fetch.
     * 
    **/
    where: sysdiagramsWhereUniqueInput
  }


  /**
   * sysdiagrams findFirst
   */
  export type sysdiagramsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     * 
    **/
    select?: sysdiagramsSelect | null
    /**
     * Throw an Error if a sysdiagrams can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which sysdiagrams to fetch.
     * 
    **/
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     * 
    **/
    orderBy?: Enumerable<sysdiagramsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     * 
    **/
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     * 
    **/
    distinct?: Enumerable<SysdiagramsScalarFieldEnum>
  }


  /**
   * sysdiagrams findMany
   */
  export type sysdiagramsFindManyArgs = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     * 
    **/
    select?: sysdiagramsSelect | null
    /**
     * Filter, which sysdiagrams to fetch.
     * 
    **/
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     * 
    **/
    orderBy?: Enumerable<sysdiagramsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sysdiagrams.
     * 
    **/
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SysdiagramsScalarFieldEnum>
  }


  /**
   * sysdiagrams create
   */
  export type sysdiagramsCreateArgs = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     * 
    **/
    select?: sysdiagramsSelect | null
    /**
     * The data needed to create a sysdiagrams.
     * 
    **/
    data: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
  }


  /**
   * sysdiagrams createMany
   */
  export type sysdiagramsCreateManyArgs = {
    /**
     * The data used to create many sysdiagrams.
     * 
    **/
    data: Enumerable<sysdiagramsCreateManyInput>
  }


  /**
   * sysdiagrams update
   */
  export type sysdiagramsUpdateArgs = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     * 
    **/
    select?: sysdiagramsSelect | null
    /**
     * The data needed to update a sysdiagrams.
     * 
    **/
    data: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
    /**
     * Choose, which sysdiagrams to update.
     * 
    **/
    where: sysdiagramsWhereUniqueInput
  }


  /**
   * sysdiagrams updateMany
   */
  export type sysdiagramsUpdateManyArgs = {
    /**
     * The data used to update sysdiagrams.
     * 
    **/
    data: XOR<sysdiagramsUpdateManyMutationInput, sysdiagramsUncheckedUpdateManyInput>
    /**
     * Filter which sysdiagrams to update
     * 
    **/
    where?: sysdiagramsWhereInput
  }


  /**
   * sysdiagrams upsert
   */
  export type sysdiagramsUpsertArgs = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     * 
    **/
    select?: sysdiagramsSelect | null
    /**
     * The filter to search for the sysdiagrams to update in case it exists.
     * 
    **/
    where: sysdiagramsWhereUniqueInput
    /**
     * In case the sysdiagrams found by the `where` argument doesn't exist, create a new sysdiagrams with this data.
     * 
    **/
    create: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
    /**
     * In case the sysdiagrams was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
  }


  /**
   * sysdiagrams delete
   */
  export type sysdiagramsDeleteArgs = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     * 
    **/
    select?: sysdiagramsSelect | null
    /**
     * Filter which sysdiagrams to delete.
     * 
    **/
    where: sysdiagramsWhereUniqueInput
  }


  /**
   * sysdiagrams deleteMany
   */
  export type sysdiagramsDeleteManyArgs = {
    /**
     * Filter which sysdiagrams to delete
     * 
    **/
    where?: sysdiagramsWhereInput
  }


  /**
   * sysdiagrams without action
   */
  export type sysdiagramsArgs = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     * 
    **/
    select?: sysdiagramsSelect | null
  }



  /**
   * Model UsuarioEmpleados
   */


  export type AggregateUsuarioEmpleados = {
    _count: UsuarioEmpleadosCountAggregateOutputType | null
    _avg: UsuarioEmpleadosAvgAggregateOutputType | null
    _sum: UsuarioEmpleadosSumAggregateOutputType | null
    _min: UsuarioEmpleadosMinAggregateOutputType | null
    _max: UsuarioEmpleadosMaxAggregateOutputType | null
  }

  export type UsuarioEmpleadosAvgAggregateOutputType = {
    id_usuarioEmpleado: number | null
    id_empleado: number | null
  }

  export type UsuarioEmpleadosSumAggregateOutputType = {
    id_usuarioEmpleado: number | null
    id_empleado: number | null
  }

  export type UsuarioEmpleadosMinAggregateOutputType = {
    id_usuarioEmpleado: number | null
    nom_usuarioEmpleado: string | null
    estado: boolean | null
    contrasenia_empleado: string | null
    correo_empleado: string | null
    id_empleado: number | null
  }

  export type UsuarioEmpleadosMaxAggregateOutputType = {
    id_usuarioEmpleado: number | null
    nom_usuarioEmpleado: string | null
    estado: boolean | null
    contrasenia_empleado: string | null
    correo_empleado: string | null
    id_empleado: number | null
  }

  export type UsuarioEmpleadosCountAggregateOutputType = {
    id_usuarioEmpleado: number
    nom_usuarioEmpleado: number
    estado: number
    contrasenia_empleado: number
    correo_empleado: number
    id_empleado: number
    _all: number
  }


  export type UsuarioEmpleadosAvgAggregateInputType = {
    id_usuarioEmpleado?: true
    id_empleado?: true
  }

  export type UsuarioEmpleadosSumAggregateInputType = {
    id_usuarioEmpleado?: true
    id_empleado?: true
  }

  export type UsuarioEmpleadosMinAggregateInputType = {
    id_usuarioEmpleado?: true
    nom_usuarioEmpleado?: true
    estado?: true
    contrasenia_empleado?: true
    correo_empleado?: true
    id_empleado?: true
  }

  export type UsuarioEmpleadosMaxAggregateInputType = {
    id_usuarioEmpleado?: true
    nom_usuarioEmpleado?: true
    estado?: true
    contrasenia_empleado?: true
    correo_empleado?: true
    id_empleado?: true
  }

  export type UsuarioEmpleadosCountAggregateInputType = {
    id_usuarioEmpleado?: true
    nom_usuarioEmpleado?: true
    estado?: true
    contrasenia_empleado?: true
    correo_empleado?: true
    id_empleado?: true
    _all?: true
  }

  export type UsuarioEmpleadosAggregateArgs = {
    /**
     * Filter which UsuarioEmpleados to aggregate.
     * 
    **/
    where?: UsuarioEmpleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioEmpleados to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioEmpleadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UsuarioEmpleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioEmpleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioEmpleados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsuarioEmpleados
    **/
    _count?: true | UsuarioEmpleadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioEmpleadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioEmpleadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioEmpleadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioEmpleadosMaxAggregateInputType
  }

  export type GetUsuarioEmpleadosAggregateType<T extends UsuarioEmpleadosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarioEmpleados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarioEmpleados[P]>
      : GetScalarType<T[P], AggregateUsuarioEmpleados[P]>
  }




  export type UsuarioEmpleadosGroupByArgs = {
    where?: UsuarioEmpleadosWhereInput
    orderBy?: Enumerable<UsuarioEmpleadosOrderByWithAggregationInput>
    by: Array<UsuarioEmpleadosScalarFieldEnum>
    having?: UsuarioEmpleadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioEmpleadosCountAggregateInputType | true
    _avg?: UsuarioEmpleadosAvgAggregateInputType
    _sum?: UsuarioEmpleadosSumAggregateInputType
    _min?: UsuarioEmpleadosMinAggregateInputType
    _max?: UsuarioEmpleadosMaxAggregateInputType
  }


  export type UsuarioEmpleadosGroupByOutputType = {
    id_usuarioEmpleado: number
    nom_usuarioEmpleado: string
    estado: boolean
    contrasenia_empleado: string
    correo_empleado: string
    id_empleado: number
    _count: UsuarioEmpleadosCountAggregateOutputType | null
    _avg: UsuarioEmpleadosAvgAggregateOutputType | null
    _sum: UsuarioEmpleadosSumAggregateOutputType | null
    _min: UsuarioEmpleadosMinAggregateOutputType | null
    _max: UsuarioEmpleadosMaxAggregateOutputType | null
  }

  type GetUsuarioEmpleadosGroupByPayload<T extends UsuarioEmpleadosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsuarioEmpleadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioEmpleadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioEmpleadosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioEmpleadosGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioEmpleadosSelect = {
    id_usuarioEmpleado?: boolean
    nom_usuarioEmpleado?: boolean
    estado?: boolean
    contrasenia_empleado?: boolean
    correo_empleado?: boolean
    id_empleado?: boolean
    Empleados?: boolean | EmpleadosArgs
  }

  export type UsuarioEmpleadosInclude = {
    Empleados?: boolean | EmpleadosArgs
  }

  export type UsuarioEmpleadosGetPayload<
    S extends boolean | null | undefined | UsuarioEmpleadosArgs,
    U = keyof S
      > = S extends true
        ? UsuarioEmpleados
    : S extends undefined
    ? never
    : S extends UsuarioEmpleadosArgs | UsuarioEmpleadosFindManyArgs
    ?'include' extends U
    ? UsuarioEmpleados  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Empleados' ? EmpleadosGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Empleados' ? EmpleadosGetPayload<S['select'][P]> :  P extends keyof UsuarioEmpleados ? UsuarioEmpleados[P] : never
  } 
    : UsuarioEmpleados
  : UsuarioEmpleados


  type UsuarioEmpleadosCountArgs = Merge<
    Omit<UsuarioEmpleadosFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioEmpleadosCountAggregateInputType | true
    }
  >

  export interface UsuarioEmpleadosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UsuarioEmpleados that matches the filter.
     * @param {UsuarioEmpleadosFindUniqueArgs} args - Arguments to find a UsuarioEmpleados
     * @example
     * // Get one UsuarioEmpleados
     * const usuarioEmpleados = await prisma.usuarioEmpleados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioEmpleadosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsuarioEmpleadosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UsuarioEmpleados'> extends True ? CheckSelect<T, Prisma__UsuarioEmpleadosClient<UsuarioEmpleados>, Prisma__UsuarioEmpleadosClient<UsuarioEmpleadosGetPayload<T>>> : CheckSelect<T, Prisma__UsuarioEmpleadosClient<UsuarioEmpleados | null >, Prisma__UsuarioEmpleadosClient<UsuarioEmpleadosGetPayload<T> | null >>

    /**
     * Find the first UsuarioEmpleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioEmpleadosFindFirstArgs} args - Arguments to find a UsuarioEmpleados
     * @example
     * // Get one UsuarioEmpleados
     * const usuarioEmpleados = await prisma.usuarioEmpleados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioEmpleadosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsuarioEmpleadosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UsuarioEmpleados'> extends True ? CheckSelect<T, Prisma__UsuarioEmpleadosClient<UsuarioEmpleados>, Prisma__UsuarioEmpleadosClient<UsuarioEmpleadosGetPayload<T>>> : CheckSelect<T, Prisma__UsuarioEmpleadosClient<UsuarioEmpleados | null >, Prisma__UsuarioEmpleadosClient<UsuarioEmpleadosGetPayload<T> | null >>

    /**
     * Find zero or more UsuarioEmpleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioEmpleadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuarioEmpleados
     * const usuarioEmpleados = await prisma.usuarioEmpleados.findMany()
     * 
     * // Get first 10 UsuarioEmpleados
     * const usuarioEmpleados = await prisma.usuarioEmpleados.findMany({ take: 10 })
     * 
     * // Only select the `id_usuarioEmpleado`
     * const usuarioEmpleadosWithId_usuarioEmpleadoOnly = await prisma.usuarioEmpleados.findMany({ select: { id_usuarioEmpleado: true } })
     * 
    **/
    findMany<T extends UsuarioEmpleadosFindManyArgs>(
      args?: SelectSubset<T, UsuarioEmpleadosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UsuarioEmpleados>>, PrismaPromise<Array<UsuarioEmpleadosGetPayload<T>>>>

    /**
     * Create a UsuarioEmpleados.
     * @param {UsuarioEmpleadosCreateArgs} args - Arguments to create a UsuarioEmpleados.
     * @example
     * // Create one UsuarioEmpleados
     * const UsuarioEmpleados = await prisma.usuarioEmpleados.create({
     *   data: {
     *     // ... data to create a UsuarioEmpleados
     *   }
     * })
     * 
    **/
    create<T extends UsuarioEmpleadosCreateArgs>(
      args: SelectSubset<T, UsuarioEmpleadosCreateArgs>
    ): CheckSelect<T, Prisma__UsuarioEmpleadosClient<UsuarioEmpleados>, Prisma__UsuarioEmpleadosClient<UsuarioEmpleadosGetPayload<T>>>

    /**
     * Create many UsuarioEmpleados.
     *     @param {UsuarioEmpleadosCreateManyArgs} args - Arguments to create many UsuarioEmpleados.
     *     @example
     *     // Create many UsuarioEmpleados
     *     const usuarioEmpleados = await prisma.usuarioEmpleados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioEmpleadosCreateManyArgs>(
      args?: SelectSubset<T, UsuarioEmpleadosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UsuarioEmpleados.
     * @param {UsuarioEmpleadosDeleteArgs} args - Arguments to delete one UsuarioEmpleados.
     * @example
     * // Delete one UsuarioEmpleados
     * const UsuarioEmpleados = await prisma.usuarioEmpleados.delete({
     *   where: {
     *     // ... filter to delete one UsuarioEmpleados
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioEmpleadosDeleteArgs>(
      args: SelectSubset<T, UsuarioEmpleadosDeleteArgs>
    ): CheckSelect<T, Prisma__UsuarioEmpleadosClient<UsuarioEmpleados>, Prisma__UsuarioEmpleadosClient<UsuarioEmpleadosGetPayload<T>>>

    /**
     * Update one UsuarioEmpleados.
     * @param {UsuarioEmpleadosUpdateArgs} args - Arguments to update one UsuarioEmpleados.
     * @example
     * // Update one UsuarioEmpleados
     * const usuarioEmpleados = await prisma.usuarioEmpleados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioEmpleadosUpdateArgs>(
      args: SelectSubset<T, UsuarioEmpleadosUpdateArgs>
    ): CheckSelect<T, Prisma__UsuarioEmpleadosClient<UsuarioEmpleados>, Prisma__UsuarioEmpleadosClient<UsuarioEmpleadosGetPayload<T>>>

    /**
     * Delete zero or more UsuarioEmpleados.
     * @param {UsuarioEmpleadosDeleteManyArgs} args - Arguments to filter UsuarioEmpleados to delete.
     * @example
     * // Delete a few UsuarioEmpleados
     * const { count } = await prisma.usuarioEmpleados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioEmpleadosDeleteManyArgs>(
      args?: SelectSubset<T, UsuarioEmpleadosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioEmpleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioEmpleadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuarioEmpleados
     * const usuarioEmpleados = await prisma.usuarioEmpleados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioEmpleadosUpdateManyArgs>(
      args: SelectSubset<T, UsuarioEmpleadosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UsuarioEmpleados.
     * @param {UsuarioEmpleadosUpsertArgs} args - Arguments to update or create a UsuarioEmpleados.
     * @example
     * // Update or create a UsuarioEmpleados
     * const usuarioEmpleados = await prisma.usuarioEmpleados.upsert({
     *   create: {
     *     // ... data to create a UsuarioEmpleados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuarioEmpleados we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioEmpleadosUpsertArgs>(
      args: SelectSubset<T, UsuarioEmpleadosUpsertArgs>
    ): CheckSelect<T, Prisma__UsuarioEmpleadosClient<UsuarioEmpleados>, Prisma__UsuarioEmpleadosClient<UsuarioEmpleadosGetPayload<T>>>

    /**
     * Count the number of UsuarioEmpleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioEmpleadosCountArgs} args - Arguments to filter UsuarioEmpleados to count.
     * @example
     * // Count the number of UsuarioEmpleados
     * const count = await prisma.usuarioEmpleados.count({
     *   where: {
     *     // ... the filter for the UsuarioEmpleados we want to count
     *   }
     * })
    **/
    count<T extends UsuarioEmpleadosCountArgs>(
      args?: Subset<T, UsuarioEmpleadosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioEmpleadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuarioEmpleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioEmpleadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioEmpleadosAggregateArgs>(args: Subset<T, UsuarioEmpleadosAggregateArgs>): PrismaPromise<GetUsuarioEmpleadosAggregateType<T>>

    /**
     * Group by UsuarioEmpleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioEmpleadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioEmpleadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioEmpleadosGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioEmpleadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioEmpleadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioEmpleadosGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsuarioEmpleados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsuarioEmpleadosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Empleados<T extends EmpleadosArgs = {}>(args?: Subset<T, EmpleadosArgs>): CheckSelect<T, Prisma__EmpleadosClient<Empleados | null >, Prisma__EmpleadosClient<EmpleadosGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UsuarioEmpleados findUnique
   */
  export type UsuarioEmpleadosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UsuarioEmpleados
     * 
    **/
    select?: UsuarioEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioEmpleadosInclude | null
    /**
     * Throw an Error if a UsuarioEmpleados can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UsuarioEmpleados to fetch.
     * 
    **/
    where: UsuarioEmpleadosWhereUniqueInput
  }


  /**
   * UsuarioEmpleados findFirst
   */
  export type UsuarioEmpleadosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UsuarioEmpleados
     * 
    **/
    select?: UsuarioEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioEmpleadosInclude | null
    /**
     * Throw an Error if a UsuarioEmpleados can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UsuarioEmpleados to fetch.
     * 
    **/
    where?: UsuarioEmpleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioEmpleados to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioEmpleadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioEmpleados.
     * 
    **/
    cursor?: UsuarioEmpleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioEmpleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioEmpleados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioEmpleados.
     * 
    **/
    distinct?: Enumerable<UsuarioEmpleadosScalarFieldEnum>
  }


  /**
   * UsuarioEmpleados findMany
   */
  export type UsuarioEmpleadosFindManyArgs = {
    /**
     * Select specific fields to fetch from the UsuarioEmpleados
     * 
    **/
    select?: UsuarioEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioEmpleadosInclude | null
    /**
     * Filter, which UsuarioEmpleados to fetch.
     * 
    **/
    where?: UsuarioEmpleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioEmpleados to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioEmpleadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsuarioEmpleados.
     * 
    **/
    cursor?: UsuarioEmpleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioEmpleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioEmpleados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsuarioEmpleadosScalarFieldEnum>
  }


  /**
   * UsuarioEmpleados create
   */
  export type UsuarioEmpleadosCreateArgs = {
    /**
     * Select specific fields to fetch from the UsuarioEmpleados
     * 
    **/
    select?: UsuarioEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioEmpleadosInclude | null
    /**
     * The data needed to create a UsuarioEmpleados.
     * 
    **/
    data: XOR<UsuarioEmpleadosCreateInput, UsuarioEmpleadosUncheckedCreateInput>
  }


  /**
   * UsuarioEmpleados createMany
   */
  export type UsuarioEmpleadosCreateManyArgs = {
    /**
     * The data used to create many UsuarioEmpleados.
     * 
    **/
    data: Enumerable<UsuarioEmpleadosCreateManyInput>
  }


  /**
   * UsuarioEmpleados update
   */
  export type UsuarioEmpleadosUpdateArgs = {
    /**
     * Select specific fields to fetch from the UsuarioEmpleados
     * 
    **/
    select?: UsuarioEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioEmpleadosInclude | null
    /**
     * The data needed to update a UsuarioEmpleados.
     * 
    **/
    data: XOR<UsuarioEmpleadosUpdateInput, UsuarioEmpleadosUncheckedUpdateInput>
    /**
     * Choose, which UsuarioEmpleados to update.
     * 
    **/
    where: UsuarioEmpleadosWhereUniqueInput
  }


  /**
   * UsuarioEmpleados updateMany
   */
  export type UsuarioEmpleadosUpdateManyArgs = {
    /**
     * The data used to update UsuarioEmpleados.
     * 
    **/
    data: XOR<UsuarioEmpleadosUpdateManyMutationInput, UsuarioEmpleadosUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioEmpleados to update
     * 
    **/
    where?: UsuarioEmpleadosWhereInput
  }


  /**
   * UsuarioEmpleados upsert
   */
  export type UsuarioEmpleadosUpsertArgs = {
    /**
     * Select specific fields to fetch from the UsuarioEmpleados
     * 
    **/
    select?: UsuarioEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioEmpleadosInclude | null
    /**
     * The filter to search for the UsuarioEmpleados to update in case it exists.
     * 
    **/
    where: UsuarioEmpleadosWhereUniqueInput
    /**
     * In case the UsuarioEmpleados found by the `where` argument doesn't exist, create a new UsuarioEmpleados with this data.
     * 
    **/
    create: XOR<UsuarioEmpleadosCreateInput, UsuarioEmpleadosUncheckedCreateInput>
    /**
     * In case the UsuarioEmpleados was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UsuarioEmpleadosUpdateInput, UsuarioEmpleadosUncheckedUpdateInput>
  }


  /**
   * UsuarioEmpleados delete
   */
  export type UsuarioEmpleadosDeleteArgs = {
    /**
     * Select specific fields to fetch from the UsuarioEmpleados
     * 
    **/
    select?: UsuarioEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioEmpleadosInclude | null
    /**
     * Filter which UsuarioEmpleados to delete.
     * 
    **/
    where: UsuarioEmpleadosWhereUniqueInput
  }


  /**
   * UsuarioEmpleados deleteMany
   */
  export type UsuarioEmpleadosDeleteManyArgs = {
    /**
     * Filter which UsuarioEmpleados to delete
     * 
    **/
    where?: UsuarioEmpleadosWhereInput
  }


  /**
   * UsuarioEmpleados without action
   */
  export type UsuarioEmpleadosArgs = {
    /**
     * Select specific fields to fetch from the UsuarioEmpleados
     * 
    **/
    select?: UsuarioEmpleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioEmpleadosInclude | null
  }



  /**
   * Model usuariosClientes
   */


  export type AggregateUsuariosClientes = {
    _count: UsuariosClientesCountAggregateOutputType | null
    _avg: UsuariosClientesAvgAggregateOutputType | null
    _sum: UsuariosClientesSumAggregateOutputType | null
    _min: UsuariosClientesMinAggregateOutputType | null
    _max: UsuariosClientesMaxAggregateOutputType | null
  }

  export type UsuariosClientesAvgAggregateOutputType = {
    id_usuarioCliente: number | null
    id_cliente: number | null
  }

  export type UsuariosClientesSumAggregateOutputType = {
    id_usuarioCliente: number | null
    id_cliente: number | null
  }

  export type UsuariosClientesMinAggregateOutputType = {
    id_usuarioCliente: number | null
    nombre_usuario: string | null
    contraenia_usuario: string | null
    id_cliente: number | null
    correo_usuario: string | null
    estado: boolean | null
  }

  export type UsuariosClientesMaxAggregateOutputType = {
    id_usuarioCliente: number | null
    nombre_usuario: string | null
    contraenia_usuario: string | null
    id_cliente: number | null
    correo_usuario: string | null
    estado: boolean | null
  }

  export type UsuariosClientesCountAggregateOutputType = {
    id_usuarioCliente: number
    nombre_usuario: number
    contraenia_usuario: number
    id_cliente: number
    correo_usuario: number
    estado: number
    _all: number
  }


  export type UsuariosClientesAvgAggregateInputType = {
    id_usuarioCliente?: true
    id_cliente?: true
  }

  export type UsuariosClientesSumAggregateInputType = {
    id_usuarioCliente?: true
    id_cliente?: true
  }

  export type UsuariosClientesMinAggregateInputType = {
    id_usuarioCliente?: true
    nombre_usuario?: true
    contraenia_usuario?: true
    id_cliente?: true
    correo_usuario?: true
    estado?: true
  }

  export type UsuariosClientesMaxAggregateInputType = {
    id_usuarioCliente?: true
    nombre_usuario?: true
    contraenia_usuario?: true
    id_cliente?: true
    correo_usuario?: true
    estado?: true
  }

  export type UsuariosClientesCountAggregateInputType = {
    id_usuarioCliente?: true
    nombre_usuario?: true
    contraenia_usuario?: true
    id_cliente?: true
    correo_usuario?: true
    estado?: true
    _all?: true
  }

  export type UsuariosClientesAggregateArgs = {
    /**
     * Filter which usuariosClientes to aggregate.
     * 
    **/
    where?: usuariosClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosClientes to fetch.
     * 
    **/
    orderBy?: Enumerable<usuariosClientesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usuariosClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosClientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosClientes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuariosClientes
    **/
    _count?: true | UsuariosClientesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosClientesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosClientesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosClientesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosClientesMaxAggregateInputType
  }

  export type GetUsuariosClientesAggregateType<T extends UsuariosClientesAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuariosClientes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuariosClientes[P]>
      : GetScalarType<T[P], AggregateUsuariosClientes[P]>
  }




  export type UsuariosClientesGroupByArgs = {
    where?: usuariosClientesWhereInput
    orderBy?: Enumerable<usuariosClientesOrderByWithAggregationInput>
    by: Array<UsuariosClientesScalarFieldEnum>
    having?: usuariosClientesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosClientesCountAggregateInputType | true
    _avg?: UsuariosClientesAvgAggregateInputType
    _sum?: UsuariosClientesSumAggregateInputType
    _min?: UsuariosClientesMinAggregateInputType
    _max?: UsuariosClientesMaxAggregateInputType
  }


  export type UsuariosClientesGroupByOutputType = {
    id_usuarioCliente: number
    nombre_usuario: string
    contraenia_usuario: string
    id_cliente: number
    correo_usuario: string
    estado: boolean
    _count: UsuariosClientesCountAggregateOutputType | null
    _avg: UsuariosClientesAvgAggregateOutputType | null
    _sum: UsuariosClientesSumAggregateOutputType | null
    _min: UsuariosClientesMinAggregateOutputType | null
    _max: UsuariosClientesMaxAggregateOutputType | null
  }

  type GetUsuariosClientesGroupByPayload<T extends UsuariosClientesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsuariosClientesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosClientesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosClientesGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosClientesGroupByOutputType[P]>
        }
      >
    >


  export type usuariosClientesSelect = {
    id_usuarioCliente?: boolean
    nombre_usuario?: boolean
    contraenia_usuario?: boolean
    id_cliente?: boolean
    correo_usuario?: boolean
    estado?: boolean
    Clientes?: boolean | ClientesArgs
    Carrito?: boolean | CarritoFindManyArgs
    DireccionesEnvio?: boolean | DireccionesEnvioFindManyArgs
    _count?: boolean | UsuariosClientesCountOutputTypeArgs
  }

  export type usuariosClientesInclude = {
    Clientes?: boolean | ClientesArgs
    Carrito?: boolean | CarritoFindManyArgs
    DireccionesEnvio?: boolean | DireccionesEnvioFindManyArgs
    _count?: boolean | UsuariosClientesCountOutputTypeArgs
  }

  export type usuariosClientesGetPayload<
    S extends boolean | null | undefined | usuariosClientesArgs,
    U = keyof S
      > = S extends true
        ? usuariosClientes
    : S extends undefined
    ? never
    : S extends usuariosClientesArgs | usuariosClientesFindManyArgs
    ?'include' extends U
    ? usuariosClientes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Clientes' ? ClientesGetPayload<S['include'][P]> :
        P extends 'Carrito' ? Array < CarritoGetPayload<S['include'][P]>>  :
        P extends 'DireccionesEnvio' ? Array < DireccionesEnvioGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsuariosClientesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Clientes' ? ClientesGetPayload<S['select'][P]> :
        P extends 'Carrito' ? Array < CarritoGetPayload<S['select'][P]>>  :
        P extends 'DireccionesEnvio' ? Array < DireccionesEnvioGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsuariosClientesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof usuariosClientes ? usuariosClientes[P] : never
  } 
    : usuariosClientes
  : usuariosClientes


  type usuariosClientesCountArgs = Merge<
    Omit<usuariosClientesFindManyArgs, 'select' | 'include'> & {
      select?: UsuariosClientesCountAggregateInputType | true
    }
  >

  export interface usuariosClientesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UsuariosClientes that matches the filter.
     * @param {usuariosClientesFindUniqueArgs} args - Arguments to find a UsuariosClientes
     * @example
     * // Get one UsuariosClientes
     * const usuariosClientes = await prisma.usuariosClientes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuariosClientesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuariosClientesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuariosClientes'> extends True ? CheckSelect<T, Prisma__usuariosClientesClient<usuariosClientes>, Prisma__usuariosClientesClient<usuariosClientesGetPayload<T>>> : CheckSelect<T, Prisma__usuariosClientesClient<usuariosClientes | null >, Prisma__usuariosClientesClient<usuariosClientesGetPayload<T> | null >>

    /**
     * Find the first UsuariosClientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosClientesFindFirstArgs} args - Arguments to find a UsuariosClientes
     * @example
     * // Get one UsuariosClientes
     * const usuariosClientes = await prisma.usuariosClientes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuariosClientesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuariosClientesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuariosClientes'> extends True ? CheckSelect<T, Prisma__usuariosClientesClient<usuariosClientes>, Prisma__usuariosClientesClient<usuariosClientesGetPayload<T>>> : CheckSelect<T, Prisma__usuariosClientesClient<usuariosClientes | null >, Prisma__usuariosClientesClient<usuariosClientesGetPayload<T> | null >>

    /**
     * Find zero or more UsuariosClientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosClientesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuariosClientes
     * const usuariosClientes = await prisma.usuariosClientes.findMany()
     * 
     * // Get first 10 UsuariosClientes
     * const usuariosClientes = await prisma.usuariosClientes.findMany({ take: 10 })
     * 
     * // Only select the `id_usuarioCliente`
     * const usuariosClientesWithId_usuarioClienteOnly = await prisma.usuariosClientes.findMany({ select: { id_usuarioCliente: true } })
     * 
    **/
    findMany<T extends usuariosClientesFindManyArgs>(
      args?: SelectSubset<T, usuariosClientesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<usuariosClientes>>, PrismaPromise<Array<usuariosClientesGetPayload<T>>>>

    /**
     * Create a UsuariosClientes.
     * @param {usuariosClientesCreateArgs} args - Arguments to create a UsuariosClientes.
     * @example
     * // Create one UsuariosClientes
     * const UsuariosClientes = await prisma.usuariosClientes.create({
     *   data: {
     *     // ... data to create a UsuariosClientes
     *   }
     * })
     * 
    **/
    create<T extends usuariosClientesCreateArgs>(
      args: SelectSubset<T, usuariosClientesCreateArgs>
    ): CheckSelect<T, Prisma__usuariosClientesClient<usuariosClientes>, Prisma__usuariosClientesClient<usuariosClientesGetPayload<T>>>

    /**
     * Create many UsuariosClientes.
     *     @param {usuariosClientesCreateManyArgs} args - Arguments to create many UsuariosClientes.
     *     @example
     *     // Create many UsuariosClientes
     *     const usuariosClientes = await prisma.usuariosClientes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuariosClientesCreateManyArgs>(
      args?: SelectSubset<T, usuariosClientesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UsuariosClientes.
     * @param {usuariosClientesDeleteArgs} args - Arguments to delete one UsuariosClientes.
     * @example
     * // Delete one UsuariosClientes
     * const UsuariosClientes = await prisma.usuariosClientes.delete({
     *   where: {
     *     // ... filter to delete one UsuariosClientes
     *   }
     * })
     * 
    **/
    delete<T extends usuariosClientesDeleteArgs>(
      args: SelectSubset<T, usuariosClientesDeleteArgs>
    ): CheckSelect<T, Prisma__usuariosClientesClient<usuariosClientes>, Prisma__usuariosClientesClient<usuariosClientesGetPayload<T>>>

    /**
     * Update one UsuariosClientes.
     * @param {usuariosClientesUpdateArgs} args - Arguments to update one UsuariosClientes.
     * @example
     * // Update one UsuariosClientes
     * const usuariosClientes = await prisma.usuariosClientes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuariosClientesUpdateArgs>(
      args: SelectSubset<T, usuariosClientesUpdateArgs>
    ): CheckSelect<T, Prisma__usuariosClientesClient<usuariosClientes>, Prisma__usuariosClientesClient<usuariosClientesGetPayload<T>>>

    /**
     * Delete zero or more UsuariosClientes.
     * @param {usuariosClientesDeleteManyArgs} args - Arguments to filter UsuariosClientes to delete.
     * @example
     * // Delete a few UsuariosClientes
     * const { count } = await prisma.usuariosClientes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuariosClientesDeleteManyArgs>(
      args?: SelectSubset<T, usuariosClientesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosClientesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuariosClientes
     * const usuariosClientes = await prisma.usuariosClientes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuariosClientesUpdateManyArgs>(
      args: SelectSubset<T, usuariosClientesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UsuariosClientes.
     * @param {usuariosClientesUpsertArgs} args - Arguments to update or create a UsuariosClientes.
     * @example
     * // Update or create a UsuariosClientes
     * const usuariosClientes = await prisma.usuariosClientes.upsert({
     *   create: {
     *     // ... data to create a UsuariosClientes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuariosClientes we want to update
     *   }
     * })
    **/
    upsert<T extends usuariosClientesUpsertArgs>(
      args: SelectSubset<T, usuariosClientesUpsertArgs>
    ): CheckSelect<T, Prisma__usuariosClientesClient<usuariosClientes>, Prisma__usuariosClientesClient<usuariosClientesGetPayload<T>>>

    /**
     * Count the number of UsuariosClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosClientesCountArgs} args - Arguments to filter UsuariosClientes to count.
     * @example
     * // Count the number of UsuariosClientes
     * const count = await prisma.usuariosClientes.count({
     *   where: {
     *     // ... the filter for the UsuariosClientes we want to count
     *   }
     * })
    **/
    count<T extends usuariosClientesCountArgs>(
      args?: Subset<T, usuariosClientesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosClientesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuariosClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosClientesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosClientesAggregateArgs>(args: Subset<T, UsuariosClientesAggregateArgs>): PrismaPromise<GetUsuariosClientesAggregateType<T>>

    /**
     * Group by UsuariosClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosClientesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuariosClientesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuariosClientesGroupByArgs['orderBy'] }
        : { orderBy?: UsuariosClientesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuariosClientesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosClientesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuariosClientes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuariosClientesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Clientes<T extends ClientesArgs = {}>(args?: Subset<T, ClientesArgs>): CheckSelect<T, Prisma__ClientesClient<Clientes | null >, Prisma__ClientesClient<ClientesGetPayload<T> | null >>;

    Carrito<T extends CarritoFindManyArgs = {}>(args?: Subset<T, CarritoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Carrito>>, PrismaPromise<Array<CarritoGetPayload<T>>>>;

    DireccionesEnvio<T extends DireccionesEnvioFindManyArgs = {}>(args?: Subset<T, DireccionesEnvioFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DireccionesEnvio>>, PrismaPromise<Array<DireccionesEnvioGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * usuariosClientes findUnique
   */
  export type usuariosClientesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the usuariosClientes
     * 
    **/
    select?: usuariosClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuariosClientesInclude | null
    /**
     * Throw an Error if a usuariosClientes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which usuariosClientes to fetch.
     * 
    **/
    where: usuariosClientesWhereUniqueInput
  }


  /**
   * usuariosClientes findFirst
   */
  export type usuariosClientesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the usuariosClientes
     * 
    **/
    select?: usuariosClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuariosClientesInclude | null
    /**
     * Throw an Error if a usuariosClientes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which usuariosClientes to fetch.
     * 
    **/
    where?: usuariosClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosClientes to fetch.
     * 
    **/
    orderBy?: Enumerable<usuariosClientesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuariosClientes.
     * 
    **/
    cursor?: usuariosClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosClientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosClientes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuariosClientes.
     * 
    **/
    distinct?: Enumerable<UsuariosClientesScalarFieldEnum>
  }


  /**
   * usuariosClientes findMany
   */
  export type usuariosClientesFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuariosClientes
     * 
    **/
    select?: usuariosClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuariosClientesInclude | null
    /**
     * Filter, which usuariosClientes to fetch.
     * 
    **/
    where?: usuariosClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosClientes to fetch.
     * 
    **/
    orderBy?: Enumerable<usuariosClientesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuariosClientes.
     * 
    **/
    cursor?: usuariosClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosClientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosClientes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsuariosClientesScalarFieldEnum>
  }


  /**
   * usuariosClientes create
   */
  export type usuariosClientesCreateArgs = {
    /**
     * Select specific fields to fetch from the usuariosClientes
     * 
    **/
    select?: usuariosClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuariosClientesInclude | null
    /**
     * The data needed to create a usuariosClientes.
     * 
    **/
    data: XOR<usuariosClientesCreateInput, usuariosClientesUncheckedCreateInput>
  }


  /**
   * usuariosClientes createMany
   */
  export type usuariosClientesCreateManyArgs = {
    /**
     * The data used to create many usuariosClientes.
     * 
    **/
    data: Enumerable<usuariosClientesCreateManyInput>
  }


  /**
   * usuariosClientes update
   */
  export type usuariosClientesUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuariosClientes
     * 
    **/
    select?: usuariosClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuariosClientesInclude | null
    /**
     * The data needed to update a usuariosClientes.
     * 
    **/
    data: XOR<usuariosClientesUpdateInput, usuariosClientesUncheckedUpdateInput>
    /**
     * Choose, which usuariosClientes to update.
     * 
    **/
    where: usuariosClientesWhereUniqueInput
  }


  /**
   * usuariosClientes updateMany
   */
  export type usuariosClientesUpdateManyArgs = {
    /**
     * The data used to update usuariosClientes.
     * 
    **/
    data: XOR<usuariosClientesUpdateManyMutationInput, usuariosClientesUncheckedUpdateManyInput>
    /**
     * Filter which usuariosClientes to update
     * 
    **/
    where?: usuariosClientesWhereInput
  }


  /**
   * usuariosClientes upsert
   */
  export type usuariosClientesUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuariosClientes
     * 
    **/
    select?: usuariosClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuariosClientesInclude | null
    /**
     * The filter to search for the usuariosClientes to update in case it exists.
     * 
    **/
    where: usuariosClientesWhereUniqueInput
    /**
     * In case the usuariosClientes found by the `where` argument doesn't exist, create a new usuariosClientes with this data.
     * 
    **/
    create: XOR<usuariosClientesCreateInput, usuariosClientesUncheckedCreateInput>
    /**
     * In case the usuariosClientes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usuariosClientesUpdateInput, usuariosClientesUncheckedUpdateInput>
  }


  /**
   * usuariosClientes delete
   */
  export type usuariosClientesDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuariosClientes
     * 
    **/
    select?: usuariosClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuariosClientesInclude | null
    /**
     * Filter which usuariosClientes to delete.
     * 
    **/
    where: usuariosClientesWhereUniqueInput
  }


  /**
   * usuariosClientes deleteMany
   */
  export type usuariosClientesDeleteManyArgs = {
    /**
     * Filter which usuariosClientes to delete
     * 
    **/
    where?: usuariosClientesWhereInput
  }


  /**
   * usuariosClientes without action
   */
  export type usuariosClientesArgs = {
    /**
     * Select specific fields to fetch from the usuariosClientes
     * 
    **/
    select?: usuariosClientesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuariosClientesInclude | null
  }



  /**
   * Model Venta
   */


  export type AggregateVenta = {
    _count: VentaCountAggregateOutputType | null
    _avg: VentaAvgAggregateOutputType | null
    _sum: VentaSumAggregateOutputType | null
    _min: VentaMinAggregateOutputType | null
    _max: VentaMaxAggregateOutputType | null
  }

  export type VentaAvgAggregateOutputType = {
    id_Venta: number | null
    id_cliente: number | null
    ISV: number | null
    id_direccionEnvio: number | null
    descuento: number | null
  }

  export type VentaSumAggregateOutputType = {
    id_Venta: number | null
    id_cliente: number | null
    ISV: number | null
    id_direccionEnvio: number | null
    descuento: number | null
  }

  export type VentaMinAggregateOutputType = {
    id_Venta: number | null
    fecha: Date | null
    id_cliente: number | null
    RTN_estado: boolean | null
    ISV: number | null
    id_direccionEnvio: number | null
    descuento: number | null
  }

  export type VentaMaxAggregateOutputType = {
    id_Venta: number | null
    fecha: Date | null
    id_cliente: number | null
    RTN_estado: boolean | null
    ISV: number | null
    id_direccionEnvio: number | null
    descuento: number | null
  }

  export type VentaCountAggregateOutputType = {
    id_Venta: number
    fecha: number
    id_cliente: number
    RTN_estado: number
    ISV: number
    id_direccionEnvio: number
    descuento: number
    _all: number
  }


  export type VentaAvgAggregateInputType = {
    id_Venta?: true
    id_cliente?: true
    ISV?: true
    id_direccionEnvio?: true
    descuento?: true
  }

  export type VentaSumAggregateInputType = {
    id_Venta?: true
    id_cliente?: true
    ISV?: true
    id_direccionEnvio?: true
    descuento?: true
  }

  export type VentaMinAggregateInputType = {
    id_Venta?: true
    fecha?: true
    id_cliente?: true
    RTN_estado?: true
    ISV?: true
    id_direccionEnvio?: true
    descuento?: true
  }

  export type VentaMaxAggregateInputType = {
    id_Venta?: true
    fecha?: true
    id_cliente?: true
    RTN_estado?: true
    ISV?: true
    id_direccionEnvio?: true
    descuento?: true
  }

  export type VentaCountAggregateInputType = {
    id_Venta?: true
    fecha?: true
    id_cliente?: true
    RTN_estado?: true
    ISV?: true
    id_direccionEnvio?: true
    descuento?: true
    _all?: true
  }

  export type VentaAggregateArgs = {
    /**
     * Filter which Venta to aggregate.
     * 
    **/
    where?: VentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     * 
    **/
    orderBy?: Enumerable<VentaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ventas
    **/
    _count?: true | VentaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VentaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VentaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VentaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VentaMaxAggregateInputType
  }

  export type GetVentaAggregateType<T extends VentaAggregateArgs> = {
        [P in keyof T & keyof AggregateVenta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenta[P]>
      : GetScalarType<T[P], AggregateVenta[P]>
  }




  export type VentaGroupByArgs = {
    where?: VentaWhereInput
    orderBy?: Enumerable<VentaOrderByWithAggregationInput>
    by: Array<VentaScalarFieldEnum>
    having?: VentaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VentaCountAggregateInputType | true
    _avg?: VentaAvgAggregateInputType
    _sum?: VentaSumAggregateInputType
    _min?: VentaMinAggregateInputType
    _max?: VentaMaxAggregateInputType
  }


  export type VentaGroupByOutputType = {
    id_Venta: number
    fecha: Date
    id_cliente: number
    RTN_estado: boolean
    ISV: number
    id_direccionEnvio: number
    descuento: number
    _count: VentaCountAggregateOutputType | null
    _avg: VentaAvgAggregateOutputType | null
    _sum: VentaSumAggregateOutputType | null
    _min: VentaMinAggregateOutputType | null
    _max: VentaMaxAggregateOutputType | null
  }

  type GetVentaGroupByPayload<T extends VentaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VentaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VentaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VentaGroupByOutputType[P]>
            : GetScalarType<T[P], VentaGroupByOutputType[P]>
        }
      >
    >


  export type VentaSelect = {
    id_Venta?: boolean
    fecha?: boolean
    id_cliente?: boolean
    RTN_estado?: boolean
    ISV?: boolean
    id_direccionEnvio?: boolean
    descuento?: boolean
    Clientes?: boolean | ClientesArgs
    DireccionesEnvio?: boolean | DireccionesEnvioArgs
    DetallesVentas?: boolean | DetallesVentasFindManyArgs
    Envios?: boolean | EnviosFindManyArgs
    _count?: boolean | VentaCountOutputTypeArgs
  }

  export type VentaInclude = {
    Clientes?: boolean | ClientesArgs
    DireccionesEnvio?: boolean | DireccionesEnvioArgs
    DetallesVentas?: boolean | DetallesVentasFindManyArgs
    Envios?: boolean | EnviosFindManyArgs
    _count?: boolean | VentaCountOutputTypeArgs
  }

  export type VentaGetPayload<
    S extends boolean | null | undefined | VentaArgs,
    U = keyof S
      > = S extends true
        ? Venta
    : S extends undefined
    ? never
    : S extends VentaArgs | VentaFindManyArgs
    ?'include' extends U
    ? Venta  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Clientes' ? ClientesGetPayload<S['include'][P]> :
        P extends 'DireccionesEnvio' ? DireccionesEnvioGetPayload<S['include'][P]> :
        P extends 'DetallesVentas' ? Array < DetallesVentasGetPayload<S['include'][P]>>  :
        P extends 'Envios' ? Array < EnviosGetPayload<S['include'][P]>>  :
        P extends '_count' ? VentaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Clientes' ? ClientesGetPayload<S['select'][P]> :
        P extends 'DireccionesEnvio' ? DireccionesEnvioGetPayload<S['select'][P]> :
        P extends 'DetallesVentas' ? Array < DetallesVentasGetPayload<S['select'][P]>>  :
        P extends 'Envios' ? Array < EnviosGetPayload<S['select'][P]>>  :
        P extends '_count' ? VentaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Venta ? Venta[P] : never
  } 
    : Venta
  : Venta


  type VentaCountArgs = Merge<
    Omit<VentaFindManyArgs, 'select' | 'include'> & {
      select?: VentaCountAggregateInputType | true
    }
  >

  export interface VentaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Venta that matches the filter.
     * @param {VentaFindUniqueArgs} args - Arguments to find a Venta
     * @example
     * // Get one Venta
     * const venta = await prisma.venta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VentaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VentaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Venta'> extends True ? CheckSelect<T, Prisma__VentaClient<Venta>, Prisma__VentaClient<VentaGetPayload<T>>> : CheckSelect<T, Prisma__VentaClient<Venta | null >, Prisma__VentaClient<VentaGetPayload<T> | null >>

    /**
     * Find the first Venta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaFindFirstArgs} args - Arguments to find a Venta
     * @example
     * // Get one Venta
     * const venta = await prisma.venta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VentaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VentaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Venta'> extends True ? CheckSelect<T, Prisma__VentaClient<Venta>, Prisma__VentaClient<VentaGetPayload<T>>> : CheckSelect<T, Prisma__VentaClient<Venta | null >, Prisma__VentaClient<VentaGetPayload<T> | null >>

    /**
     * Find zero or more Ventas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ventas
     * const ventas = await prisma.venta.findMany()
     * 
     * // Get first 10 Ventas
     * const ventas = await prisma.venta.findMany({ take: 10 })
     * 
     * // Only select the `id_Venta`
     * const ventaWithId_VentaOnly = await prisma.venta.findMany({ select: { id_Venta: true } })
     * 
    **/
    findMany<T extends VentaFindManyArgs>(
      args?: SelectSubset<T, VentaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Venta>>, PrismaPromise<Array<VentaGetPayload<T>>>>

    /**
     * Create a Venta.
     * @param {VentaCreateArgs} args - Arguments to create a Venta.
     * @example
     * // Create one Venta
     * const Venta = await prisma.venta.create({
     *   data: {
     *     // ... data to create a Venta
     *   }
     * })
     * 
    **/
    create<T extends VentaCreateArgs>(
      args: SelectSubset<T, VentaCreateArgs>
    ): CheckSelect<T, Prisma__VentaClient<Venta>, Prisma__VentaClient<VentaGetPayload<T>>>

    /**
     * Create many Ventas.
     *     @param {VentaCreateManyArgs} args - Arguments to create many Ventas.
     *     @example
     *     // Create many Ventas
     *     const venta = await prisma.venta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VentaCreateManyArgs>(
      args?: SelectSubset<T, VentaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Venta.
     * @param {VentaDeleteArgs} args - Arguments to delete one Venta.
     * @example
     * // Delete one Venta
     * const Venta = await prisma.venta.delete({
     *   where: {
     *     // ... filter to delete one Venta
     *   }
     * })
     * 
    **/
    delete<T extends VentaDeleteArgs>(
      args: SelectSubset<T, VentaDeleteArgs>
    ): CheckSelect<T, Prisma__VentaClient<Venta>, Prisma__VentaClient<VentaGetPayload<T>>>

    /**
     * Update one Venta.
     * @param {VentaUpdateArgs} args - Arguments to update one Venta.
     * @example
     * // Update one Venta
     * const venta = await prisma.venta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VentaUpdateArgs>(
      args: SelectSubset<T, VentaUpdateArgs>
    ): CheckSelect<T, Prisma__VentaClient<Venta>, Prisma__VentaClient<VentaGetPayload<T>>>

    /**
     * Delete zero or more Ventas.
     * @param {VentaDeleteManyArgs} args - Arguments to filter Ventas to delete.
     * @example
     * // Delete a few Ventas
     * const { count } = await prisma.venta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VentaDeleteManyArgs>(
      args?: SelectSubset<T, VentaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ventas
     * const venta = await prisma.venta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VentaUpdateManyArgs>(
      args: SelectSubset<T, VentaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Venta.
     * @param {VentaUpsertArgs} args - Arguments to update or create a Venta.
     * @example
     * // Update or create a Venta
     * const venta = await prisma.venta.upsert({
     *   create: {
     *     // ... data to create a Venta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venta we want to update
     *   }
     * })
    **/
    upsert<T extends VentaUpsertArgs>(
      args: SelectSubset<T, VentaUpsertArgs>
    ): CheckSelect<T, Prisma__VentaClient<Venta>, Prisma__VentaClient<VentaGetPayload<T>>>

    /**
     * Count the number of Ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaCountArgs} args - Arguments to filter Ventas to count.
     * @example
     * // Count the number of Ventas
     * const count = await prisma.venta.count({
     *   where: {
     *     // ... the filter for the Ventas we want to count
     *   }
     * })
    **/
    count<T extends VentaCountArgs>(
      args?: Subset<T, VentaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VentaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VentaAggregateArgs>(args: Subset<T, VentaAggregateArgs>): PrismaPromise<GetVentaAggregateType<T>>

    /**
     * Group by Venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VentaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VentaGroupByArgs['orderBy'] }
        : { orderBy?: VentaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VentaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVentaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VentaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Clientes<T extends ClientesArgs = {}>(args?: Subset<T, ClientesArgs>): CheckSelect<T, Prisma__ClientesClient<Clientes | null >, Prisma__ClientesClient<ClientesGetPayload<T> | null >>;

    DireccionesEnvio<T extends DireccionesEnvioArgs = {}>(args?: Subset<T, DireccionesEnvioArgs>): CheckSelect<T, Prisma__DireccionesEnvioClient<DireccionesEnvio | null >, Prisma__DireccionesEnvioClient<DireccionesEnvioGetPayload<T> | null >>;

    DetallesVentas<T extends DetallesVentasFindManyArgs = {}>(args?: Subset<T, DetallesVentasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DetallesVentas>>, PrismaPromise<Array<DetallesVentasGetPayload<T>>>>;

    Envios<T extends EnviosFindManyArgs = {}>(args?: Subset<T, EnviosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Envios>>, PrismaPromise<Array<EnviosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Venta findUnique
   */
  export type VentaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Venta
     * 
    **/
    select?: VentaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VentaInclude | null
    /**
     * Throw an Error if a Venta can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Venta to fetch.
     * 
    **/
    where: VentaWhereUniqueInput
  }


  /**
   * Venta findFirst
   */
  export type VentaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Venta
     * 
    **/
    select?: VentaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VentaInclude | null
    /**
     * Throw an Error if a Venta can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Venta to fetch.
     * 
    **/
    where?: VentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     * 
    **/
    orderBy?: Enumerable<VentaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventas.
     * 
    **/
    cursor?: VentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventas.
     * 
    **/
    distinct?: Enumerable<VentaScalarFieldEnum>
  }


  /**
   * Venta findMany
   */
  export type VentaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Venta
     * 
    **/
    select?: VentaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VentaInclude | null
    /**
     * Filter, which Ventas to fetch.
     * 
    **/
    where?: VentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     * 
    **/
    orderBy?: Enumerable<VentaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ventas.
     * 
    **/
    cursor?: VentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VentaScalarFieldEnum>
  }


  /**
   * Venta create
   */
  export type VentaCreateArgs = {
    /**
     * Select specific fields to fetch from the Venta
     * 
    **/
    select?: VentaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VentaInclude | null
    /**
     * The data needed to create a Venta.
     * 
    **/
    data: XOR<VentaCreateInput, VentaUncheckedCreateInput>
  }


  /**
   * Venta createMany
   */
  export type VentaCreateManyArgs = {
    /**
     * The data used to create many Ventas.
     * 
    **/
    data: Enumerable<VentaCreateManyInput>
  }


  /**
   * Venta update
   */
  export type VentaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Venta
     * 
    **/
    select?: VentaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VentaInclude | null
    /**
     * The data needed to update a Venta.
     * 
    **/
    data: XOR<VentaUpdateInput, VentaUncheckedUpdateInput>
    /**
     * Choose, which Venta to update.
     * 
    **/
    where: VentaWhereUniqueInput
  }


  /**
   * Venta updateMany
   */
  export type VentaUpdateManyArgs = {
    /**
     * The data used to update Ventas.
     * 
    **/
    data: XOR<VentaUpdateManyMutationInput, VentaUncheckedUpdateManyInput>
    /**
     * Filter which Ventas to update
     * 
    **/
    where?: VentaWhereInput
  }


  /**
   * Venta upsert
   */
  export type VentaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Venta
     * 
    **/
    select?: VentaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VentaInclude | null
    /**
     * The filter to search for the Venta to update in case it exists.
     * 
    **/
    where: VentaWhereUniqueInput
    /**
     * In case the Venta found by the `where` argument doesn't exist, create a new Venta with this data.
     * 
    **/
    create: XOR<VentaCreateInput, VentaUncheckedCreateInput>
    /**
     * In case the Venta was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VentaUpdateInput, VentaUncheckedUpdateInput>
  }


  /**
   * Venta delete
   */
  export type VentaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Venta
     * 
    **/
    select?: VentaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VentaInclude | null
    /**
     * Filter which Venta to delete.
     * 
    **/
    where: VentaWhereUniqueInput
  }


  /**
   * Venta deleteMany
   */
  export type VentaDeleteManyArgs = {
    /**
     * Filter which Ventas to delete
     * 
    **/
    where?: VentaWhereInput
  }


  /**
   * Venta without action
   */
  export type VentaArgs = {
    /**
     * Select specific fields to fetch from the Venta
     * 
    **/
    select?: VentaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VentaInclude | null
  }



  /**
   * Model Carrito
   */


  export type AggregateCarrito = {
    _count: CarritoCountAggregateOutputType | null
    _avg: CarritoAvgAggregateOutputType | null
    _sum: CarritoSumAggregateOutputType | null
    _min: CarritoMinAggregateOutputType | null
    _max: CarritoMaxAggregateOutputType | null
  }

  export type CarritoAvgAggregateOutputType = {
    id_carrito: number | null
    id_usuarioCliente: number | null
  }

  export type CarritoSumAggregateOutputType = {
    id_carrito: number | null
    id_usuarioCliente: number | null
  }

  export type CarritoMinAggregateOutputType = {
    id_carrito: number | null
    id_usuarioCliente: number | null
  }

  export type CarritoMaxAggregateOutputType = {
    id_carrito: number | null
    id_usuarioCliente: number | null
  }

  export type CarritoCountAggregateOutputType = {
    id_carrito: number
    id_usuarioCliente: number
    _all: number
  }


  export type CarritoAvgAggregateInputType = {
    id_carrito?: true
    id_usuarioCliente?: true
  }

  export type CarritoSumAggregateInputType = {
    id_carrito?: true
    id_usuarioCliente?: true
  }

  export type CarritoMinAggregateInputType = {
    id_carrito?: true
    id_usuarioCliente?: true
  }

  export type CarritoMaxAggregateInputType = {
    id_carrito?: true
    id_usuarioCliente?: true
  }

  export type CarritoCountAggregateInputType = {
    id_carrito?: true
    id_usuarioCliente?: true
    _all?: true
  }

  export type CarritoAggregateArgs = {
    /**
     * Filter which Carrito to aggregate.
     * 
    **/
    where?: CarritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carritos to fetch.
     * 
    **/
    orderBy?: Enumerable<CarritoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CarritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carritos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carritos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carritos
    **/
    _count?: true | CarritoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarritoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarritoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarritoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarritoMaxAggregateInputType
  }

  export type GetCarritoAggregateType<T extends CarritoAggregateArgs> = {
        [P in keyof T & keyof AggregateCarrito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarrito[P]>
      : GetScalarType<T[P], AggregateCarrito[P]>
  }




  export type CarritoGroupByArgs = {
    where?: CarritoWhereInput
    orderBy?: Enumerable<CarritoOrderByWithAggregationInput>
    by: Array<CarritoScalarFieldEnum>
    having?: CarritoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarritoCountAggregateInputType | true
    _avg?: CarritoAvgAggregateInputType
    _sum?: CarritoSumAggregateInputType
    _min?: CarritoMinAggregateInputType
    _max?: CarritoMaxAggregateInputType
  }


  export type CarritoGroupByOutputType = {
    id_carrito: number
    id_usuarioCliente: number
    _count: CarritoCountAggregateOutputType | null
    _avg: CarritoAvgAggregateOutputType | null
    _sum: CarritoSumAggregateOutputType | null
    _min: CarritoMinAggregateOutputType | null
    _max: CarritoMaxAggregateOutputType | null
  }

  type GetCarritoGroupByPayload<T extends CarritoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CarritoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarritoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarritoGroupByOutputType[P]>
            : GetScalarType<T[P], CarritoGroupByOutputType[P]>
        }
      >
    >


  export type CarritoSelect = {
    id_carrito?: boolean
    id_usuarioCliente?: boolean
    usuariosClientes?: boolean | usuariosClientesArgs
    CarritoItem?: boolean | CarritoItemFindManyArgs
    _count?: boolean | CarritoCountOutputTypeArgs
  }

  export type CarritoInclude = {
    usuariosClientes?: boolean | usuariosClientesArgs
    CarritoItem?: boolean | CarritoItemFindManyArgs
    _count?: boolean | CarritoCountOutputTypeArgs
  }

  export type CarritoGetPayload<
    S extends boolean | null | undefined | CarritoArgs,
    U = keyof S
      > = S extends true
        ? Carrito
    : S extends undefined
    ? never
    : S extends CarritoArgs | CarritoFindManyArgs
    ?'include' extends U
    ? Carrito  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuariosClientes' ? usuariosClientesGetPayload<S['include'][P]> :
        P extends 'CarritoItem' ? Array < CarritoItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? CarritoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuariosClientes' ? usuariosClientesGetPayload<S['select'][P]> :
        P extends 'CarritoItem' ? Array < CarritoItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? CarritoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Carrito ? Carrito[P] : never
  } 
    : Carrito
  : Carrito


  type CarritoCountArgs = Merge<
    Omit<CarritoFindManyArgs, 'select' | 'include'> & {
      select?: CarritoCountAggregateInputType | true
    }
  >

  export interface CarritoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Carrito that matches the filter.
     * @param {CarritoFindUniqueArgs} args - Arguments to find a Carrito
     * @example
     * // Get one Carrito
     * const carrito = await prisma.carrito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CarritoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CarritoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Carrito'> extends True ? CheckSelect<T, Prisma__CarritoClient<Carrito>, Prisma__CarritoClient<CarritoGetPayload<T>>> : CheckSelect<T, Prisma__CarritoClient<Carrito | null >, Prisma__CarritoClient<CarritoGetPayload<T> | null >>

    /**
     * Find the first Carrito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoFindFirstArgs} args - Arguments to find a Carrito
     * @example
     * // Get one Carrito
     * const carrito = await prisma.carrito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CarritoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CarritoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Carrito'> extends True ? CheckSelect<T, Prisma__CarritoClient<Carrito>, Prisma__CarritoClient<CarritoGetPayload<T>>> : CheckSelect<T, Prisma__CarritoClient<Carrito | null >, Prisma__CarritoClient<CarritoGetPayload<T> | null >>

    /**
     * Find zero or more Carritos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carritos
     * const carritos = await prisma.carrito.findMany()
     * 
     * // Get first 10 Carritos
     * const carritos = await prisma.carrito.findMany({ take: 10 })
     * 
     * // Only select the `id_carrito`
     * const carritoWithId_carritoOnly = await prisma.carrito.findMany({ select: { id_carrito: true } })
     * 
    **/
    findMany<T extends CarritoFindManyArgs>(
      args?: SelectSubset<T, CarritoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Carrito>>, PrismaPromise<Array<CarritoGetPayload<T>>>>

    /**
     * Create a Carrito.
     * @param {CarritoCreateArgs} args - Arguments to create a Carrito.
     * @example
     * // Create one Carrito
     * const Carrito = await prisma.carrito.create({
     *   data: {
     *     // ... data to create a Carrito
     *   }
     * })
     * 
    **/
    create<T extends CarritoCreateArgs>(
      args: SelectSubset<T, CarritoCreateArgs>
    ): CheckSelect<T, Prisma__CarritoClient<Carrito>, Prisma__CarritoClient<CarritoGetPayload<T>>>

    /**
     * Create many Carritos.
     *     @param {CarritoCreateManyArgs} args - Arguments to create many Carritos.
     *     @example
     *     // Create many Carritos
     *     const carrito = await prisma.carrito.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CarritoCreateManyArgs>(
      args?: SelectSubset<T, CarritoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Carrito.
     * @param {CarritoDeleteArgs} args - Arguments to delete one Carrito.
     * @example
     * // Delete one Carrito
     * const Carrito = await prisma.carrito.delete({
     *   where: {
     *     // ... filter to delete one Carrito
     *   }
     * })
     * 
    **/
    delete<T extends CarritoDeleteArgs>(
      args: SelectSubset<T, CarritoDeleteArgs>
    ): CheckSelect<T, Prisma__CarritoClient<Carrito>, Prisma__CarritoClient<CarritoGetPayload<T>>>

    /**
     * Update one Carrito.
     * @param {CarritoUpdateArgs} args - Arguments to update one Carrito.
     * @example
     * // Update one Carrito
     * const carrito = await prisma.carrito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CarritoUpdateArgs>(
      args: SelectSubset<T, CarritoUpdateArgs>
    ): CheckSelect<T, Prisma__CarritoClient<Carrito>, Prisma__CarritoClient<CarritoGetPayload<T>>>

    /**
     * Delete zero or more Carritos.
     * @param {CarritoDeleteManyArgs} args - Arguments to filter Carritos to delete.
     * @example
     * // Delete a few Carritos
     * const { count } = await prisma.carrito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CarritoDeleteManyArgs>(
      args?: SelectSubset<T, CarritoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carritos
     * const carrito = await prisma.carrito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CarritoUpdateManyArgs>(
      args: SelectSubset<T, CarritoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Carrito.
     * @param {CarritoUpsertArgs} args - Arguments to update or create a Carrito.
     * @example
     * // Update or create a Carrito
     * const carrito = await prisma.carrito.upsert({
     *   create: {
     *     // ... data to create a Carrito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carrito we want to update
     *   }
     * })
    **/
    upsert<T extends CarritoUpsertArgs>(
      args: SelectSubset<T, CarritoUpsertArgs>
    ): CheckSelect<T, Prisma__CarritoClient<Carrito>, Prisma__CarritoClient<CarritoGetPayload<T>>>

    /**
     * Count the number of Carritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoCountArgs} args - Arguments to filter Carritos to count.
     * @example
     * // Count the number of Carritos
     * const count = await prisma.carrito.count({
     *   where: {
     *     // ... the filter for the Carritos we want to count
     *   }
     * })
    **/
    count<T extends CarritoCountArgs>(
      args?: Subset<T, CarritoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarritoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarritoAggregateArgs>(args: Subset<T, CarritoAggregateArgs>): PrismaPromise<GetCarritoAggregateType<T>>

    /**
     * Group by Carrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarritoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarritoGroupByArgs['orderBy'] }
        : { orderBy?: CarritoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarritoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarritoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carrito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CarritoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuariosClientes<T extends usuariosClientesArgs = {}>(args?: Subset<T, usuariosClientesArgs>): CheckSelect<T, Prisma__usuariosClientesClient<usuariosClientes | null >, Prisma__usuariosClientesClient<usuariosClientesGetPayload<T> | null >>;

    CarritoItem<T extends CarritoItemFindManyArgs = {}>(args?: Subset<T, CarritoItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CarritoItem>>, PrismaPromise<Array<CarritoItemGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Carrito findUnique
   */
  export type CarritoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Carrito
     * 
    **/
    select?: CarritoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoInclude | null
    /**
     * Throw an Error if a Carrito can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Carrito to fetch.
     * 
    **/
    where: CarritoWhereUniqueInput
  }


  /**
   * Carrito findFirst
   */
  export type CarritoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Carrito
     * 
    **/
    select?: CarritoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoInclude | null
    /**
     * Throw an Error if a Carrito can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Carrito to fetch.
     * 
    **/
    where?: CarritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carritos to fetch.
     * 
    **/
    orderBy?: Enumerable<CarritoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carritos.
     * 
    **/
    cursor?: CarritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carritos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carritos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carritos.
     * 
    **/
    distinct?: Enumerable<CarritoScalarFieldEnum>
  }


  /**
   * Carrito findMany
   */
  export type CarritoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Carrito
     * 
    **/
    select?: CarritoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoInclude | null
    /**
     * Filter, which Carritos to fetch.
     * 
    **/
    where?: CarritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carritos to fetch.
     * 
    **/
    orderBy?: Enumerable<CarritoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carritos.
     * 
    **/
    cursor?: CarritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carritos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carritos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CarritoScalarFieldEnum>
  }


  /**
   * Carrito create
   */
  export type CarritoCreateArgs = {
    /**
     * Select specific fields to fetch from the Carrito
     * 
    **/
    select?: CarritoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoInclude | null
    /**
     * The data needed to create a Carrito.
     * 
    **/
    data: XOR<CarritoCreateInput, CarritoUncheckedCreateInput>
  }


  /**
   * Carrito createMany
   */
  export type CarritoCreateManyArgs = {
    /**
     * The data used to create many Carritos.
     * 
    **/
    data: Enumerable<CarritoCreateManyInput>
  }


  /**
   * Carrito update
   */
  export type CarritoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Carrito
     * 
    **/
    select?: CarritoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoInclude | null
    /**
     * The data needed to update a Carrito.
     * 
    **/
    data: XOR<CarritoUpdateInput, CarritoUncheckedUpdateInput>
    /**
     * Choose, which Carrito to update.
     * 
    **/
    where: CarritoWhereUniqueInput
  }


  /**
   * Carrito updateMany
   */
  export type CarritoUpdateManyArgs = {
    /**
     * The data used to update Carritos.
     * 
    **/
    data: XOR<CarritoUpdateManyMutationInput, CarritoUncheckedUpdateManyInput>
    /**
     * Filter which Carritos to update
     * 
    **/
    where?: CarritoWhereInput
  }


  /**
   * Carrito upsert
   */
  export type CarritoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Carrito
     * 
    **/
    select?: CarritoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoInclude | null
    /**
     * The filter to search for the Carrito to update in case it exists.
     * 
    **/
    where: CarritoWhereUniqueInput
    /**
     * In case the Carrito found by the `where` argument doesn't exist, create a new Carrito with this data.
     * 
    **/
    create: XOR<CarritoCreateInput, CarritoUncheckedCreateInput>
    /**
     * In case the Carrito was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CarritoUpdateInput, CarritoUncheckedUpdateInput>
  }


  /**
   * Carrito delete
   */
  export type CarritoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Carrito
     * 
    **/
    select?: CarritoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoInclude | null
    /**
     * Filter which Carrito to delete.
     * 
    **/
    where: CarritoWhereUniqueInput
  }


  /**
   * Carrito deleteMany
   */
  export type CarritoDeleteManyArgs = {
    /**
     * Filter which Carritos to delete
     * 
    **/
    where?: CarritoWhereInput
  }


  /**
   * Carrito without action
   */
  export type CarritoArgs = {
    /**
     * Select specific fields to fetch from the Carrito
     * 
    **/
    select?: CarritoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoInclude | null
  }



  /**
   * Model CarritoItem
   */


  export type AggregateCarritoItem = {
    _count: CarritoItemCountAggregateOutputType | null
    _avg: CarritoItemAvgAggregateOutputType | null
    _sum: CarritoItemSumAggregateOutputType | null
    _min: CarritoItemMinAggregateOutputType | null
    _max: CarritoItemMaxAggregateOutputType | null
  }

  export type CarritoItemAvgAggregateOutputType = {
    id_itemCarrito: number | null
    id_Carrito: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type CarritoItemSumAggregateOutputType = {
    id_itemCarrito: number | null
    id_Carrito: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type CarritoItemMinAggregateOutputType = {
    id_itemCarrito: number | null
    id_Carrito: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type CarritoItemMaxAggregateOutputType = {
    id_itemCarrito: number | null
    id_Carrito: number | null
    id_producto: number | null
    cantidad: number | null
  }

  export type CarritoItemCountAggregateOutputType = {
    id_itemCarrito: number
    id_Carrito: number
    id_producto: number
    cantidad: number
    _all: number
  }


  export type CarritoItemAvgAggregateInputType = {
    id_itemCarrito?: true
    id_Carrito?: true
    id_producto?: true
    cantidad?: true
  }

  export type CarritoItemSumAggregateInputType = {
    id_itemCarrito?: true
    id_Carrito?: true
    id_producto?: true
    cantidad?: true
  }

  export type CarritoItemMinAggregateInputType = {
    id_itemCarrito?: true
    id_Carrito?: true
    id_producto?: true
    cantidad?: true
  }

  export type CarritoItemMaxAggregateInputType = {
    id_itemCarrito?: true
    id_Carrito?: true
    id_producto?: true
    cantidad?: true
  }

  export type CarritoItemCountAggregateInputType = {
    id_itemCarrito?: true
    id_Carrito?: true
    id_producto?: true
    cantidad?: true
    _all?: true
  }

  export type CarritoItemAggregateArgs = {
    /**
     * Filter which CarritoItem to aggregate.
     * 
    **/
    where?: CarritoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarritoItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CarritoItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CarritoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarritoItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarritoItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CarritoItems
    **/
    _count?: true | CarritoItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarritoItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarritoItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarritoItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarritoItemMaxAggregateInputType
  }

  export type GetCarritoItemAggregateType<T extends CarritoItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCarritoItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarritoItem[P]>
      : GetScalarType<T[P], AggregateCarritoItem[P]>
  }




  export type CarritoItemGroupByArgs = {
    where?: CarritoItemWhereInput
    orderBy?: Enumerable<CarritoItemOrderByWithAggregationInput>
    by: Array<CarritoItemScalarFieldEnum>
    having?: CarritoItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarritoItemCountAggregateInputType | true
    _avg?: CarritoItemAvgAggregateInputType
    _sum?: CarritoItemSumAggregateInputType
    _min?: CarritoItemMinAggregateInputType
    _max?: CarritoItemMaxAggregateInputType
  }


  export type CarritoItemGroupByOutputType = {
    id_itemCarrito: number
    id_Carrito: number
    id_producto: number
    cantidad: number
    _count: CarritoItemCountAggregateOutputType | null
    _avg: CarritoItemAvgAggregateOutputType | null
    _sum: CarritoItemSumAggregateOutputType | null
    _min: CarritoItemMinAggregateOutputType | null
    _max: CarritoItemMaxAggregateOutputType | null
  }

  type GetCarritoItemGroupByPayload<T extends CarritoItemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CarritoItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarritoItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarritoItemGroupByOutputType[P]>
            : GetScalarType<T[P], CarritoItemGroupByOutputType[P]>
        }
      >
    >


  export type CarritoItemSelect = {
    id_itemCarrito?: boolean
    id_Carrito?: boolean
    id_producto?: boolean
    cantidad?: boolean
    Carrito?: boolean | CarritoArgs
    Productos?: boolean | ProductosArgs
  }

  export type CarritoItemInclude = {
    Carrito?: boolean | CarritoArgs
    Productos?: boolean | ProductosArgs
  }

  export type CarritoItemGetPayload<
    S extends boolean | null | undefined | CarritoItemArgs,
    U = keyof S
      > = S extends true
        ? CarritoItem
    : S extends undefined
    ? never
    : S extends CarritoItemArgs | CarritoItemFindManyArgs
    ?'include' extends U
    ? CarritoItem  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Carrito' ? CarritoGetPayload<S['include'][P]> :
        P extends 'Productos' ? ProductosGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Carrito' ? CarritoGetPayload<S['select'][P]> :
        P extends 'Productos' ? ProductosGetPayload<S['select'][P]> :  P extends keyof CarritoItem ? CarritoItem[P] : never
  } 
    : CarritoItem
  : CarritoItem


  type CarritoItemCountArgs = Merge<
    Omit<CarritoItemFindManyArgs, 'select' | 'include'> & {
      select?: CarritoItemCountAggregateInputType | true
    }
  >

  export interface CarritoItemDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CarritoItem that matches the filter.
     * @param {CarritoItemFindUniqueArgs} args - Arguments to find a CarritoItem
     * @example
     * // Get one CarritoItem
     * const carritoItem = await prisma.carritoItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CarritoItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CarritoItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CarritoItem'> extends True ? CheckSelect<T, Prisma__CarritoItemClient<CarritoItem>, Prisma__CarritoItemClient<CarritoItemGetPayload<T>>> : CheckSelect<T, Prisma__CarritoItemClient<CarritoItem | null >, Prisma__CarritoItemClient<CarritoItemGetPayload<T> | null >>

    /**
     * Find the first CarritoItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemFindFirstArgs} args - Arguments to find a CarritoItem
     * @example
     * // Get one CarritoItem
     * const carritoItem = await prisma.carritoItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CarritoItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CarritoItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CarritoItem'> extends True ? CheckSelect<T, Prisma__CarritoItemClient<CarritoItem>, Prisma__CarritoItemClient<CarritoItemGetPayload<T>>> : CheckSelect<T, Prisma__CarritoItemClient<CarritoItem | null >, Prisma__CarritoItemClient<CarritoItemGetPayload<T> | null >>

    /**
     * Find zero or more CarritoItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CarritoItems
     * const carritoItems = await prisma.carritoItem.findMany()
     * 
     * // Get first 10 CarritoItems
     * const carritoItems = await prisma.carritoItem.findMany({ take: 10 })
     * 
     * // Only select the `id_itemCarrito`
     * const carritoItemWithId_itemCarritoOnly = await prisma.carritoItem.findMany({ select: { id_itemCarrito: true } })
     * 
    **/
    findMany<T extends CarritoItemFindManyArgs>(
      args?: SelectSubset<T, CarritoItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CarritoItem>>, PrismaPromise<Array<CarritoItemGetPayload<T>>>>

    /**
     * Create a CarritoItem.
     * @param {CarritoItemCreateArgs} args - Arguments to create a CarritoItem.
     * @example
     * // Create one CarritoItem
     * const CarritoItem = await prisma.carritoItem.create({
     *   data: {
     *     // ... data to create a CarritoItem
     *   }
     * })
     * 
    **/
    create<T extends CarritoItemCreateArgs>(
      args: SelectSubset<T, CarritoItemCreateArgs>
    ): CheckSelect<T, Prisma__CarritoItemClient<CarritoItem>, Prisma__CarritoItemClient<CarritoItemGetPayload<T>>>

    /**
     * Create many CarritoItems.
     *     @param {CarritoItemCreateManyArgs} args - Arguments to create many CarritoItems.
     *     @example
     *     // Create many CarritoItems
     *     const carritoItem = await prisma.carritoItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CarritoItemCreateManyArgs>(
      args?: SelectSubset<T, CarritoItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CarritoItem.
     * @param {CarritoItemDeleteArgs} args - Arguments to delete one CarritoItem.
     * @example
     * // Delete one CarritoItem
     * const CarritoItem = await prisma.carritoItem.delete({
     *   where: {
     *     // ... filter to delete one CarritoItem
     *   }
     * })
     * 
    **/
    delete<T extends CarritoItemDeleteArgs>(
      args: SelectSubset<T, CarritoItemDeleteArgs>
    ): CheckSelect<T, Prisma__CarritoItemClient<CarritoItem>, Prisma__CarritoItemClient<CarritoItemGetPayload<T>>>

    /**
     * Update one CarritoItem.
     * @param {CarritoItemUpdateArgs} args - Arguments to update one CarritoItem.
     * @example
     * // Update one CarritoItem
     * const carritoItem = await prisma.carritoItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CarritoItemUpdateArgs>(
      args: SelectSubset<T, CarritoItemUpdateArgs>
    ): CheckSelect<T, Prisma__CarritoItemClient<CarritoItem>, Prisma__CarritoItemClient<CarritoItemGetPayload<T>>>

    /**
     * Delete zero or more CarritoItems.
     * @param {CarritoItemDeleteManyArgs} args - Arguments to filter CarritoItems to delete.
     * @example
     * // Delete a few CarritoItems
     * const { count } = await prisma.carritoItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CarritoItemDeleteManyArgs>(
      args?: SelectSubset<T, CarritoItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CarritoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CarritoItems
     * const carritoItem = await prisma.carritoItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CarritoItemUpdateManyArgs>(
      args: SelectSubset<T, CarritoItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CarritoItem.
     * @param {CarritoItemUpsertArgs} args - Arguments to update or create a CarritoItem.
     * @example
     * // Update or create a CarritoItem
     * const carritoItem = await prisma.carritoItem.upsert({
     *   create: {
     *     // ... data to create a CarritoItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CarritoItem we want to update
     *   }
     * })
    **/
    upsert<T extends CarritoItemUpsertArgs>(
      args: SelectSubset<T, CarritoItemUpsertArgs>
    ): CheckSelect<T, Prisma__CarritoItemClient<CarritoItem>, Prisma__CarritoItemClient<CarritoItemGetPayload<T>>>

    /**
     * Count the number of CarritoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemCountArgs} args - Arguments to filter CarritoItems to count.
     * @example
     * // Count the number of CarritoItems
     * const count = await prisma.carritoItem.count({
     *   where: {
     *     // ... the filter for the CarritoItems we want to count
     *   }
     * })
    **/
    count<T extends CarritoItemCountArgs>(
      args?: Subset<T, CarritoItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarritoItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CarritoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarritoItemAggregateArgs>(args: Subset<T, CarritoItemAggregateArgs>): PrismaPromise<GetCarritoItemAggregateType<T>>

    /**
     * Group by CarritoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarritoItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarritoItemGroupByArgs['orderBy'] }
        : { orderBy?: CarritoItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarritoItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarritoItemGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CarritoItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CarritoItemClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Carrito<T extends CarritoArgs = {}>(args?: Subset<T, CarritoArgs>): CheckSelect<T, Prisma__CarritoClient<Carrito | null >, Prisma__CarritoClient<CarritoGetPayload<T> | null >>;

    Productos<T extends ProductosArgs = {}>(args?: Subset<T, ProductosArgs>): CheckSelect<T, Prisma__ProductosClient<Productos | null >, Prisma__ProductosClient<ProductosGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CarritoItem findUnique
   */
  export type CarritoItemFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CarritoItem
     * 
    **/
    select?: CarritoItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoItemInclude | null
    /**
     * Throw an Error if a CarritoItem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CarritoItem to fetch.
     * 
    **/
    where: CarritoItemWhereUniqueInput
  }


  /**
   * CarritoItem findFirst
   */
  export type CarritoItemFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CarritoItem
     * 
    **/
    select?: CarritoItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoItemInclude | null
    /**
     * Throw an Error if a CarritoItem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CarritoItem to fetch.
     * 
    **/
    where?: CarritoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarritoItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CarritoItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarritoItems.
     * 
    **/
    cursor?: CarritoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarritoItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarritoItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarritoItems.
     * 
    **/
    distinct?: Enumerable<CarritoItemScalarFieldEnum>
  }


  /**
   * CarritoItem findMany
   */
  export type CarritoItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the CarritoItem
     * 
    **/
    select?: CarritoItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoItemInclude | null
    /**
     * Filter, which CarritoItems to fetch.
     * 
    **/
    where?: CarritoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarritoItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CarritoItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CarritoItems.
     * 
    **/
    cursor?: CarritoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarritoItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarritoItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CarritoItemScalarFieldEnum>
  }


  /**
   * CarritoItem create
   */
  export type CarritoItemCreateArgs = {
    /**
     * Select specific fields to fetch from the CarritoItem
     * 
    **/
    select?: CarritoItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoItemInclude | null
    /**
     * The data needed to create a CarritoItem.
     * 
    **/
    data: XOR<CarritoItemCreateInput, CarritoItemUncheckedCreateInput>
  }


  /**
   * CarritoItem createMany
   */
  export type CarritoItemCreateManyArgs = {
    /**
     * The data used to create many CarritoItems.
     * 
    **/
    data: Enumerable<CarritoItemCreateManyInput>
  }


  /**
   * CarritoItem update
   */
  export type CarritoItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the CarritoItem
     * 
    **/
    select?: CarritoItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoItemInclude | null
    /**
     * The data needed to update a CarritoItem.
     * 
    **/
    data: XOR<CarritoItemUpdateInput, CarritoItemUncheckedUpdateInput>
    /**
     * Choose, which CarritoItem to update.
     * 
    **/
    where: CarritoItemWhereUniqueInput
  }


  /**
   * CarritoItem updateMany
   */
  export type CarritoItemUpdateManyArgs = {
    /**
     * The data used to update CarritoItems.
     * 
    **/
    data: XOR<CarritoItemUpdateManyMutationInput, CarritoItemUncheckedUpdateManyInput>
    /**
     * Filter which CarritoItems to update
     * 
    **/
    where?: CarritoItemWhereInput
  }


  /**
   * CarritoItem upsert
   */
  export type CarritoItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the CarritoItem
     * 
    **/
    select?: CarritoItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoItemInclude | null
    /**
     * The filter to search for the CarritoItem to update in case it exists.
     * 
    **/
    where: CarritoItemWhereUniqueInput
    /**
     * In case the CarritoItem found by the `where` argument doesn't exist, create a new CarritoItem with this data.
     * 
    **/
    create: XOR<CarritoItemCreateInput, CarritoItemUncheckedCreateInput>
    /**
     * In case the CarritoItem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CarritoItemUpdateInput, CarritoItemUncheckedUpdateInput>
  }


  /**
   * CarritoItem delete
   */
  export type CarritoItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the CarritoItem
     * 
    **/
    select?: CarritoItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoItemInclude | null
    /**
     * Filter which CarritoItem to delete.
     * 
    **/
    where: CarritoItemWhereUniqueInput
  }


  /**
   * CarritoItem deleteMany
   */
  export type CarritoItemDeleteManyArgs = {
    /**
     * Filter which CarritoItems to delete
     * 
    **/
    where?: CarritoItemWhereInput
  }


  /**
   * CarritoItem without action
   */
  export type CarritoItemArgs = {
    /**
     * Select specific fields to fetch from the CarritoItem
     * 
    **/
    select?: CarritoItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarritoItemInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CategoriasScalarFieldEnum: {
    id_categoria: 'id_categoria',
    descripcion_categoria: 'descripcion_categoria',
    estado: 'estado'
  };

  export type CategoriasScalarFieldEnum = (typeof CategoriasScalarFieldEnum)[keyof typeof CategoriasScalarFieldEnum]


  export const CiudadesScalarFieldEnum: {
    id_ciudad: 'id_ciudad',
    nombre_ciudad: 'nombre_ciudad',
    codigoPostal: 'codigoPostal',
    id_departamento: 'id_departamento'
  };

  export type CiudadesScalarFieldEnum = (typeof CiudadesScalarFieldEnum)[keyof typeof CiudadesScalarFieldEnum]


  export const ClientesScalarFieldEnum: {
    id_cliente: 'id_cliente',
    nom_cliente: 'nom_cliente',
    apellido_cliente: 'apellido_cliente',
    RTN: 'RTN',
    direccion_cliente: 'direccion_cliente',
    id_ciudad: 'id_ciudad',
    tel_cliente: 'tel_cliente',
    estado: 'estado',
    DNI_Cliente: 'DNI_Cliente'
  };

  export type ClientesScalarFieldEnum = (typeof ClientesScalarFieldEnum)[keyof typeof ClientesScalarFieldEnum]


  export const ComprasScalarFieldEnum: {
    id_compra: 'id_compra',
    fecha_compra: 'fecha_compra',
    id_prov: 'id_prov',
    id_empleado: 'id_empleado',
    isv: 'isv',
    descuento: 'descuento'
  };

  export type ComprasScalarFieldEnum = (typeof ComprasScalarFieldEnum)[keyof typeof ComprasScalarFieldEnum]


  export const DepartamentosScalarFieldEnum: {
    id_departamento: 'id_departamento',
    nombreDepartamento: 'nombreDepartamento'
  };

  export type DepartamentosScalarFieldEnum = (typeof DepartamentosScalarFieldEnum)[keyof typeof DepartamentosScalarFieldEnum]


  export const DetalleComprasScalarFieldEnum: {
    id_detalleCompra: 'id_detalleCompra',
    id_producto: 'id_producto',
    id_compra: 'id_compra',
    precio: 'precio',
    cantidad: 'cantidad'
  };

  export type DetalleComprasScalarFieldEnum = (typeof DetalleComprasScalarFieldEnum)[keyof typeof DetalleComprasScalarFieldEnum]


  export const DetallesVentasScalarFieldEnum: {
    id_detalleVenta: 'id_detalleVenta',
    id_producto: 'id_producto',
    id_venta: 'id_venta',
    precio: 'precio',
    cantidad: 'cantidad'
  };

  export type DetallesVentasScalarFieldEnum = (typeof DetallesVentasScalarFieldEnum)[keyof typeof DetallesVentasScalarFieldEnum]


  export const DireccionesEnvioScalarFieldEnum: {
    id_direccionEnvio: 'id_direccionEnvio',
    direccion: 'direccion',
    id_ciudad: 'id_ciudad',
    id_usuarioCliente: 'id_usuarioCliente',
    direccion_opcional: 'direccion_opcional'
  };

  export type DireccionesEnvioScalarFieldEnum = (typeof DireccionesEnvioScalarFieldEnum)[keyof typeof DireccionesEnvioScalarFieldEnum]


  export const EmpleadosScalarFieldEnum: {
    id_empleado: 'id_empleado',
    nom_empleado: 'nom_empleado',
    apellido_empleado: 'apellido_empleado',
    telefono_empleado: 'telefono_empleado',
    direccion_empleado: 'direccion_empleado',
    id_ciudad: 'id_ciudad',
    id_rol: 'id_rol',
    fnacimiento_empleado: 'fnacimiento_empleado',
    Estado: 'Estado'
  };

  export type EmpleadosScalarFieldEnum = (typeof EmpleadosScalarFieldEnum)[keyof typeof EmpleadosScalarFieldEnum]


  export const EmpresasEnvioScalarFieldEnum: {
    id_empresaEnvio: 'id_empresaEnvio',
    nombre_empresa: 'nombre_empresa',
    direccion_empresa: 'direccion_empresa',
    telefono_empresa: 'telefono_empresa',
    id_ciudad: 'id_ciudad',
    estado: 'estado',
    correo_empresa: 'correo_empresa'
  };

  export type EmpresasEnvioScalarFieldEnum = (typeof EmpresasEnvioScalarFieldEnum)[keyof typeof EmpresasEnvioScalarFieldEnum]


  export const EnviosScalarFieldEnum: {
    id_envio: 'id_envio',
    num_rastreo: 'num_rastreo',
    id_venta: 'id_venta',
    id_empresaEnvio: 'id_empresaEnvio'
  };

  export type EnviosScalarFieldEnum = (typeof EnviosScalarFieldEnum)[keyof typeof EnviosScalarFieldEnum]


  export const MarcasScalarFieldEnum: {
    id_marca: 'id_marca',
    descripcion_marca: 'descripcion_marca',
    estado: 'estado'
  };

  export type MarcasScalarFieldEnum = (typeof MarcasScalarFieldEnum)[keyof typeof MarcasScalarFieldEnum]


  export const ProductosScalarFieldEnum: {
    id_producto: 'id_producto',
    descripcion_producto: 'descripcion_producto',
    id_marca: 'id_marca',
    id_categoria: 'id_categoria',
    id_proveedor: 'id_proveedor',
    cantidad_por_unidad: 'cantidad_por_unidad',
    costo_producto: 'costo_producto',
    precio_actual: 'precio_actual',
    stock: 'stock',
    descuento: 'descuento',
    estado: 'estado',
    imagen: 'imagen'
  };

  export type ProductosScalarFieldEnum = (typeof ProductosScalarFieldEnum)[keyof typeof ProductosScalarFieldEnum]


  export const ProveedoresScalarFieldEnum: {
    id_prov: 'id_prov',
    nom_prov: 'nom_prov',
    telefono_prov: 'telefono_prov',
    correo_prov: 'correo_prov',
    direccion_prov: 'direccion_prov',
    id_ciudad: 'id_ciudad',
    Estado: 'Estado'
  };

  export type ProveedoresScalarFieldEnum = (typeof ProveedoresScalarFieldEnum)[keyof typeof ProveedoresScalarFieldEnum]


  export const RolesEmpleadosScalarFieldEnum: {
    id_rol: 'id_rol',
    descripcion: 'descripcion'
  };

  export type RolesEmpleadosScalarFieldEnum = (typeof RolesEmpleadosScalarFieldEnum)[keyof typeof RolesEmpleadosScalarFieldEnum]


  export const SysdiagramsScalarFieldEnum: {
    name: 'name',
    principal_id: 'principal_id',
    diagram_id: 'diagram_id',
    version: 'version',
    definition: 'definition'
  };

  export type SysdiagramsScalarFieldEnum = (typeof SysdiagramsScalarFieldEnum)[keyof typeof SysdiagramsScalarFieldEnum]


  export const UsuarioEmpleadosScalarFieldEnum: {
    id_usuarioEmpleado: 'id_usuarioEmpleado',
    nom_usuarioEmpleado: 'nom_usuarioEmpleado',
    estado: 'estado',
    contrasenia_empleado: 'contrasenia_empleado',
    correo_empleado: 'correo_empleado',
    id_empleado: 'id_empleado'
  };

  export type UsuarioEmpleadosScalarFieldEnum = (typeof UsuarioEmpleadosScalarFieldEnum)[keyof typeof UsuarioEmpleadosScalarFieldEnum]


  export const UsuariosClientesScalarFieldEnum: {
    id_usuarioCliente: 'id_usuarioCliente',
    nombre_usuario: 'nombre_usuario',
    contraenia_usuario: 'contraenia_usuario',
    id_cliente: 'id_cliente',
    correo_usuario: 'correo_usuario',
    estado: 'estado'
  };

  export type UsuariosClientesScalarFieldEnum = (typeof UsuariosClientesScalarFieldEnum)[keyof typeof UsuariosClientesScalarFieldEnum]


  export const VentaScalarFieldEnum: {
    id_Venta: 'id_Venta',
    fecha: 'fecha',
    id_cliente: 'id_cliente',
    RTN_estado: 'RTN_estado',
    ISV: 'ISV',
    id_direccionEnvio: 'id_direccionEnvio',
    descuento: 'descuento'
  };

  export type VentaScalarFieldEnum = (typeof VentaScalarFieldEnum)[keyof typeof VentaScalarFieldEnum]


  export const CarritoScalarFieldEnum: {
    id_carrito: 'id_carrito',
    id_usuarioCliente: 'id_usuarioCliente'
  };

  export type CarritoScalarFieldEnum = (typeof CarritoScalarFieldEnum)[keyof typeof CarritoScalarFieldEnum]


  export const CarritoItemScalarFieldEnum: {
    id_itemCarrito: 'id_itemCarrito',
    id_Carrito: 'id_Carrito',
    id_producto: 'id_producto',
    cantidad: 'cantidad'
  };

  export type CarritoItemScalarFieldEnum = (typeof CarritoItemScalarFieldEnum)[keyof typeof CarritoItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type CategoriasWhereInput = {
    AND?: Enumerable<CategoriasWhereInput>
    OR?: Enumerable<CategoriasWhereInput>
    NOT?: Enumerable<CategoriasWhereInput>
    id_categoria?: IntFilter | number
    descripcion_categoria?: StringFilter | string
    estado?: BoolFilter | boolean
    Productos?: ProductosListRelationFilter
  }

  export type CategoriasOrderByWithRelationInput = {
    id_categoria?: SortOrder
    descripcion_categoria?: SortOrder
    estado?: SortOrder
    Productos?: ProductosOrderByRelationAggregateInput
  }

  export type CategoriasWhereUniqueInput = {
    id_categoria?: number
  }

  export type CategoriasOrderByWithAggregationInput = {
    id_categoria?: SortOrder
    descripcion_categoria?: SortOrder
    estado?: SortOrder
    _count?: CategoriasCountOrderByAggregateInput
    _avg?: CategoriasAvgOrderByAggregateInput
    _max?: CategoriasMaxOrderByAggregateInput
    _min?: CategoriasMinOrderByAggregateInput
    _sum?: CategoriasSumOrderByAggregateInput
  }

  export type CategoriasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoriasScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoriasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoriasScalarWhereWithAggregatesInput>
    id_categoria?: IntWithAggregatesFilter | number
    descripcion_categoria?: StringWithAggregatesFilter | string
    estado?: BoolWithAggregatesFilter | boolean
  }

  export type CiudadesWhereInput = {
    AND?: Enumerable<CiudadesWhereInput>
    OR?: Enumerable<CiudadesWhereInput>
    NOT?: Enumerable<CiudadesWhereInput>
    id_ciudad?: IntFilter | number
    nombre_ciudad?: StringFilter | string
    codigoPostal?: StringFilter | string
    id_departamento?: IntFilter | number
    Departamentos?: XOR<DepartamentosRelationFilter, DepartamentosWhereInput>
    Clientes?: ClientesListRelationFilter
    DireccionesEnvio?: DireccionesEnvioListRelationFilter
    Empleados?: EmpleadosListRelationFilter
    EmpresasEnvio?: EmpresasEnvioListRelationFilter
    Proveedores?: ProveedoresListRelationFilter
  }

  export type CiudadesOrderByWithRelationInput = {
    id_ciudad?: SortOrder
    nombre_ciudad?: SortOrder
    codigoPostal?: SortOrder
    id_departamento?: SortOrder
    Departamentos?: DepartamentosOrderByWithRelationInput
    Clientes?: ClientesOrderByRelationAggregateInput
    DireccionesEnvio?: DireccionesEnvioOrderByRelationAggregateInput
    Empleados?: EmpleadosOrderByRelationAggregateInput
    EmpresasEnvio?: EmpresasEnvioOrderByRelationAggregateInput
    Proveedores?: ProveedoresOrderByRelationAggregateInput
  }

  export type CiudadesWhereUniqueInput = {
    id_ciudad?: number
  }

  export type CiudadesOrderByWithAggregationInput = {
    id_ciudad?: SortOrder
    nombre_ciudad?: SortOrder
    codigoPostal?: SortOrder
    id_departamento?: SortOrder
    _count?: CiudadesCountOrderByAggregateInput
    _avg?: CiudadesAvgOrderByAggregateInput
    _max?: CiudadesMaxOrderByAggregateInput
    _min?: CiudadesMinOrderByAggregateInput
    _sum?: CiudadesSumOrderByAggregateInput
  }

  export type CiudadesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CiudadesScalarWhereWithAggregatesInput>
    OR?: Enumerable<CiudadesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CiudadesScalarWhereWithAggregatesInput>
    id_ciudad?: IntWithAggregatesFilter | number
    nombre_ciudad?: StringWithAggregatesFilter | string
    codigoPostal?: StringWithAggregatesFilter | string
    id_departamento?: IntWithAggregatesFilter | number
  }

  export type ClientesWhereInput = {
    AND?: Enumerable<ClientesWhereInput>
    OR?: Enumerable<ClientesWhereInput>
    NOT?: Enumerable<ClientesWhereInput>
    id_cliente?: IntFilter | number
    nom_cliente?: StringFilter | string
    apellido_cliente?: StringFilter | string
    RTN?: StringNullableFilter | string | null
    direccion_cliente?: StringFilter | string
    id_ciudad?: IntFilter | number
    tel_cliente?: StringFilter | string
    estado?: BoolFilter | boolean
    DNI_Cliente?: StringFilter | string
    Ciudades?: XOR<CiudadesRelationFilter, CiudadesWhereInput>
    usuariosClientes?: UsuariosClientesListRelationFilter
    Venta?: VentaListRelationFilter
  }

  export type ClientesOrderByWithRelationInput = {
    id_cliente?: SortOrder
    nom_cliente?: SortOrder
    apellido_cliente?: SortOrder
    RTN?: SortOrder
    direccion_cliente?: SortOrder
    id_ciudad?: SortOrder
    tel_cliente?: SortOrder
    estado?: SortOrder
    DNI_Cliente?: SortOrder
    Ciudades?: CiudadesOrderByWithRelationInput
    usuariosClientes?: usuariosClientesOrderByRelationAggregateInput
    Venta?: VentaOrderByRelationAggregateInput
  }

  export type ClientesWhereUniqueInput = {
    id_cliente?: number
  }

  export type ClientesOrderByWithAggregationInput = {
    id_cliente?: SortOrder
    nom_cliente?: SortOrder
    apellido_cliente?: SortOrder
    RTN?: SortOrder
    direccion_cliente?: SortOrder
    id_ciudad?: SortOrder
    tel_cliente?: SortOrder
    estado?: SortOrder
    DNI_Cliente?: SortOrder
    _count?: ClientesCountOrderByAggregateInput
    _avg?: ClientesAvgOrderByAggregateInput
    _max?: ClientesMaxOrderByAggregateInput
    _min?: ClientesMinOrderByAggregateInput
    _sum?: ClientesSumOrderByAggregateInput
  }

  export type ClientesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClientesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClientesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClientesScalarWhereWithAggregatesInput>
    id_cliente?: IntWithAggregatesFilter | number
    nom_cliente?: StringWithAggregatesFilter | string
    apellido_cliente?: StringWithAggregatesFilter | string
    RTN?: StringNullableWithAggregatesFilter | string | null
    direccion_cliente?: StringWithAggregatesFilter | string
    id_ciudad?: IntWithAggregatesFilter | number
    tel_cliente?: StringWithAggregatesFilter | string
    estado?: BoolWithAggregatesFilter | boolean
    DNI_Cliente?: StringWithAggregatesFilter | string
  }

  export type ComprasWhereInput = {
    AND?: Enumerable<ComprasWhereInput>
    OR?: Enumerable<ComprasWhereInput>
    NOT?: Enumerable<ComprasWhereInput>
    id_compra?: IntFilter | number
    fecha_compra?: DateTimeFilter | Date | string
    id_prov?: IntFilter | number
    id_empleado?: IntFilter | number
    isv?: FloatFilter | number
    descuento?: FloatFilter | number
    Empleados?: XOR<EmpleadosRelationFilter, EmpleadosWhereInput>
    Proveedores?: XOR<ProveedoresRelationFilter, ProveedoresWhereInput>
    DetalleCompras?: DetalleComprasListRelationFilter
  }

  export type ComprasOrderByWithRelationInput = {
    id_compra?: SortOrder
    fecha_compra?: SortOrder
    id_prov?: SortOrder
    id_empleado?: SortOrder
    isv?: SortOrder
    descuento?: SortOrder
    Empleados?: EmpleadosOrderByWithRelationInput
    Proveedores?: ProveedoresOrderByWithRelationInput
    DetalleCompras?: DetalleComprasOrderByRelationAggregateInput
  }

  export type ComprasWhereUniqueInput = {
    id_compra?: number
  }

  export type ComprasOrderByWithAggregationInput = {
    id_compra?: SortOrder
    fecha_compra?: SortOrder
    id_prov?: SortOrder
    id_empleado?: SortOrder
    isv?: SortOrder
    descuento?: SortOrder
    _count?: ComprasCountOrderByAggregateInput
    _avg?: ComprasAvgOrderByAggregateInput
    _max?: ComprasMaxOrderByAggregateInput
    _min?: ComprasMinOrderByAggregateInput
    _sum?: ComprasSumOrderByAggregateInput
  }

  export type ComprasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ComprasScalarWhereWithAggregatesInput>
    OR?: Enumerable<ComprasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ComprasScalarWhereWithAggregatesInput>
    id_compra?: IntWithAggregatesFilter | number
    fecha_compra?: DateTimeWithAggregatesFilter | Date | string
    id_prov?: IntWithAggregatesFilter | number
    id_empleado?: IntWithAggregatesFilter | number
    isv?: FloatWithAggregatesFilter | number
    descuento?: FloatWithAggregatesFilter | number
  }

  export type DepartamentosWhereInput = {
    AND?: Enumerable<DepartamentosWhereInput>
    OR?: Enumerable<DepartamentosWhereInput>
    NOT?: Enumerable<DepartamentosWhereInput>
    id_departamento?: IntFilter | number
    nombreDepartamento?: StringFilter | string
    Ciudades?: CiudadesListRelationFilter
  }

  export type DepartamentosOrderByWithRelationInput = {
    id_departamento?: SortOrder
    nombreDepartamento?: SortOrder
    Ciudades?: CiudadesOrderByRelationAggregateInput
  }

  export type DepartamentosWhereUniqueInput = {
    id_departamento?: number
  }

  export type DepartamentosOrderByWithAggregationInput = {
    id_departamento?: SortOrder
    nombreDepartamento?: SortOrder
    _count?: DepartamentosCountOrderByAggregateInput
    _avg?: DepartamentosAvgOrderByAggregateInput
    _max?: DepartamentosMaxOrderByAggregateInput
    _min?: DepartamentosMinOrderByAggregateInput
    _sum?: DepartamentosSumOrderByAggregateInput
  }

  export type DepartamentosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DepartamentosScalarWhereWithAggregatesInput>
    OR?: Enumerable<DepartamentosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DepartamentosScalarWhereWithAggregatesInput>
    id_departamento?: IntWithAggregatesFilter | number
    nombreDepartamento?: StringWithAggregatesFilter | string
  }

  export type DetalleComprasWhereInput = {
    AND?: Enumerable<DetalleComprasWhereInput>
    OR?: Enumerable<DetalleComprasWhereInput>
    NOT?: Enumerable<DetalleComprasWhereInput>
    id_detalleCompra?: IntFilter | number
    id_producto?: IntFilter | number
    id_compra?: IntFilter | number
    precio?: FloatFilter | number
    cantidad?: FloatFilter | number
    Compras?: XOR<ComprasRelationFilter, ComprasWhereInput>
    Productos?: XOR<ProductosRelationFilter, ProductosWhereInput>
  }

  export type DetalleComprasOrderByWithRelationInput = {
    id_detalleCompra?: SortOrder
    id_producto?: SortOrder
    id_compra?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    Compras?: ComprasOrderByWithRelationInput
    Productos?: ProductosOrderByWithRelationInput
  }

  export type DetalleComprasWhereUniqueInput = {
    id_detalleCompra?: number
  }

  export type DetalleComprasOrderByWithAggregationInput = {
    id_detalleCompra?: SortOrder
    id_producto?: SortOrder
    id_compra?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    _count?: DetalleComprasCountOrderByAggregateInput
    _avg?: DetalleComprasAvgOrderByAggregateInput
    _max?: DetalleComprasMaxOrderByAggregateInput
    _min?: DetalleComprasMinOrderByAggregateInput
    _sum?: DetalleComprasSumOrderByAggregateInput
  }

  export type DetalleComprasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DetalleComprasScalarWhereWithAggregatesInput>
    OR?: Enumerable<DetalleComprasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DetalleComprasScalarWhereWithAggregatesInput>
    id_detalleCompra?: IntWithAggregatesFilter | number
    id_producto?: IntWithAggregatesFilter | number
    id_compra?: IntWithAggregatesFilter | number
    precio?: FloatWithAggregatesFilter | number
    cantidad?: FloatWithAggregatesFilter | number
  }

  export type DetallesVentasWhereInput = {
    AND?: Enumerable<DetallesVentasWhereInput>
    OR?: Enumerable<DetallesVentasWhereInput>
    NOT?: Enumerable<DetallesVentasWhereInput>
    id_detalleVenta?: IntFilter | number
    id_producto?: IntFilter | number
    id_venta?: IntFilter | number
    precio?: FloatFilter | number
    cantidad?: FloatFilter | number
    Productos?: XOR<ProductosRelationFilter, ProductosWhereInput>
    Venta?: XOR<VentaRelationFilter, VentaWhereInput>
  }

  export type DetallesVentasOrderByWithRelationInput = {
    id_detalleVenta?: SortOrder
    id_producto?: SortOrder
    id_venta?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    Productos?: ProductosOrderByWithRelationInput
    Venta?: VentaOrderByWithRelationInput
  }

  export type DetallesVentasWhereUniqueInput = {
    id_detalleVenta?: number
  }

  export type DetallesVentasOrderByWithAggregationInput = {
    id_detalleVenta?: SortOrder
    id_producto?: SortOrder
    id_venta?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    _count?: DetallesVentasCountOrderByAggregateInput
    _avg?: DetallesVentasAvgOrderByAggregateInput
    _max?: DetallesVentasMaxOrderByAggregateInput
    _min?: DetallesVentasMinOrderByAggregateInput
    _sum?: DetallesVentasSumOrderByAggregateInput
  }

  export type DetallesVentasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DetallesVentasScalarWhereWithAggregatesInput>
    OR?: Enumerable<DetallesVentasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DetallesVentasScalarWhereWithAggregatesInput>
    id_detalleVenta?: IntWithAggregatesFilter | number
    id_producto?: IntWithAggregatesFilter | number
    id_venta?: IntWithAggregatesFilter | number
    precio?: FloatWithAggregatesFilter | number
    cantidad?: FloatWithAggregatesFilter | number
  }

  export type DireccionesEnvioWhereInput = {
    AND?: Enumerable<DireccionesEnvioWhereInput>
    OR?: Enumerable<DireccionesEnvioWhereInput>
    NOT?: Enumerable<DireccionesEnvioWhereInput>
    id_direccionEnvio?: IntFilter | number
    direccion?: StringFilter | string
    id_ciudad?: IntFilter | number
    id_usuarioCliente?: IntFilter | number
    direccion_opcional?: StringFilter | string
    Ciudades?: XOR<CiudadesRelationFilter, CiudadesWhereInput>
    usuariosClientes?: XOR<UsuariosClientesRelationFilter, usuariosClientesWhereInput>
    Venta?: VentaListRelationFilter
  }

  export type DireccionesEnvioOrderByWithRelationInput = {
    id_direccionEnvio?: SortOrder
    direccion?: SortOrder
    id_ciudad?: SortOrder
    id_usuarioCliente?: SortOrder
    direccion_opcional?: SortOrder
    Ciudades?: CiudadesOrderByWithRelationInput
    usuariosClientes?: usuariosClientesOrderByWithRelationInput
    Venta?: VentaOrderByRelationAggregateInput
  }

  export type DireccionesEnvioWhereUniqueInput = {
    id_direccionEnvio?: number
  }

  export type DireccionesEnvioOrderByWithAggregationInput = {
    id_direccionEnvio?: SortOrder
    direccion?: SortOrder
    id_ciudad?: SortOrder
    id_usuarioCliente?: SortOrder
    direccion_opcional?: SortOrder
    _count?: DireccionesEnvioCountOrderByAggregateInput
    _avg?: DireccionesEnvioAvgOrderByAggregateInput
    _max?: DireccionesEnvioMaxOrderByAggregateInput
    _min?: DireccionesEnvioMinOrderByAggregateInput
    _sum?: DireccionesEnvioSumOrderByAggregateInput
  }

  export type DireccionesEnvioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DireccionesEnvioScalarWhereWithAggregatesInput>
    OR?: Enumerable<DireccionesEnvioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DireccionesEnvioScalarWhereWithAggregatesInput>
    id_direccionEnvio?: IntWithAggregatesFilter | number
    direccion?: StringWithAggregatesFilter | string
    id_ciudad?: IntWithAggregatesFilter | number
    id_usuarioCliente?: IntWithAggregatesFilter | number
    direccion_opcional?: StringWithAggregatesFilter | string
  }

  export type EmpleadosWhereInput = {
    AND?: Enumerable<EmpleadosWhereInput>
    OR?: Enumerable<EmpleadosWhereInput>
    NOT?: Enumerable<EmpleadosWhereInput>
    id_empleado?: IntFilter | number
    nom_empleado?: StringFilter | string
    apellido_empleado?: StringFilter | string
    telefono_empleado?: StringFilter | string
    direccion_empleado?: StringFilter | string
    id_ciudad?: IntFilter | number
    id_rol?: IntFilter | number
    fnacimiento_empleado?: IntFilter | number
    Estado?: BoolFilter | boolean
    Ciudades?: XOR<CiudadesRelationFilter, CiudadesWhereInput>
    RolesEmpleados?: XOR<RolesEmpleadosRelationFilter, RolesEmpleadosWhereInput>
    Compras?: ComprasListRelationFilter
    UsuarioEmpleados?: UsuarioEmpleadosListRelationFilter
  }

  export type EmpleadosOrderByWithRelationInput = {
    id_empleado?: SortOrder
    nom_empleado?: SortOrder
    apellido_empleado?: SortOrder
    telefono_empleado?: SortOrder
    direccion_empleado?: SortOrder
    id_ciudad?: SortOrder
    id_rol?: SortOrder
    fnacimiento_empleado?: SortOrder
    Estado?: SortOrder
    Ciudades?: CiudadesOrderByWithRelationInput
    RolesEmpleados?: RolesEmpleadosOrderByWithRelationInput
    Compras?: ComprasOrderByRelationAggregateInput
    UsuarioEmpleados?: UsuarioEmpleadosOrderByRelationAggregateInput
  }

  export type EmpleadosWhereUniqueInput = {
    id_empleado?: number
  }

  export type EmpleadosOrderByWithAggregationInput = {
    id_empleado?: SortOrder
    nom_empleado?: SortOrder
    apellido_empleado?: SortOrder
    telefono_empleado?: SortOrder
    direccion_empleado?: SortOrder
    id_ciudad?: SortOrder
    id_rol?: SortOrder
    fnacimiento_empleado?: SortOrder
    Estado?: SortOrder
    _count?: EmpleadosCountOrderByAggregateInput
    _avg?: EmpleadosAvgOrderByAggregateInput
    _max?: EmpleadosMaxOrderByAggregateInput
    _min?: EmpleadosMinOrderByAggregateInput
    _sum?: EmpleadosSumOrderByAggregateInput
  }

  export type EmpleadosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EmpleadosScalarWhereWithAggregatesInput>
    OR?: Enumerable<EmpleadosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EmpleadosScalarWhereWithAggregatesInput>
    id_empleado?: IntWithAggregatesFilter | number
    nom_empleado?: StringWithAggregatesFilter | string
    apellido_empleado?: StringWithAggregatesFilter | string
    telefono_empleado?: StringWithAggregatesFilter | string
    direccion_empleado?: StringWithAggregatesFilter | string
    id_ciudad?: IntWithAggregatesFilter | number
    id_rol?: IntWithAggregatesFilter | number
    fnacimiento_empleado?: IntWithAggregatesFilter | number
    Estado?: BoolWithAggregatesFilter | boolean
  }

  export type EmpresasEnvioWhereInput = {
    AND?: Enumerable<EmpresasEnvioWhereInput>
    OR?: Enumerable<EmpresasEnvioWhereInput>
    NOT?: Enumerable<EmpresasEnvioWhereInput>
    id_empresaEnvio?: IntFilter | number
    nombre_empresa?: StringFilter | string
    direccion_empresa?: StringFilter | string
    telefono_empresa?: StringFilter | string
    id_ciudad?: IntFilter | number
    estado?: BoolFilter | boolean
    correo_empresa?: StringFilter | string
    Ciudades?: XOR<CiudadesRelationFilter, CiudadesWhereInput>
    Envios?: EnviosListRelationFilter
  }

  export type EmpresasEnvioOrderByWithRelationInput = {
    id_empresaEnvio?: SortOrder
    nombre_empresa?: SortOrder
    direccion_empresa?: SortOrder
    telefono_empresa?: SortOrder
    id_ciudad?: SortOrder
    estado?: SortOrder
    correo_empresa?: SortOrder
    Ciudades?: CiudadesOrderByWithRelationInput
    Envios?: EnviosOrderByRelationAggregateInput
  }

  export type EmpresasEnvioWhereUniqueInput = {
    id_empresaEnvio?: number
  }

  export type EmpresasEnvioOrderByWithAggregationInput = {
    id_empresaEnvio?: SortOrder
    nombre_empresa?: SortOrder
    direccion_empresa?: SortOrder
    telefono_empresa?: SortOrder
    id_ciudad?: SortOrder
    estado?: SortOrder
    correo_empresa?: SortOrder
    _count?: EmpresasEnvioCountOrderByAggregateInput
    _avg?: EmpresasEnvioAvgOrderByAggregateInput
    _max?: EmpresasEnvioMaxOrderByAggregateInput
    _min?: EmpresasEnvioMinOrderByAggregateInput
    _sum?: EmpresasEnvioSumOrderByAggregateInput
  }

  export type EmpresasEnvioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EmpresasEnvioScalarWhereWithAggregatesInput>
    OR?: Enumerable<EmpresasEnvioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EmpresasEnvioScalarWhereWithAggregatesInput>
    id_empresaEnvio?: IntWithAggregatesFilter | number
    nombre_empresa?: StringWithAggregatesFilter | string
    direccion_empresa?: StringWithAggregatesFilter | string
    telefono_empresa?: StringWithAggregatesFilter | string
    id_ciudad?: IntWithAggregatesFilter | number
    estado?: BoolWithAggregatesFilter | boolean
    correo_empresa?: StringWithAggregatesFilter | string
  }

  export type EnviosWhereInput = {
    AND?: Enumerable<EnviosWhereInput>
    OR?: Enumerable<EnviosWhereInput>
    NOT?: Enumerable<EnviosWhereInput>
    id_envio?: IntFilter | number
    num_rastreo?: StringFilter | string
    id_venta?: IntFilter | number
    id_empresaEnvio?: IntFilter | number
    EmpresasEnvio?: XOR<EmpresasEnvioRelationFilter, EmpresasEnvioWhereInput>
    Venta?: XOR<VentaRelationFilter, VentaWhereInput>
  }

  export type EnviosOrderByWithRelationInput = {
    id_envio?: SortOrder
    num_rastreo?: SortOrder
    id_venta?: SortOrder
    id_empresaEnvio?: SortOrder
    EmpresasEnvio?: EmpresasEnvioOrderByWithRelationInput
    Venta?: VentaOrderByWithRelationInput
  }

  export type EnviosWhereUniqueInput = {
    id_envio?: number
  }

  export type EnviosOrderByWithAggregationInput = {
    id_envio?: SortOrder
    num_rastreo?: SortOrder
    id_venta?: SortOrder
    id_empresaEnvio?: SortOrder
    _count?: EnviosCountOrderByAggregateInput
    _avg?: EnviosAvgOrderByAggregateInput
    _max?: EnviosMaxOrderByAggregateInput
    _min?: EnviosMinOrderByAggregateInput
    _sum?: EnviosSumOrderByAggregateInput
  }

  export type EnviosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EnviosScalarWhereWithAggregatesInput>
    OR?: Enumerable<EnviosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EnviosScalarWhereWithAggregatesInput>
    id_envio?: IntWithAggregatesFilter | number
    num_rastreo?: StringWithAggregatesFilter | string
    id_venta?: IntWithAggregatesFilter | number
    id_empresaEnvio?: IntWithAggregatesFilter | number
  }

  export type MarcasWhereInput = {
    AND?: Enumerable<MarcasWhereInput>
    OR?: Enumerable<MarcasWhereInput>
    NOT?: Enumerable<MarcasWhereInput>
    id_marca?: IntFilter | number
    descripcion_marca?: StringFilter | string
    estado?: BoolFilter | boolean
    Productos?: ProductosListRelationFilter
  }

  export type MarcasOrderByWithRelationInput = {
    id_marca?: SortOrder
    descripcion_marca?: SortOrder
    estado?: SortOrder
    Productos?: ProductosOrderByRelationAggregateInput
  }

  export type MarcasWhereUniqueInput = {
    id_marca?: number
  }

  export type MarcasOrderByWithAggregationInput = {
    id_marca?: SortOrder
    descripcion_marca?: SortOrder
    estado?: SortOrder
    _count?: MarcasCountOrderByAggregateInput
    _avg?: MarcasAvgOrderByAggregateInput
    _max?: MarcasMaxOrderByAggregateInput
    _min?: MarcasMinOrderByAggregateInput
    _sum?: MarcasSumOrderByAggregateInput
  }

  export type MarcasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarcasScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarcasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarcasScalarWhereWithAggregatesInput>
    id_marca?: IntWithAggregatesFilter | number
    descripcion_marca?: StringWithAggregatesFilter | string
    estado?: BoolWithAggregatesFilter | boolean
  }

  export type ProductosWhereInput = {
    AND?: Enumerable<ProductosWhereInput>
    OR?: Enumerable<ProductosWhereInput>
    NOT?: Enumerable<ProductosWhereInput>
    id_producto?: IntFilter | number
    descripcion_producto?: StringFilter | string
    id_marca?: IntFilter | number
    id_categoria?: IntFilter | number
    id_proveedor?: IntFilter | number
    cantidad_por_unidad?: StringFilter | string
    costo_producto?: FloatFilter | number
    precio_actual?: FloatFilter | number
    stock?: FloatFilter | number
    descuento?: FloatNullableFilter | number | null
    estado?: BoolFilter | boolean
    imagen?: StringNullableFilter | string | null
    Categorias?: XOR<CategoriasRelationFilter, CategoriasWhereInput>
    Marcas?: XOR<MarcasRelationFilter, MarcasWhereInput>
    Proveedores?: XOR<ProveedoresRelationFilter, ProveedoresWhereInput>
    CarritoItem?: CarritoItemListRelationFilter
    DetalleCompras?: DetalleComprasListRelationFilter
    DetallesVentas?: DetallesVentasListRelationFilter
  }

  export type ProductosOrderByWithRelationInput = {
    id_producto?: SortOrder
    descripcion_producto?: SortOrder
    id_marca?: SortOrder
    id_categoria?: SortOrder
    id_proveedor?: SortOrder
    cantidad_por_unidad?: SortOrder
    costo_producto?: SortOrder
    precio_actual?: SortOrder
    stock?: SortOrder
    descuento?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    Categorias?: CategoriasOrderByWithRelationInput
    Marcas?: MarcasOrderByWithRelationInput
    Proveedores?: ProveedoresOrderByWithRelationInput
    CarritoItem?: CarritoItemOrderByRelationAggregateInput
    DetalleCompras?: DetalleComprasOrderByRelationAggregateInput
    DetallesVentas?: DetallesVentasOrderByRelationAggregateInput
  }

  export type ProductosWhereUniqueInput = {
    id_producto?: number
  }

  export type ProductosOrderByWithAggregationInput = {
    id_producto?: SortOrder
    descripcion_producto?: SortOrder
    id_marca?: SortOrder
    id_categoria?: SortOrder
    id_proveedor?: SortOrder
    cantidad_por_unidad?: SortOrder
    costo_producto?: SortOrder
    precio_actual?: SortOrder
    stock?: SortOrder
    descuento?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    _count?: ProductosCountOrderByAggregateInput
    _avg?: ProductosAvgOrderByAggregateInput
    _max?: ProductosMaxOrderByAggregateInput
    _min?: ProductosMinOrderByAggregateInput
    _sum?: ProductosSumOrderByAggregateInput
  }

  export type ProductosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductosScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductosScalarWhereWithAggregatesInput>
    id_producto?: IntWithAggregatesFilter | number
    descripcion_producto?: StringWithAggregatesFilter | string
    id_marca?: IntWithAggregatesFilter | number
    id_categoria?: IntWithAggregatesFilter | number
    id_proveedor?: IntWithAggregatesFilter | number
    cantidad_por_unidad?: StringWithAggregatesFilter | string
    costo_producto?: FloatWithAggregatesFilter | number
    precio_actual?: FloatWithAggregatesFilter | number
    stock?: FloatWithAggregatesFilter | number
    descuento?: FloatNullableWithAggregatesFilter | number | null
    estado?: BoolWithAggregatesFilter | boolean
    imagen?: StringNullableWithAggregatesFilter | string | null
  }

  export type ProveedoresWhereInput = {
    AND?: Enumerable<ProveedoresWhereInput>
    OR?: Enumerable<ProveedoresWhereInput>
    NOT?: Enumerable<ProveedoresWhereInput>
    id_prov?: IntFilter | number
    nom_prov?: StringFilter | string
    telefono_prov?: StringFilter | string
    correo_prov?: StringFilter | string
    direccion_prov?: StringFilter | string
    id_ciudad?: IntFilter | number
    Estado?: BoolFilter | boolean
    Ciudades?: XOR<CiudadesRelationFilter, CiudadesWhereInput>
    Compras?: ComprasListRelationFilter
    Productos?: ProductosListRelationFilter
  }

  export type ProveedoresOrderByWithRelationInput = {
    id_prov?: SortOrder
    nom_prov?: SortOrder
    telefono_prov?: SortOrder
    correo_prov?: SortOrder
    direccion_prov?: SortOrder
    id_ciudad?: SortOrder
    Estado?: SortOrder
    Ciudades?: CiudadesOrderByWithRelationInput
    Compras?: ComprasOrderByRelationAggregateInput
    Productos?: ProductosOrderByRelationAggregateInput
  }

  export type ProveedoresWhereUniqueInput = {
    id_prov?: number
  }

  export type ProveedoresOrderByWithAggregationInput = {
    id_prov?: SortOrder
    nom_prov?: SortOrder
    telefono_prov?: SortOrder
    correo_prov?: SortOrder
    direccion_prov?: SortOrder
    id_ciudad?: SortOrder
    Estado?: SortOrder
    _count?: ProveedoresCountOrderByAggregateInput
    _avg?: ProveedoresAvgOrderByAggregateInput
    _max?: ProveedoresMaxOrderByAggregateInput
    _min?: ProveedoresMinOrderByAggregateInput
    _sum?: ProveedoresSumOrderByAggregateInput
  }

  export type ProveedoresScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProveedoresScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProveedoresScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProveedoresScalarWhereWithAggregatesInput>
    id_prov?: IntWithAggregatesFilter | number
    nom_prov?: StringWithAggregatesFilter | string
    telefono_prov?: StringWithAggregatesFilter | string
    correo_prov?: StringWithAggregatesFilter | string
    direccion_prov?: StringWithAggregatesFilter | string
    id_ciudad?: IntWithAggregatesFilter | number
    Estado?: BoolWithAggregatesFilter | boolean
  }

  export type RolesEmpleadosWhereInput = {
    AND?: Enumerable<RolesEmpleadosWhereInput>
    OR?: Enumerable<RolesEmpleadosWhereInput>
    NOT?: Enumerable<RolesEmpleadosWhereInput>
    id_rol?: IntFilter | number
    descripcion?: StringFilter | string
    Empleados?: EmpleadosListRelationFilter
  }

  export type RolesEmpleadosOrderByWithRelationInput = {
    id_rol?: SortOrder
    descripcion?: SortOrder
    Empleados?: EmpleadosOrderByRelationAggregateInput
  }

  export type RolesEmpleadosWhereUniqueInput = {
    id_rol?: number
  }

  export type RolesEmpleadosOrderByWithAggregationInput = {
    id_rol?: SortOrder
    descripcion?: SortOrder
    _count?: RolesEmpleadosCountOrderByAggregateInput
    _avg?: RolesEmpleadosAvgOrderByAggregateInput
    _max?: RolesEmpleadosMaxOrderByAggregateInput
    _min?: RolesEmpleadosMinOrderByAggregateInput
    _sum?: RolesEmpleadosSumOrderByAggregateInput
  }

  export type RolesEmpleadosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RolesEmpleadosScalarWhereWithAggregatesInput>
    OR?: Enumerable<RolesEmpleadosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RolesEmpleadosScalarWhereWithAggregatesInput>
    id_rol?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type sysdiagramsWhereInput = {
    AND?: Enumerable<sysdiagramsWhereInput>
    OR?: Enumerable<sysdiagramsWhereInput>
    NOT?: Enumerable<sysdiagramsWhereInput>
    name?: StringFilter | string
    principal_id?: IntFilter | number
    diagram_id?: IntFilter | number
    version?: IntNullableFilter | number | null
    definition?: BytesNullableFilter | Buffer | null
  }

  export type sysdiagramsOrderByWithRelationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsWhereUniqueInput = {
    diagram_id?: number
    principal_id_name?: sysdiagramsPrincipal_idNameCompoundUniqueInput
  }

  export type sysdiagramsOrderByWithAggregationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
    _count?: sysdiagramsCountOrderByAggregateInput
    _avg?: sysdiagramsAvgOrderByAggregateInput
    _max?: sysdiagramsMaxOrderByAggregateInput
    _min?: sysdiagramsMinOrderByAggregateInput
    _sum?: sysdiagramsSumOrderByAggregateInput
  }

  export type sysdiagramsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sysdiagramsScalarWhereWithAggregatesInput>
    OR?: Enumerable<sysdiagramsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sysdiagramsScalarWhereWithAggregatesInput>
    name?: StringWithAggregatesFilter | string
    principal_id?: IntWithAggregatesFilter | number
    diagram_id?: IntWithAggregatesFilter | number
    version?: IntNullableWithAggregatesFilter | number | null
    definition?: BytesNullableWithAggregatesFilter | Buffer | null
  }

  export type UsuarioEmpleadosWhereInput = {
    AND?: Enumerable<UsuarioEmpleadosWhereInput>
    OR?: Enumerable<UsuarioEmpleadosWhereInput>
    NOT?: Enumerable<UsuarioEmpleadosWhereInput>
    id_usuarioEmpleado?: IntFilter | number
    nom_usuarioEmpleado?: StringFilter | string
    estado?: BoolFilter | boolean
    contrasenia_empleado?: StringFilter | string
    correo_empleado?: StringFilter | string
    id_empleado?: IntFilter | number
    Empleados?: XOR<EmpleadosRelationFilter, EmpleadosWhereInput>
  }

  export type UsuarioEmpleadosOrderByWithRelationInput = {
    id_usuarioEmpleado?: SortOrder
    nom_usuarioEmpleado?: SortOrder
    estado?: SortOrder
    contrasenia_empleado?: SortOrder
    correo_empleado?: SortOrder
    id_empleado?: SortOrder
    Empleados?: EmpleadosOrderByWithRelationInput
  }

  export type UsuarioEmpleadosWhereUniqueInput = {
    id_usuarioEmpleado?: number
  }

  export type UsuarioEmpleadosOrderByWithAggregationInput = {
    id_usuarioEmpleado?: SortOrder
    nom_usuarioEmpleado?: SortOrder
    estado?: SortOrder
    contrasenia_empleado?: SortOrder
    correo_empleado?: SortOrder
    id_empleado?: SortOrder
    _count?: UsuarioEmpleadosCountOrderByAggregateInput
    _avg?: UsuarioEmpleadosAvgOrderByAggregateInput
    _max?: UsuarioEmpleadosMaxOrderByAggregateInput
    _min?: UsuarioEmpleadosMinOrderByAggregateInput
    _sum?: UsuarioEmpleadosSumOrderByAggregateInput
  }

  export type UsuarioEmpleadosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsuarioEmpleadosScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsuarioEmpleadosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsuarioEmpleadosScalarWhereWithAggregatesInput>
    id_usuarioEmpleado?: IntWithAggregatesFilter | number
    nom_usuarioEmpleado?: StringWithAggregatesFilter | string
    estado?: BoolWithAggregatesFilter | boolean
    contrasenia_empleado?: StringWithAggregatesFilter | string
    correo_empleado?: StringWithAggregatesFilter | string
    id_empleado?: IntWithAggregatesFilter | number
  }

  export type usuariosClientesWhereInput = {
    AND?: Enumerable<usuariosClientesWhereInput>
    OR?: Enumerable<usuariosClientesWhereInput>
    NOT?: Enumerable<usuariosClientesWhereInput>
    id_usuarioCliente?: IntFilter | number
    nombre_usuario?: StringFilter | string
    contraenia_usuario?: StringFilter | string
    id_cliente?: IntFilter | number
    correo_usuario?: StringFilter | string
    estado?: BoolFilter | boolean
    Clientes?: XOR<ClientesRelationFilter, ClientesWhereInput>
    Carrito?: CarritoListRelationFilter
    DireccionesEnvio?: DireccionesEnvioListRelationFilter
  }

  export type usuariosClientesOrderByWithRelationInput = {
    id_usuarioCliente?: SortOrder
    nombre_usuario?: SortOrder
    contraenia_usuario?: SortOrder
    id_cliente?: SortOrder
    correo_usuario?: SortOrder
    estado?: SortOrder
    Clientes?: ClientesOrderByWithRelationInput
    Carrito?: CarritoOrderByRelationAggregateInput
    DireccionesEnvio?: DireccionesEnvioOrderByRelationAggregateInput
  }

  export type usuariosClientesWhereUniqueInput = {
    id_usuarioCliente?: number
  }

  export type usuariosClientesOrderByWithAggregationInput = {
    id_usuarioCliente?: SortOrder
    nombre_usuario?: SortOrder
    contraenia_usuario?: SortOrder
    id_cliente?: SortOrder
    correo_usuario?: SortOrder
    estado?: SortOrder
    _count?: usuariosClientesCountOrderByAggregateInput
    _avg?: usuariosClientesAvgOrderByAggregateInput
    _max?: usuariosClientesMaxOrderByAggregateInput
    _min?: usuariosClientesMinOrderByAggregateInput
    _sum?: usuariosClientesSumOrderByAggregateInput
  }

  export type usuariosClientesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuariosClientesScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuariosClientesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuariosClientesScalarWhereWithAggregatesInput>
    id_usuarioCliente?: IntWithAggregatesFilter | number
    nombre_usuario?: StringWithAggregatesFilter | string
    contraenia_usuario?: StringWithAggregatesFilter | string
    id_cliente?: IntWithAggregatesFilter | number
    correo_usuario?: StringWithAggregatesFilter | string
    estado?: BoolWithAggregatesFilter | boolean
  }

  export type VentaWhereInput = {
    AND?: Enumerable<VentaWhereInput>
    OR?: Enumerable<VentaWhereInput>
    NOT?: Enumerable<VentaWhereInput>
    id_Venta?: IntFilter | number
    fecha?: DateTimeFilter | Date | string
    id_cliente?: IntFilter | number
    RTN_estado?: BoolFilter | boolean
    ISV?: FloatFilter | number
    id_direccionEnvio?: IntFilter | number
    descuento?: FloatFilter | number
    Clientes?: XOR<ClientesRelationFilter, ClientesWhereInput>
    DireccionesEnvio?: XOR<DireccionesEnvioRelationFilter, DireccionesEnvioWhereInput>
    DetallesVentas?: DetallesVentasListRelationFilter
    Envios?: EnviosListRelationFilter
  }

  export type VentaOrderByWithRelationInput = {
    id_Venta?: SortOrder
    fecha?: SortOrder
    id_cliente?: SortOrder
    RTN_estado?: SortOrder
    ISV?: SortOrder
    id_direccionEnvio?: SortOrder
    descuento?: SortOrder
    Clientes?: ClientesOrderByWithRelationInput
    DireccionesEnvio?: DireccionesEnvioOrderByWithRelationInput
    DetallesVentas?: DetallesVentasOrderByRelationAggregateInput
    Envios?: EnviosOrderByRelationAggregateInput
  }

  export type VentaWhereUniqueInput = {
    id_Venta?: number
  }

  export type VentaOrderByWithAggregationInput = {
    id_Venta?: SortOrder
    fecha?: SortOrder
    id_cliente?: SortOrder
    RTN_estado?: SortOrder
    ISV?: SortOrder
    id_direccionEnvio?: SortOrder
    descuento?: SortOrder
    _count?: VentaCountOrderByAggregateInput
    _avg?: VentaAvgOrderByAggregateInput
    _max?: VentaMaxOrderByAggregateInput
    _min?: VentaMinOrderByAggregateInput
    _sum?: VentaSumOrderByAggregateInput
  }

  export type VentaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VentaScalarWhereWithAggregatesInput>
    OR?: Enumerable<VentaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VentaScalarWhereWithAggregatesInput>
    id_Venta?: IntWithAggregatesFilter | number
    fecha?: DateTimeWithAggregatesFilter | Date | string
    id_cliente?: IntWithAggregatesFilter | number
    RTN_estado?: BoolWithAggregatesFilter | boolean
    ISV?: FloatWithAggregatesFilter | number
    id_direccionEnvio?: IntWithAggregatesFilter | number
    descuento?: FloatWithAggregatesFilter | number
  }

  export type CarritoWhereInput = {
    AND?: Enumerable<CarritoWhereInput>
    OR?: Enumerable<CarritoWhereInput>
    NOT?: Enumerable<CarritoWhereInput>
    id_carrito?: IntFilter | number
    id_usuarioCliente?: IntFilter | number
    usuariosClientes?: XOR<UsuariosClientesRelationFilter, usuariosClientesWhereInput>
    CarritoItem?: CarritoItemListRelationFilter
  }

  export type CarritoOrderByWithRelationInput = {
    id_carrito?: SortOrder
    id_usuarioCliente?: SortOrder
    usuariosClientes?: usuariosClientesOrderByWithRelationInput
    CarritoItem?: CarritoItemOrderByRelationAggregateInput
  }

  export type CarritoWhereUniqueInput = {
    id_carrito?: number
  }

  export type CarritoOrderByWithAggregationInput = {
    id_carrito?: SortOrder
    id_usuarioCliente?: SortOrder
    _count?: CarritoCountOrderByAggregateInput
    _avg?: CarritoAvgOrderByAggregateInput
    _max?: CarritoMaxOrderByAggregateInput
    _min?: CarritoMinOrderByAggregateInput
    _sum?: CarritoSumOrderByAggregateInput
  }

  export type CarritoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CarritoScalarWhereWithAggregatesInput>
    OR?: Enumerable<CarritoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CarritoScalarWhereWithAggregatesInput>
    id_carrito?: IntWithAggregatesFilter | number
    id_usuarioCliente?: IntWithAggregatesFilter | number
  }

  export type CarritoItemWhereInput = {
    AND?: Enumerable<CarritoItemWhereInput>
    OR?: Enumerable<CarritoItemWhereInput>
    NOT?: Enumerable<CarritoItemWhereInput>
    id_itemCarrito?: IntFilter | number
    id_Carrito?: IntFilter | number
    id_producto?: IntFilter | number
    cantidad?: IntFilter | number
    Carrito?: XOR<CarritoRelationFilter, CarritoWhereInput>
    Productos?: XOR<ProductosRelationFilter, ProductosWhereInput>
  }

  export type CarritoItemOrderByWithRelationInput = {
    id_itemCarrito?: SortOrder
    id_Carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    Carrito?: CarritoOrderByWithRelationInput
    Productos?: ProductosOrderByWithRelationInput
  }

  export type CarritoItemWhereUniqueInput = {
    id_itemCarrito?: number
  }

  export type CarritoItemOrderByWithAggregationInput = {
    id_itemCarrito?: SortOrder
    id_Carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    _count?: CarritoItemCountOrderByAggregateInput
    _avg?: CarritoItemAvgOrderByAggregateInput
    _max?: CarritoItemMaxOrderByAggregateInput
    _min?: CarritoItemMinOrderByAggregateInput
    _sum?: CarritoItemSumOrderByAggregateInput
  }

  export type CarritoItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CarritoItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<CarritoItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CarritoItemScalarWhereWithAggregatesInput>
    id_itemCarrito?: IntWithAggregatesFilter | number
    id_Carrito?: IntWithAggregatesFilter | number
    id_producto?: IntWithAggregatesFilter | number
    cantidad?: IntWithAggregatesFilter | number
  }

  export type CategoriasCreateInput = {
    descripcion_categoria: string
    estado: boolean
    Productos?: ProductosCreateNestedManyWithoutCategoriasInput
  }

  export type CategoriasUncheckedCreateInput = {
    id_categoria?: number
    descripcion_categoria: string
    estado: boolean
    Productos?: ProductosUncheckedCreateNestedManyWithoutCategoriasInput
  }

  export type CategoriasUpdateInput = {
    descripcion_categoria?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Productos?: ProductosUpdateManyWithoutCategoriasInput
  }

  export type CategoriasUncheckedUpdateInput = {
    id_categoria?: IntFieldUpdateOperationsInput | number
    descripcion_categoria?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Productos?: ProductosUncheckedUpdateManyWithoutCategoriasInput
  }

  export type CategoriasCreateManyInput = {
    descripcion_categoria: string
    estado: boolean
  }

  export type CategoriasUpdateManyMutationInput = {
    descripcion_categoria?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoriasUncheckedUpdateManyInput = {
    id_categoria?: IntFieldUpdateOperationsInput | number
    descripcion_categoria?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CiudadesCreateInput = {
    nombre_ciudad: string
    codigoPostal: string
    Departamentos: DepartamentosCreateNestedOneWithoutCiudadesInput
    Clientes?: ClientesCreateNestedManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedCreateInput = {
    id_ciudad?: number
    nombre_ciudad: string
    codigoPostal: string
    id_departamento: number
    Clientes?: ClientesUncheckedCreateNestedManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesUpdateInput = {
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    Departamentos?: DepartamentosUpdateOneRequiredWithoutCiudadesInput
    Clientes?: ClientesUpdateManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUpdateManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedUpdateInput = {
    id_ciudad?: IntFieldUpdateOperationsInput | number
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    id_departamento?: IntFieldUpdateOperationsInput | number
    Clientes?: ClientesUncheckedUpdateManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedUpdateManyWithoutCiudadesInput
  }

  export type CiudadesCreateManyInput = {
    nombre_ciudad: string
    codigoPostal: string
    id_departamento: number
  }

  export type CiudadesUpdateManyMutationInput = {
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
  }

  export type CiudadesUncheckedUpdateManyInput = {
    id_ciudad?: IntFieldUpdateOperationsInput | number
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    id_departamento?: IntFieldUpdateOperationsInput | number
  }

  export type ClientesCreateInput = {
    nom_cliente: string
    apellido_cliente: string
    RTN?: string | null
    direccion_cliente: string
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
    Ciudades: CiudadesCreateNestedOneWithoutClientesInput
    usuariosClientes?: usuariosClientesCreateNestedManyWithoutClientesInput
    Venta?: VentaCreateNestedManyWithoutClientesInput
  }

  export type ClientesUncheckedCreateInput = {
    id_cliente?: number
    nom_cliente: string
    apellido_cliente: string
    RTN?: string | null
    direccion_cliente: string
    id_ciudad: number
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
    usuariosClientes?: usuariosClientesUncheckedCreateNestedManyWithoutClientesInput
    Venta?: VentaUncheckedCreateNestedManyWithoutClientesInput
  }

  export type ClientesUpdateInput = {
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
    Ciudades?: CiudadesUpdateOneRequiredWithoutClientesInput
    usuariosClientes?: usuariosClientesUpdateManyWithoutClientesInput
    Venta?: VentaUpdateManyWithoutClientesInput
  }

  export type ClientesUncheckedUpdateInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
    usuariosClientes?: usuariosClientesUncheckedUpdateManyWithoutClientesInput
    Venta?: VentaUncheckedUpdateManyWithoutClientesInput
  }

  export type ClientesCreateManyInput = {
    nom_cliente: string
    apellido_cliente: string
    RTN?: string | null
    direccion_cliente: string
    id_ciudad: number
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
  }

  export type ClientesUpdateManyMutationInput = {
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
  }

  export type ClientesUncheckedUpdateManyInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
  }

  export type ComprasCreateInput = {
    fecha_compra: Date | string
    isv: number
    descuento: number
    Empleados: EmpleadosCreateNestedOneWithoutComprasInput
    Proveedores: ProveedoresCreateNestedOneWithoutComprasInput
    DetalleCompras?: DetalleComprasCreateNestedManyWithoutComprasInput
  }

  export type ComprasUncheckedCreateInput = {
    id_compra?: number
    fecha_compra: Date | string
    id_prov: number
    id_empleado: number
    isv: number
    descuento: number
    DetalleCompras?: DetalleComprasUncheckedCreateNestedManyWithoutComprasInput
  }

  export type ComprasUpdateInput = {
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    Empleados?: EmpleadosUpdateOneRequiredWithoutComprasInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutComprasInput
    DetalleCompras?: DetalleComprasUpdateManyWithoutComprasInput
  }

  export type ComprasUncheckedUpdateInput = {
    id_compra?: IntFieldUpdateOperationsInput | number
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    id_prov?: IntFieldUpdateOperationsInput | number
    id_empleado?: IntFieldUpdateOperationsInput | number
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    DetalleCompras?: DetalleComprasUncheckedUpdateManyWithoutComprasInput
  }

  export type ComprasCreateManyInput = {
    fecha_compra: Date | string
    id_prov: number
    id_empleado: number
    isv: number
    descuento: number
  }

  export type ComprasUpdateManyMutationInput = {
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
  }

  export type ComprasUncheckedUpdateManyInput = {
    id_compra?: IntFieldUpdateOperationsInput | number
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    id_prov?: IntFieldUpdateOperationsInput | number
    id_empleado?: IntFieldUpdateOperationsInput | number
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
  }

  export type DepartamentosCreateInput = {
    nombreDepartamento: string
    Ciudades?: CiudadesCreateNestedManyWithoutDepartamentosInput
  }

  export type DepartamentosUncheckedCreateInput = {
    id_departamento?: number
    nombreDepartamento: string
    Ciudades?: CiudadesUncheckedCreateNestedManyWithoutDepartamentosInput
  }

  export type DepartamentosUpdateInput = {
    nombreDepartamento?: StringFieldUpdateOperationsInput | string
    Ciudades?: CiudadesUpdateManyWithoutDepartamentosInput
  }

  export type DepartamentosUncheckedUpdateInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombreDepartamento?: StringFieldUpdateOperationsInput | string
    Ciudades?: CiudadesUncheckedUpdateManyWithoutDepartamentosInput
  }

  export type DepartamentosCreateManyInput = {
    nombreDepartamento: string
  }

  export type DepartamentosUpdateManyMutationInput = {
    nombreDepartamento?: StringFieldUpdateOperationsInput | string
  }

  export type DepartamentosUncheckedUpdateManyInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombreDepartamento?: StringFieldUpdateOperationsInput | string
  }

  export type DetalleComprasCreateInput = {
    precio: number
    cantidad: number
    Compras: ComprasCreateNestedOneWithoutDetalleComprasInput
    Productos: ProductosCreateNestedOneWithoutDetalleComprasInput
  }

  export type DetalleComprasUncheckedCreateInput = {
    id_detalleCompra?: number
    id_producto: number
    id_compra: number
    precio: number
    cantidad: number
  }

  export type DetalleComprasUpdateInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
    Compras?: ComprasUpdateOneRequiredWithoutDetalleComprasInput
    Productos?: ProductosUpdateOneRequiredWithoutDetalleComprasInput
  }

  export type DetalleComprasUncheckedUpdateInput = {
    id_detalleCompra?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    id_compra?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type DetalleComprasCreateManyInput = {
    id_producto: number
    id_compra: number
    precio: number
    cantidad: number
  }

  export type DetalleComprasUpdateManyMutationInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type DetalleComprasUncheckedUpdateManyInput = {
    id_detalleCompra?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    id_compra?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type DetallesVentasCreateInput = {
    precio: number
    cantidad: number
    Productos: ProductosCreateNestedOneWithoutDetallesVentasInput
    Venta: VentaCreateNestedOneWithoutDetallesVentasInput
  }

  export type DetallesVentasUncheckedCreateInput = {
    id_detalleVenta?: number
    id_producto: number
    id_venta: number
    precio: number
    cantidad: number
  }

  export type DetallesVentasUpdateInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
    Productos?: ProductosUpdateOneRequiredWithoutDetallesVentasInput
    Venta?: VentaUpdateOneRequiredWithoutDetallesVentasInput
  }

  export type DetallesVentasUncheckedUpdateInput = {
    id_detalleVenta?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    id_venta?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type DetallesVentasCreateManyInput = {
    id_producto: number
    id_venta: number
    precio: number
    cantidad: number
  }

  export type DetallesVentasUpdateManyMutationInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type DetallesVentasUncheckedUpdateManyInput = {
    id_detalleVenta?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    id_venta?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type DireccionesEnvioCreateInput = {
    direccion: string
    direccion_opcional: string
    Ciudades: CiudadesCreateNestedOneWithoutDireccionesEnvioInput
    usuariosClientes: usuariosClientesCreateNestedOneWithoutDireccionesEnvioInput
    Venta?: VentaCreateNestedManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioUncheckedCreateInput = {
    id_direccionEnvio?: number
    direccion: string
    id_ciudad: number
    id_usuarioCliente: number
    direccion_opcional: string
    Venta?: VentaUncheckedCreateNestedManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioUpdateInput = {
    direccion?: StringFieldUpdateOperationsInput | string
    direccion_opcional?: StringFieldUpdateOperationsInput | string
    Ciudades?: CiudadesUpdateOneRequiredWithoutDireccionesEnvioInput
    usuariosClientes?: usuariosClientesUpdateOneRequiredWithoutDireccionesEnvioInput
    Venta?: VentaUpdateManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioUncheckedUpdateInput = {
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    direccion?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    direccion_opcional?: StringFieldUpdateOperationsInput | string
    Venta?: VentaUncheckedUpdateManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioCreateManyInput = {
    direccion: string
    id_ciudad: number
    id_usuarioCliente: number
    direccion_opcional: string
  }

  export type DireccionesEnvioUpdateManyMutationInput = {
    direccion?: StringFieldUpdateOperationsInput | string
    direccion_opcional?: StringFieldUpdateOperationsInput | string
  }

  export type DireccionesEnvioUncheckedUpdateManyInput = {
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    direccion?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    direccion_opcional?: StringFieldUpdateOperationsInput | string
  }

  export type EmpleadosCreateInput = {
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    fnacimiento_empleado: number
    Estado: boolean
    Ciudades: CiudadesCreateNestedOneWithoutEmpleadosInput
    RolesEmpleados: RolesEmpleadosCreateNestedOneWithoutEmpleadosInput
    Compras?: ComprasCreateNestedManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosCreateNestedManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedCreateInput = {
    id_empleado?: number
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    id_ciudad: number
    id_rol: number
    fnacimiento_empleado: number
    Estado: boolean
    Compras?: ComprasUncheckedCreateNestedManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosUncheckedCreateNestedManyWithoutEmpleadosInput
  }

  export type EmpleadosUpdateInput = {
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Ciudades?: CiudadesUpdateOneRequiredWithoutEmpleadosInput
    RolesEmpleados?: RolesEmpleadosUpdateOneRequiredWithoutEmpleadosInput
    Compras?: ComprasUpdateManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosUpdateManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedUpdateInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    id_rol?: IntFieldUpdateOperationsInput | number
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUncheckedUpdateManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosUncheckedUpdateManyWithoutEmpleadosInput
  }

  export type EmpleadosCreateManyInput = {
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    id_ciudad: number
    id_rol: number
    fnacimiento_empleado: number
    Estado: boolean
  }

  export type EmpleadosUpdateManyMutationInput = {
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmpleadosUncheckedUpdateManyInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    id_rol?: IntFieldUpdateOperationsInput | number
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmpresasEnvioCreateInput = {
    nombre_empresa: string
    direccion_empresa: string
    telefono_empresa: string
    estado: boolean
    correo_empresa: string
    Ciudades: CiudadesCreateNestedOneWithoutEmpresasEnvioInput
    Envios?: EnviosCreateNestedManyWithoutEmpresasEnvioInput
  }

  export type EmpresasEnvioUncheckedCreateInput = {
    id_empresaEnvio?: number
    nombre_empresa: string
    direccion_empresa: string
    telefono_empresa: string
    id_ciudad: number
    estado: boolean
    correo_empresa: string
    Envios?: EnviosUncheckedCreateNestedManyWithoutEmpresasEnvioInput
  }

  export type EmpresasEnvioUpdateInput = {
    nombre_empresa?: StringFieldUpdateOperationsInput | string
    direccion_empresa?: StringFieldUpdateOperationsInput | string
    telefono_empresa?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    correo_empresa?: StringFieldUpdateOperationsInput | string
    Ciudades?: CiudadesUpdateOneRequiredWithoutEmpresasEnvioInput
    Envios?: EnviosUpdateManyWithoutEmpresasEnvioInput
  }

  export type EmpresasEnvioUncheckedUpdateInput = {
    id_empresaEnvio?: IntFieldUpdateOperationsInput | number
    nombre_empresa?: StringFieldUpdateOperationsInput | string
    direccion_empresa?: StringFieldUpdateOperationsInput | string
    telefono_empresa?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    correo_empresa?: StringFieldUpdateOperationsInput | string
    Envios?: EnviosUncheckedUpdateManyWithoutEmpresasEnvioInput
  }

  export type EmpresasEnvioCreateManyInput = {
    nombre_empresa: string
    direccion_empresa: string
    telefono_empresa: string
    id_ciudad: number
    estado: boolean
    correo_empresa: string
  }

  export type EmpresasEnvioUpdateManyMutationInput = {
    nombre_empresa?: StringFieldUpdateOperationsInput | string
    direccion_empresa?: StringFieldUpdateOperationsInput | string
    telefono_empresa?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    correo_empresa?: StringFieldUpdateOperationsInput | string
  }

  export type EmpresasEnvioUncheckedUpdateManyInput = {
    id_empresaEnvio?: IntFieldUpdateOperationsInput | number
    nombre_empresa?: StringFieldUpdateOperationsInput | string
    direccion_empresa?: StringFieldUpdateOperationsInput | string
    telefono_empresa?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    correo_empresa?: StringFieldUpdateOperationsInput | string
  }

  export type EnviosCreateInput = {
    num_rastreo: string
    EmpresasEnvio: EmpresasEnvioCreateNestedOneWithoutEnviosInput
    Venta: VentaCreateNestedOneWithoutEnviosInput
  }

  export type EnviosUncheckedCreateInput = {
    id_envio?: number
    num_rastreo: string
    id_venta: number
    id_empresaEnvio: number
  }

  export type EnviosUpdateInput = {
    num_rastreo?: StringFieldUpdateOperationsInput | string
    EmpresasEnvio?: EmpresasEnvioUpdateOneRequiredWithoutEnviosInput
    Venta?: VentaUpdateOneRequiredWithoutEnviosInput
  }

  export type EnviosUncheckedUpdateInput = {
    id_envio?: IntFieldUpdateOperationsInput | number
    num_rastreo?: StringFieldUpdateOperationsInput | string
    id_venta?: IntFieldUpdateOperationsInput | number
    id_empresaEnvio?: IntFieldUpdateOperationsInput | number
  }

  export type EnviosCreateManyInput = {
    num_rastreo: string
    id_venta: number
    id_empresaEnvio: number
  }

  export type EnviosUpdateManyMutationInput = {
    num_rastreo?: StringFieldUpdateOperationsInput | string
  }

  export type EnviosUncheckedUpdateManyInput = {
    id_envio?: IntFieldUpdateOperationsInput | number
    num_rastreo?: StringFieldUpdateOperationsInput | string
    id_venta?: IntFieldUpdateOperationsInput | number
    id_empresaEnvio?: IntFieldUpdateOperationsInput | number
  }

  export type MarcasCreateInput = {
    descripcion_marca: string
    estado: boolean
    Productos?: ProductosCreateNestedManyWithoutMarcasInput
  }

  export type MarcasUncheckedCreateInput = {
    id_marca?: number
    descripcion_marca: string
    estado: boolean
    Productos?: ProductosUncheckedCreateNestedManyWithoutMarcasInput
  }

  export type MarcasUpdateInput = {
    descripcion_marca?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Productos?: ProductosUpdateManyWithoutMarcasInput
  }

  export type MarcasUncheckedUpdateInput = {
    id_marca?: IntFieldUpdateOperationsInput | number
    descripcion_marca?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Productos?: ProductosUncheckedUpdateManyWithoutMarcasInput
  }

  export type MarcasCreateManyInput = {
    descripcion_marca: string
    estado: boolean
  }

  export type MarcasUpdateManyMutationInput = {
    descripcion_marca?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MarcasUncheckedUpdateManyInput = {
    id_marca?: IntFieldUpdateOperationsInput | number
    descripcion_marca?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductosCreateInput = {
    descripcion_producto: string
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    Categorias: CategoriasCreateNestedOneWithoutProductosInput
    Marcas: MarcasCreateNestedOneWithoutProductosInput
    Proveedores: ProveedoresCreateNestedOneWithoutProductosInput
    CarritoItem?: CarritoItemCreateNestedManyWithoutProductosInput
    DetalleCompras?: DetalleComprasCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateInput = {
    id_producto?: number
    descripcion_producto: string
    id_marca: number
    id_categoria: number
    id_proveedor: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    CarritoItem?: CarritoItemUncheckedCreateNestedManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUncheckedCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosUpdateInput = {
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    Categorias?: CategoriasUpdateOneRequiredWithoutProductosInput
    Marcas?: MarcasUpdateOneRequiredWithoutProductosInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutProductosInput
    CarritoItem?: CarritoItemUpdateManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUpdateManyWithoutProductosInput
  }

  export type ProductosUncheckedUpdateInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    id_marca?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_proveedor?: IntFieldUpdateOperationsInput | number
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    CarritoItem?: CarritoItemUncheckedUpdateManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUncheckedUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedUpdateManyWithoutProductosInput
  }

  export type ProductosCreateManyInput = {
    descripcion_producto: string
    id_marca: number
    id_categoria: number
    id_proveedor: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
  }

  export type ProductosUpdateManyMutationInput = {
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductosUncheckedUpdateManyInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    id_marca?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_proveedor?: IntFieldUpdateOperationsInput | number
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProveedoresCreateInput = {
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    Estado: boolean
    Ciudades: CiudadesCreateNestedOneWithoutProveedoresInput
    Compras?: ComprasCreateNestedManyWithoutProveedoresInput
    Productos?: ProductosCreateNestedManyWithoutProveedoresInput
  }

  export type ProveedoresUncheckedCreateInput = {
    id_prov?: number
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    id_ciudad: number
    Estado: boolean
    Compras?: ComprasUncheckedCreateNestedManyWithoutProveedoresInput
    Productos?: ProductosUncheckedCreateNestedManyWithoutProveedoresInput
  }

  export type ProveedoresUpdateInput = {
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Ciudades?: CiudadesUpdateOneRequiredWithoutProveedoresInput
    Compras?: ComprasUpdateManyWithoutProveedoresInput
    Productos?: ProductosUpdateManyWithoutProveedoresInput
  }

  export type ProveedoresUncheckedUpdateInput = {
    id_prov?: IntFieldUpdateOperationsInput | number
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUncheckedUpdateManyWithoutProveedoresInput
    Productos?: ProductosUncheckedUpdateManyWithoutProveedoresInput
  }

  export type ProveedoresCreateManyInput = {
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    id_ciudad: number
    Estado: boolean
  }

  export type ProveedoresUpdateManyMutationInput = {
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    Estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProveedoresUncheckedUpdateManyInput = {
    id_prov?: IntFieldUpdateOperationsInput | number
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolesEmpleadosCreateInput = {
    descripcion: string
    Empleados?: EmpleadosCreateNestedManyWithoutRolesEmpleadosInput
  }

  export type RolesEmpleadosUncheckedCreateInput = {
    id_rol?: number
    descripcion: string
    Empleados?: EmpleadosUncheckedCreateNestedManyWithoutRolesEmpleadosInput
  }

  export type RolesEmpleadosUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    Empleados?: EmpleadosUpdateManyWithoutRolesEmpleadosInput
  }

  export type RolesEmpleadosUncheckedUpdateInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    Empleados?: EmpleadosUncheckedUpdateManyWithoutRolesEmpleadosInput
  }

  export type RolesEmpleadosCreateManyInput = {
    descripcion: string
  }

  export type RolesEmpleadosUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type RolesEmpleadosUncheckedUpdateManyInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type sysdiagramsCreateInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Buffer | null
  }

  export type sysdiagramsUncheckedCreateInput = {
    name: string
    principal_id: number
    diagram_id?: number
    version?: number | null
    definition?: Buffer | null
  }

  export type sysdiagramsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type sysdiagramsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type sysdiagramsCreateManyInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Buffer | null
  }

  export type sysdiagramsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type sysdiagramsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type UsuarioEmpleadosCreateInput = {
    nom_usuarioEmpleado: string
    estado: boolean
    contrasenia_empleado: string
    correo_empleado: string
    Empleados: EmpleadosCreateNestedOneWithoutUsuarioEmpleadosInput
  }

  export type UsuarioEmpleadosUncheckedCreateInput = {
    id_usuarioEmpleado?: number
    nom_usuarioEmpleado: string
    estado: boolean
    contrasenia_empleado: string
    correo_empleado: string
    id_empleado: number
  }

  export type UsuarioEmpleadosUpdateInput = {
    nom_usuarioEmpleado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    contrasenia_empleado?: StringFieldUpdateOperationsInput | string
    correo_empleado?: StringFieldUpdateOperationsInput | string
    Empleados?: EmpleadosUpdateOneRequiredWithoutUsuarioEmpleadosInput
  }

  export type UsuarioEmpleadosUncheckedUpdateInput = {
    id_usuarioEmpleado?: IntFieldUpdateOperationsInput | number
    nom_usuarioEmpleado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    contrasenia_empleado?: StringFieldUpdateOperationsInput | string
    correo_empleado?: StringFieldUpdateOperationsInput | string
    id_empleado?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioEmpleadosCreateManyInput = {
    nom_usuarioEmpleado: string
    estado: boolean
    contrasenia_empleado: string
    correo_empleado: string
    id_empleado: number
  }

  export type UsuarioEmpleadosUpdateManyMutationInput = {
    nom_usuarioEmpleado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    contrasenia_empleado?: StringFieldUpdateOperationsInput | string
    correo_empleado?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioEmpleadosUncheckedUpdateManyInput = {
    id_usuarioEmpleado?: IntFieldUpdateOperationsInput | number
    nom_usuarioEmpleado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    contrasenia_empleado?: StringFieldUpdateOperationsInput | string
    correo_empleado?: StringFieldUpdateOperationsInput | string
    id_empleado?: IntFieldUpdateOperationsInput | number
  }

  export type usuariosClientesCreateInput = {
    nombre_usuario: string
    contraenia_usuario: string
    correo_usuario: string
    estado: boolean
    Clientes: ClientesCreateNestedOneWithoutUsuariosClientesInput
    Carrito?: CarritoCreateNestedManyWithoutUsuariosClientesInput
    DireccionesEnvio?: DireccionesEnvioCreateNestedManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesUncheckedCreateInput = {
    id_usuarioCliente?: number
    nombre_usuario: string
    contraenia_usuario: string
    id_cliente: number
    correo_usuario: string
    estado: boolean
    Carrito?: CarritoUncheckedCreateNestedManyWithoutUsuariosClientesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedCreateNestedManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesUpdateInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Clientes?: ClientesUpdateOneRequiredWithoutUsuariosClientesInput
    Carrito?: CarritoUpdateManyWithoutUsuariosClientesInput
    DireccionesEnvio?: DireccionesEnvioUpdateManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesUncheckedUpdateInput = {
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Carrito?: CarritoUncheckedUpdateManyWithoutUsuariosClientesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedUpdateManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesCreateManyInput = {
    nombre_usuario: string
    contraenia_usuario: string
    id_cliente: number
    correo_usuario: string
    estado: boolean
  }

  export type usuariosClientesUpdateManyMutationInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usuariosClientesUncheckedUpdateManyInput = {
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VentaCreateInput = {
    fecha: Date | string
    RTN_estado: boolean
    ISV: number
    descuento: number
    Clientes: ClientesCreateNestedOneWithoutVentaInput
    DireccionesEnvio: DireccionesEnvioCreateNestedOneWithoutVentaInput
    DetallesVentas?: DetallesVentasCreateNestedManyWithoutVentaInput
    Envios?: EnviosCreateNestedManyWithoutVentaInput
  }

  export type VentaUncheckedCreateInput = {
    id_Venta?: number
    fecha: Date | string
    id_cliente: number
    RTN_estado: boolean
    ISV: number
    id_direccionEnvio: number
    descuento: number
    DetallesVentas?: DetallesVentasUncheckedCreateNestedManyWithoutVentaInput
    Envios?: EnviosUncheckedCreateNestedManyWithoutVentaInput
  }

  export type VentaUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    Clientes?: ClientesUpdateOneRequiredWithoutVentaInput
    DireccionesEnvio?: DireccionesEnvioUpdateOneRequiredWithoutVentaInput
    DetallesVentas?: DetallesVentasUpdateManyWithoutVentaInput
    Envios?: EnviosUpdateManyWithoutVentaInput
  }

  export type VentaUncheckedUpdateInput = {
    id_Venta?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    DetallesVentas?: DetallesVentasUncheckedUpdateManyWithoutVentaInput
    Envios?: EnviosUncheckedUpdateManyWithoutVentaInput
  }

  export type VentaCreateManyInput = {
    fecha: Date | string
    id_cliente: number
    RTN_estado: boolean
    ISV: number
    id_direccionEnvio: number
    descuento: number
  }

  export type VentaUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
  }

  export type VentaUncheckedUpdateManyInput = {
    id_Venta?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
  }

  export type CarritoCreateInput = {
    usuariosClientes: usuariosClientesCreateNestedOneWithoutCarritoInput
    CarritoItem?: CarritoItemCreateNestedManyWithoutCarritoInput
  }

  export type CarritoUncheckedCreateInput = {
    id_carrito?: number
    id_usuarioCliente: number
    CarritoItem?: CarritoItemUncheckedCreateNestedManyWithoutCarritoInput
  }

  export type CarritoUpdateInput = {
    usuariosClientes?: usuariosClientesUpdateOneRequiredWithoutCarritoInput
    CarritoItem?: CarritoItemUpdateManyWithoutCarritoInput
  }

  export type CarritoUncheckedUpdateInput = {
    id_carrito?: IntFieldUpdateOperationsInput | number
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    CarritoItem?: CarritoItemUncheckedUpdateManyWithoutCarritoInput
  }

  export type CarritoCreateManyInput = {
    id_usuarioCliente: number
  }

  export type CarritoUpdateManyMutationInput = {

  }

  export type CarritoUncheckedUpdateManyInput = {
    id_carrito?: IntFieldUpdateOperationsInput | number
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
  }

  export type CarritoItemCreateInput = {
    cantidad: number
    Carrito: CarritoCreateNestedOneWithoutCarritoItemInput
    Productos: ProductosCreateNestedOneWithoutCarritoItemInput
  }

  export type CarritoItemUncheckedCreateInput = {
    id_itemCarrito?: number
    id_Carrito: number
    id_producto: number
    cantidad: number
  }

  export type CarritoItemUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    Carrito?: CarritoUpdateOneRequiredWithoutCarritoItemInput
    Productos?: ProductosUpdateOneRequiredWithoutCarritoItemInput
  }

  export type CarritoItemUncheckedUpdateInput = {
    id_itemCarrito?: IntFieldUpdateOperationsInput | number
    id_Carrito?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type CarritoItemCreateManyInput = {
    id_Carrito: number
    id_producto: number
    cantidad: number
  }

  export type CarritoItemUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type CarritoItemUncheckedUpdateManyInput = {
    id_itemCarrito?: IntFieldUpdateOperationsInput | number
    id_Carrito?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ProductosListRelationFilter = {
    every?: ProductosWhereInput
    some?: ProductosWhereInput
    none?: ProductosWhereInput
  }

  export type ProductosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriasCountOrderByAggregateInput = {
    id_categoria?: SortOrder
    descripcion_categoria?: SortOrder
    estado?: SortOrder
  }

  export type CategoriasAvgOrderByAggregateInput = {
    id_categoria?: SortOrder
  }

  export type CategoriasMaxOrderByAggregateInput = {
    id_categoria?: SortOrder
    descripcion_categoria?: SortOrder
    estado?: SortOrder
  }

  export type CategoriasMinOrderByAggregateInput = {
    id_categoria?: SortOrder
    descripcion_categoria?: SortOrder
    estado?: SortOrder
  }

  export type CategoriasSumOrderByAggregateInput = {
    id_categoria?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DepartamentosRelationFilter = {
    is?: DepartamentosWhereInput
    isNot?: DepartamentosWhereInput
  }

  export type ClientesListRelationFilter = {
    every?: ClientesWhereInput
    some?: ClientesWhereInput
    none?: ClientesWhereInput
  }

  export type DireccionesEnvioListRelationFilter = {
    every?: DireccionesEnvioWhereInput
    some?: DireccionesEnvioWhereInput
    none?: DireccionesEnvioWhereInput
  }

  export type EmpleadosListRelationFilter = {
    every?: EmpleadosWhereInput
    some?: EmpleadosWhereInput
    none?: EmpleadosWhereInput
  }

  export type EmpresasEnvioListRelationFilter = {
    every?: EmpresasEnvioWhereInput
    some?: EmpresasEnvioWhereInput
    none?: EmpresasEnvioWhereInput
  }

  export type ProveedoresListRelationFilter = {
    every?: ProveedoresWhereInput
    some?: ProveedoresWhereInput
    none?: ProveedoresWhereInput
  }

  export type ClientesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DireccionesEnvioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpleadosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresasEnvioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProveedoresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CiudadesCountOrderByAggregateInput = {
    id_ciudad?: SortOrder
    nombre_ciudad?: SortOrder
    codigoPostal?: SortOrder
    id_departamento?: SortOrder
  }

  export type CiudadesAvgOrderByAggregateInput = {
    id_ciudad?: SortOrder
    id_departamento?: SortOrder
  }

  export type CiudadesMaxOrderByAggregateInput = {
    id_ciudad?: SortOrder
    nombre_ciudad?: SortOrder
    codigoPostal?: SortOrder
    id_departamento?: SortOrder
  }

  export type CiudadesMinOrderByAggregateInput = {
    id_ciudad?: SortOrder
    nombre_ciudad?: SortOrder
    codigoPostal?: SortOrder
    id_departamento?: SortOrder
  }

  export type CiudadesSumOrderByAggregateInput = {
    id_ciudad?: SortOrder
    id_departamento?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type CiudadesRelationFilter = {
    is?: CiudadesWhereInput
    isNot?: CiudadesWhereInput
  }

  export type UsuariosClientesListRelationFilter = {
    every?: usuariosClientesWhereInput
    some?: usuariosClientesWhereInput
    none?: usuariosClientesWhereInput
  }

  export type VentaListRelationFilter = {
    every?: VentaWhereInput
    some?: VentaWhereInput
    none?: VentaWhereInput
  }

  export type usuariosClientesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VentaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientesCountOrderByAggregateInput = {
    id_cliente?: SortOrder
    nom_cliente?: SortOrder
    apellido_cliente?: SortOrder
    RTN?: SortOrder
    direccion_cliente?: SortOrder
    id_ciudad?: SortOrder
    tel_cliente?: SortOrder
    estado?: SortOrder
    DNI_Cliente?: SortOrder
  }

  export type ClientesAvgOrderByAggregateInput = {
    id_cliente?: SortOrder
    id_ciudad?: SortOrder
  }

  export type ClientesMaxOrderByAggregateInput = {
    id_cliente?: SortOrder
    nom_cliente?: SortOrder
    apellido_cliente?: SortOrder
    RTN?: SortOrder
    direccion_cliente?: SortOrder
    id_ciudad?: SortOrder
    tel_cliente?: SortOrder
    estado?: SortOrder
    DNI_Cliente?: SortOrder
  }

  export type ClientesMinOrderByAggregateInput = {
    id_cliente?: SortOrder
    nom_cliente?: SortOrder
    apellido_cliente?: SortOrder
    RTN?: SortOrder
    direccion_cliente?: SortOrder
    id_ciudad?: SortOrder
    tel_cliente?: SortOrder
    estado?: SortOrder
    DNI_Cliente?: SortOrder
  }

  export type ClientesSumOrderByAggregateInput = {
    id_cliente?: SortOrder
    id_ciudad?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type EmpleadosRelationFilter = {
    is?: EmpleadosWhereInput
    isNot?: EmpleadosWhereInput
  }

  export type ProveedoresRelationFilter = {
    is?: ProveedoresWhereInput
    isNot?: ProveedoresWhereInput
  }

  export type DetalleComprasListRelationFilter = {
    every?: DetalleComprasWhereInput
    some?: DetalleComprasWhereInput
    none?: DetalleComprasWhereInput
  }

  export type DetalleComprasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComprasCountOrderByAggregateInput = {
    id_compra?: SortOrder
    fecha_compra?: SortOrder
    id_prov?: SortOrder
    id_empleado?: SortOrder
    isv?: SortOrder
    descuento?: SortOrder
  }

  export type ComprasAvgOrderByAggregateInput = {
    id_compra?: SortOrder
    id_prov?: SortOrder
    id_empleado?: SortOrder
    isv?: SortOrder
    descuento?: SortOrder
  }

  export type ComprasMaxOrderByAggregateInput = {
    id_compra?: SortOrder
    fecha_compra?: SortOrder
    id_prov?: SortOrder
    id_empleado?: SortOrder
    isv?: SortOrder
    descuento?: SortOrder
  }

  export type ComprasMinOrderByAggregateInput = {
    id_compra?: SortOrder
    fecha_compra?: SortOrder
    id_prov?: SortOrder
    id_empleado?: SortOrder
    isv?: SortOrder
    descuento?: SortOrder
  }

  export type ComprasSumOrderByAggregateInput = {
    id_compra?: SortOrder
    id_prov?: SortOrder
    id_empleado?: SortOrder
    isv?: SortOrder
    descuento?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type CiudadesListRelationFilter = {
    every?: CiudadesWhereInput
    some?: CiudadesWhereInput
    none?: CiudadesWhereInput
  }

  export type CiudadesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartamentosCountOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombreDepartamento?: SortOrder
  }

  export type DepartamentosAvgOrderByAggregateInput = {
    id_departamento?: SortOrder
  }

  export type DepartamentosMaxOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombreDepartamento?: SortOrder
  }

  export type DepartamentosMinOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombreDepartamento?: SortOrder
  }

  export type DepartamentosSumOrderByAggregateInput = {
    id_departamento?: SortOrder
  }

  export type ComprasRelationFilter = {
    is?: ComprasWhereInput
    isNot?: ComprasWhereInput
  }

  export type ProductosRelationFilter = {
    is?: ProductosWhereInput
    isNot?: ProductosWhereInput
  }

  export type DetalleComprasCountOrderByAggregateInput = {
    id_detalleCompra?: SortOrder
    id_producto?: SortOrder
    id_compra?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleComprasAvgOrderByAggregateInput = {
    id_detalleCompra?: SortOrder
    id_producto?: SortOrder
    id_compra?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleComprasMaxOrderByAggregateInput = {
    id_detalleCompra?: SortOrder
    id_producto?: SortOrder
    id_compra?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleComprasMinOrderByAggregateInput = {
    id_detalleCompra?: SortOrder
    id_producto?: SortOrder
    id_compra?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleComprasSumOrderByAggregateInput = {
    id_detalleCompra?: SortOrder
    id_producto?: SortOrder
    id_compra?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
  }

  export type VentaRelationFilter = {
    is?: VentaWhereInput
    isNot?: VentaWhereInput
  }

  export type DetallesVentasCountOrderByAggregateInput = {
    id_detalleVenta?: SortOrder
    id_producto?: SortOrder
    id_venta?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
  }

  export type DetallesVentasAvgOrderByAggregateInput = {
    id_detalleVenta?: SortOrder
    id_producto?: SortOrder
    id_venta?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
  }

  export type DetallesVentasMaxOrderByAggregateInput = {
    id_detalleVenta?: SortOrder
    id_producto?: SortOrder
    id_venta?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
  }

  export type DetallesVentasMinOrderByAggregateInput = {
    id_detalleVenta?: SortOrder
    id_producto?: SortOrder
    id_venta?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
  }

  export type DetallesVentasSumOrderByAggregateInput = {
    id_detalleVenta?: SortOrder
    id_producto?: SortOrder
    id_venta?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
  }

  export type UsuariosClientesRelationFilter = {
    is?: usuariosClientesWhereInput
    isNot?: usuariosClientesWhereInput
  }

  export type DireccionesEnvioCountOrderByAggregateInput = {
    id_direccionEnvio?: SortOrder
    direccion?: SortOrder
    id_ciudad?: SortOrder
    id_usuarioCliente?: SortOrder
    direccion_opcional?: SortOrder
  }

  export type DireccionesEnvioAvgOrderByAggregateInput = {
    id_direccionEnvio?: SortOrder
    id_ciudad?: SortOrder
    id_usuarioCliente?: SortOrder
  }

  export type DireccionesEnvioMaxOrderByAggregateInput = {
    id_direccionEnvio?: SortOrder
    direccion?: SortOrder
    id_ciudad?: SortOrder
    id_usuarioCliente?: SortOrder
    direccion_opcional?: SortOrder
  }

  export type DireccionesEnvioMinOrderByAggregateInput = {
    id_direccionEnvio?: SortOrder
    direccion?: SortOrder
    id_ciudad?: SortOrder
    id_usuarioCliente?: SortOrder
    direccion_opcional?: SortOrder
  }

  export type DireccionesEnvioSumOrderByAggregateInput = {
    id_direccionEnvio?: SortOrder
    id_ciudad?: SortOrder
    id_usuarioCliente?: SortOrder
  }

  export type RolesEmpleadosRelationFilter = {
    is?: RolesEmpleadosWhereInput
    isNot?: RolesEmpleadosWhereInput
  }

  export type ComprasListRelationFilter = {
    every?: ComprasWhereInput
    some?: ComprasWhereInput
    none?: ComprasWhereInput
  }

  export type UsuarioEmpleadosListRelationFilter = {
    every?: UsuarioEmpleadosWhereInput
    some?: UsuarioEmpleadosWhereInput
    none?: UsuarioEmpleadosWhereInput
  }

  export type ComprasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioEmpleadosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpleadosCountOrderByAggregateInput = {
    id_empleado?: SortOrder
    nom_empleado?: SortOrder
    apellido_empleado?: SortOrder
    telefono_empleado?: SortOrder
    direccion_empleado?: SortOrder
    id_ciudad?: SortOrder
    id_rol?: SortOrder
    fnacimiento_empleado?: SortOrder
    Estado?: SortOrder
  }

  export type EmpleadosAvgOrderByAggregateInput = {
    id_empleado?: SortOrder
    id_ciudad?: SortOrder
    id_rol?: SortOrder
    fnacimiento_empleado?: SortOrder
  }

  export type EmpleadosMaxOrderByAggregateInput = {
    id_empleado?: SortOrder
    nom_empleado?: SortOrder
    apellido_empleado?: SortOrder
    telefono_empleado?: SortOrder
    direccion_empleado?: SortOrder
    id_ciudad?: SortOrder
    id_rol?: SortOrder
    fnacimiento_empleado?: SortOrder
    Estado?: SortOrder
  }

  export type EmpleadosMinOrderByAggregateInput = {
    id_empleado?: SortOrder
    nom_empleado?: SortOrder
    apellido_empleado?: SortOrder
    telefono_empleado?: SortOrder
    direccion_empleado?: SortOrder
    id_ciudad?: SortOrder
    id_rol?: SortOrder
    fnacimiento_empleado?: SortOrder
    Estado?: SortOrder
  }

  export type EmpleadosSumOrderByAggregateInput = {
    id_empleado?: SortOrder
    id_ciudad?: SortOrder
    id_rol?: SortOrder
    fnacimiento_empleado?: SortOrder
  }

  export type EnviosListRelationFilter = {
    every?: EnviosWhereInput
    some?: EnviosWhereInput
    none?: EnviosWhereInput
  }

  export type EnviosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresasEnvioCountOrderByAggregateInput = {
    id_empresaEnvio?: SortOrder
    nombre_empresa?: SortOrder
    direccion_empresa?: SortOrder
    telefono_empresa?: SortOrder
    id_ciudad?: SortOrder
    estado?: SortOrder
    correo_empresa?: SortOrder
  }

  export type EmpresasEnvioAvgOrderByAggregateInput = {
    id_empresaEnvio?: SortOrder
    id_ciudad?: SortOrder
  }

  export type EmpresasEnvioMaxOrderByAggregateInput = {
    id_empresaEnvio?: SortOrder
    nombre_empresa?: SortOrder
    direccion_empresa?: SortOrder
    telefono_empresa?: SortOrder
    id_ciudad?: SortOrder
    estado?: SortOrder
    correo_empresa?: SortOrder
  }

  export type EmpresasEnvioMinOrderByAggregateInput = {
    id_empresaEnvio?: SortOrder
    nombre_empresa?: SortOrder
    direccion_empresa?: SortOrder
    telefono_empresa?: SortOrder
    id_ciudad?: SortOrder
    estado?: SortOrder
    correo_empresa?: SortOrder
  }

  export type EmpresasEnvioSumOrderByAggregateInput = {
    id_empresaEnvio?: SortOrder
    id_ciudad?: SortOrder
  }

  export type EmpresasEnvioRelationFilter = {
    is?: EmpresasEnvioWhereInput
    isNot?: EmpresasEnvioWhereInput
  }

  export type EnviosCountOrderByAggregateInput = {
    id_envio?: SortOrder
    num_rastreo?: SortOrder
    id_venta?: SortOrder
    id_empresaEnvio?: SortOrder
  }

  export type EnviosAvgOrderByAggregateInput = {
    id_envio?: SortOrder
    id_venta?: SortOrder
    id_empresaEnvio?: SortOrder
  }

  export type EnviosMaxOrderByAggregateInput = {
    id_envio?: SortOrder
    num_rastreo?: SortOrder
    id_venta?: SortOrder
    id_empresaEnvio?: SortOrder
  }

  export type EnviosMinOrderByAggregateInput = {
    id_envio?: SortOrder
    num_rastreo?: SortOrder
    id_venta?: SortOrder
    id_empresaEnvio?: SortOrder
  }

  export type EnviosSumOrderByAggregateInput = {
    id_envio?: SortOrder
    id_venta?: SortOrder
    id_empresaEnvio?: SortOrder
  }

  export type MarcasCountOrderByAggregateInput = {
    id_marca?: SortOrder
    descripcion_marca?: SortOrder
    estado?: SortOrder
  }

  export type MarcasAvgOrderByAggregateInput = {
    id_marca?: SortOrder
  }

  export type MarcasMaxOrderByAggregateInput = {
    id_marca?: SortOrder
    descripcion_marca?: SortOrder
    estado?: SortOrder
  }

  export type MarcasMinOrderByAggregateInput = {
    id_marca?: SortOrder
    descripcion_marca?: SortOrder
    estado?: SortOrder
  }

  export type MarcasSumOrderByAggregateInput = {
    id_marca?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type CategoriasRelationFilter = {
    is?: CategoriasWhereInput
    isNot?: CategoriasWhereInput
  }

  export type MarcasRelationFilter = {
    is?: MarcasWhereInput
    isNot?: MarcasWhereInput
  }

  export type CarritoItemListRelationFilter = {
    every?: CarritoItemWhereInput
    some?: CarritoItemWhereInput
    none?: CarritoItemWhereInput
  }

  export type DetallesVentasListRelationFilter = {
    every?: DetallesVentasWhereInput
    some?: DetallesVentasWhereInput
    none?: DetallesVentasWhereInput
  }

  export type CarritoItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DetallesVentasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductosCountOrderByAggregateInput = {
    id_producto?: SortOrder
    descripcion_producto?: SortOrder
    id_marca?: SortOrder
    id_categoria?: SortOrder
    id_proveedor?: SortOrder
    cantidad_por_unidad?: SortOrder
    costo_producto?: SortOrder
    precio_actual?: SortOrder
    stock?: SortOrder
    descuento?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
  }

  export type ProductosAvgOrderByAggregateInput = {
    id_producto?: SortOrder
    id_marca?: SortOrder
    id_categoria?: SortOrder
    id_proveedor?: SortOrder
    costo_producto?: SortOrder
    precio_actual?: SortOrder
    stock?: SortOrder
    descuento?: SortOrder
  }

  export type ProductosMaxOrderByAggregateInput = {
    id_producto?: SortOrder
    descripcion_producto?: SortOrder
    id_marca?: SortOrder
    id_categoria?: SortOrder
    id_proveedor?: SortOrder
    cantidad_por_unidad?: SortOrder
    costo_producto?: SortOrder
    precio_actual?: SortOrder
    stock?: SortOrder
    descuento?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
  }

  export type ProductosMinOrderByAggregateInput = {
    id_producto?: SortOrder
    descripcion_producto?: SortOrder
    id_marca?: SortOrder
    id_categoria?: SortOrder
    id_proveedor?: SortOrder
    cantidad_por_unidad?: SortOrder
    costo_producto?: SortOrder
    precio_actual?: SortOrder
    stock?: SortOrder
    descuento?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
  }

  export type ProductosSumOrderByAggregateInput = {
    id_producto?: SortOrder
    id_marca?: SortOrder
    id_categoria?: SortOrder
    id_proveedor?: SortOrder
    costo_producto?: SortOrder
    precio_actual?: SortOrder
    stock?: SortOrder
    descuento?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type ProveedoresCountOrderByAggregateInput = {
    id_prov?: SortOrder
    nom_prov?: SortOrder
    telefono_prov?: SortOrder
    correo_prov?: SortOrder
    direccion_prov?: SortOrder
    id_ciudad?: SortOrder
    Estado?: SortOrder
  }

  export type ProveedoresAvgOrderByAggregateInput = {
    id_prov?: SortOrder
    id_ciudad?: SortOrder
  }

  export type ProveedoresMaxOrderByAggregateInput = {
    id_prov?: SortOrder
    nom_prov?: SortOrder
    telefono_prov?: SortOrder
    correo_prov?: SortOrder
    direccion_prov?: SortOrder
    id_ciudad?: SortOrder
    Estado?: SortOrder
  }

  export type ProveedoresMinOrderByAggregateInput = {
    id_prov?: SortOrder
    nom_prov?: SortOrder
    telefono_prov?: SortOrder
    correo_prov?: SortOrder
    direccion_prov?: SortOrder
    id_ciudad?: SortOrder
    Estado?: SortOrder
  }

  export type ProveedoresSumOrderByAggregateInput = {
    id_prov?: SortOrder
    id_ciudad?: SortOrder
  }

  export type RolesEmpleadosCountOrderByAggregateInput = {
    id_rol?: SortOrder
    descripcion?: SortOrder
  }

  export type RolesEmpleadosAvgOrderByAggregateInput = {
    id_rol?: SortOrder
  }

  export type RolesEmpleadosMaxOrderByAggregateInput = {
    id_rol?: SortOrder
    descripcion?: SortOrder
  }

  export type RolesEmpleadosMinOrderByAggregateInput = {
    id_rol?: SortOrder
    descripcion?: SortOrder
  }

  export type RolesEmpleadosSumOrderByAggregateInput = {
    id_rol?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type sysdiagramsPrincipal_idNameCompoundUniqueInput = {
    principal_id: number
    name: string
  }

  export type sysdiagramsCountOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsAvgOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type sysdiagramsMaxOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsMinOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsSumOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type BytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type UsuarioEmpleadosCountOrderByAggregateInput = {
    id_usuarioEmpleado?: SortOrder
    nom_usuarioEmpleado?: SortOrder
    estado?: SortOrder
    contrasenia_empleado?: SortOrder
    correo_empleado?: SortOrder
    id_empleado?: SortOrder
  }

  export type UsuarioEmpleadosAvgOrderByAggregateInput = {
    id_usuarioEmpleado?: SortOrder
    id_empleado?: SortOrder
  }

  export type UsuarioEmpleadosMaxOrderByAggregateInput = {
    id_usuarioEmpleado?: SortOrder
    nom_usuarioEmpleado?: SortOrder
    estado?: SortOrder
    contrasenia_empleado?: SortOrder
    correo_empleado?: SortOrder
    id_empleado?: SortOrder
  }

  export type UsuarioEmpleadosMinOrderByAggregateInput = {
    id_usuarioEmpleado?: SortOrder
    nom_usuarioEmpleado?: SortOrder
    estado?: SortOrder
    contrasenia_empleado?: SortOrder
    correo_empleado?: SortOrder
    id_empleado?: SortOrder
  }

  export type UsuarioEmpleadosSumOrderByAggregateInput = {
    id_usuarioEmpleado?: SortOrder
    id_empleado?: SortOrder
  }

  export type ClientesRelationFilter = {
    is?: ClientesWhereInput
    isNot?: ClientesWhereInput
  }

  export type CarritoListRelationFilter = {
    every?: CarritoWhereInput
    some?: CarritoWhereInput
    none?: CarritoWhereInput
  }

  export type CarritoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuariosClientesCountOrderByAggregateInput = {
    id_usuarioCliente?: SortOrder
    nombre_usuario?: SortOrder
    contraenia_usuario?: SortOrder
    id_cliente?: SortOrder
    correo_usuario?: SortOrder
    estado?: SortOrder
  }

  export type usuariosClientesAvgOrderByAggregateInput = {
    id_usuarioCliente?: SortOrder
    id_cliente?: SortOrder
  }

  export type usuariosClientesMaxOrderByAggregateInput = {
    id_usuarioCliente?: SortOrder
    nombre_usuario?: SortOrder
    contraenia_usuario?: SortOrder
    id_cliente?: SortOrder
    correo_usuario?: SortOrder
    estado?: SortOrder
  }

  export type usuariosClientesMinOrderByAggregateInput = {
    id_usuarioCliente?: SortOrder
    nombre_usuario?: SortOrder
    contraenia_usuario?: SortOrder
    id_cliente?: SortOrder
    correo_usuario?: SortOrder
    estado?: SortOrder
  }

  export type usuariosClientesSumOrderByAggregateInput = {
    id_usuarioCliente?: SortOrder
    id_cliente?: SortOrder
  }

  export type DireccionesEnvioRelationFilter = {
    is?: DireccionesEnvioWhereInput
    isNot?: DireccionesEnvioWhereInput
  }

  export type VentaCountOrderByAggregateInput = {
    id_Venta?: SortOrder
    fecha?: SortOrder
    id_cliente?: SortOrder
    RTN_estado?: SortOrder
    ISV?: SortOrder
    id_direccionEnvio?: SortOrder
    descuento?: SortOrder
  }

  export type VentaAvgOrderByAggregateInput = {
    id_Venta?: SortOrder
    id_cliente?: SortOrder
    ISV?: SortOrder
    id_direccionEnvio?: SortOrder
    descuento?: SortOrder
  }

  export type VentaMaxOrderByAggregateInput = {
    id_Venta?: SortOrder
    fecha?: SortOrder
    id_cliente?: SortOrder
    RTN_estado?: SortOrder
    ISV?: SortOrder
    id_direccionEnvio?: SortOrder
    descuento?: SortOrder
  }

  export type VentaMinOrderByAggregateInput = {
    id_Venta?: SortOrder
    fecha?: SortOrder
    id_cliente?: SortOrder
    RTN_estado?: SortOrder
    ISV?: SortOrder
    id_direccionEnvio?: SortOrder
    descuento?: SortOrder
  }

  export type VentaSumOrderByAggregateInput = {
    id_Venta?: SortOrder
    id_cliente?: SortOrder
    ISV?: SortOrder
    id_direccionEnvio?: SortOrder
    descuento?: SortOrder
  }

  export type CarritoCountOrderByAggregateInput = {
    id_carrito?: SortOrder
    id_usuarioCliente?: SortOrder
  }

  export type CarritoAvgOrderByAggregateInput = {
    id_carrito?: SortOrder
    id_usuarioCliente?: SortOrder
  }

  export type CarritoMaxOrderByAggregateInput = {
    id_carrito?: SortOrder
    id_usuarioCliente?: SortOrder
  }

  export type CarritoMinOrderByAggregateInput = {
    id_carrito?: SortOrder
    id_usuarioCliente?: SortOrder
  }

  export type CarritoSumOrderByAggregateInput = {
    id_carrito?: SortOrder
    id_usuarioCliente?: SortOrder
  }

  export type CarritoRelationFilter = {
    is?: CarritoWhereInput
    isNot?: CarritoWhereInput
  }

  export type CarritoItemCountOrderByAggregateInput = {
    id_itemCarrito?: SortOrder
    id_Carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type CarritoItemAvgOrderByAggregateInput = {
    id_itemCarrito?: SortOrder
    id_Carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type CarritoItemMaxOrderByAggregateInput = {
    id_itemCarrito?: SortOrder
    id_Carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type CarritoItemMinOrderByAggregateInput = {
    id_itemCarrito?: SortOrder
    id_Carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type CarritoItemSumOrderByAggregateInput = {
    id_itemCarrito?: SortOrder
    id_Carrito?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
  }

  export type ProductosCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutCategoriasInput>, Enumerable<ProductosUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutCategoriasInput>
    createMany?: ProductosCreateManyCategoriasInputEnvelope
    connect?: Enumerable<ProductosWhereUniqueInput>
  }

  export type ProductosUncheckedCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutCategoriasInput>, Enumerable<ProductosUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutCategoriasInput>
    createMany?: ProductosCreateManyCategoriasInputEnvelope
    connect?: Enumerable<ProductosWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProductosUpdateManyWithoutCategoriasInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutCategoriasInput>, Enumerable<ProductosUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutCategoriasInput>
    upsert?: Enumerable<ProductosUpsertWithWhereUniqueWithoutCategoriasInput>
    createMany?: ProductosCreateManyCategoriasInputEnvelope
    set?: Enumerable<ProductosWhereUniqueInput>
    disconnect?: Enumerable<ProductosWhereUniqueInput>
    delete?: Enumerable<ProductosWhereUniqueInput>
    connect?: Enumerable<ProductosWhereUniqueInput>
    update?: Enumerable<ProductosUpdateWithWhereUniqueWithoutCategoriasInput>
    updateMany?: Enumerable<ProductosUpdateManyWithWhereWithoutCategoriasInput>
    deleteMany?: Enumerable<ProductosScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductosUncheckedUpdateManyWithoutCategoriasInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutCategoriasInput>, Enumerable<ProductosUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutCategoriasInput>
    upsert?: Enumerable<ProductosUpsertWithWhereUniqueWithoutCategoriasInput>
    createMany?: ProductosCreateManyCategoriasInputEnvelope
    set?: Enumerable<ProductosWhereUniqueInput>
    disconnect?: Enumerable<ProductosWhereUniqueInput>
    delete?: Enumerable<ProductosWhereUniqueInput>
    connect?: Enumerable<ProductosWhereUniqueInput>
    update?: Enumerable<ProductosUpdateWithWhereUniqueWithoutCategoriasInput>
    updateMany?: Enumerable<ProductosUpdateManyWithWhereWithoutCategoriasInput>
    deleteMany?: Enumerable<ProductosScalarWhereInput>
  }

  export type DepartamentosCreateNestedOneWithoutCiudadesInput = {
    create?: XOR<DepartamentosCreateWithoutCiudadesInput, DepartamentosUncheckedCreateWithoutCiudadesInput>
    connectOrCreate?: DepartamentosCreateOrConnectWithoutCiudadesInput
    connect?: DepartamentosWhereUniqueInput
  }

  export type ClientesCreateNestedManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<ClientesCreateWithoutCiudadesInput>, Enumerable<ClientesUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<ClientesCreateOrConnectWithoutCiudadesInput>
    createMany?: ClientesCreateManyCiudadesInputEnvelope
    connect?: Enumerable<ClientesWhereUniqueInput>
  }

  export type DireccionesEnvioCreateNestedManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<DireccionesEnvioCreateWithoutCiudadesInput>, Enumerable<DireccionesEnvioUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<DireccionesEnvioCreateOrConnectWithoutCiudadesInput>
    createMany?: DireccionesEnvioCreateManyCiudadesInputEnvelope
    connect?: Enumerable<DireccionesEnvioWhereUniqueInput>
  }

  export type EmpleadosCreateNestedManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<EmpleadosCreateWithoutCiudadesInput>, Enumerable<EmpleadosUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<EmpleadosCreateOrConnectWithoutCiudadesInput>
    createMany?: EmpleadosCreateManyCiudadesInputEnvelope
    connect?: Enumerable<EmpleadosWhereUniqueInput>
  }

  export type EmpresasEnvioCreateNestedManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<EmpresasEnvioCreateWithoutCiudadesInput>, Enumerable<EmpresasEnvioUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<EmpresasEnvioCreateOrConnectWithoutCiudadesInput>
    createMany?: EmpresasEnvioCreateManyCiudadesInputEnvelope
    connect?: Enumerable<EmpresasEnvioWhereUniqueInput>
  }

  export type ProveedoresCreateNestedManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<ProveedoresCreateWithoutCiudadesInput>, Enumerable<ProveedoresUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<ProveedoresCreateOrConnectWithoutCiudadesInput>
    createMany?: ProveedoresCreateManyCiudadesInputEnvelope
    connect?: Enumerable<ProveedoresWhereUniqueInput>
  }

  export type ClientesUncheckedCreateNestedManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<ClientesCreateWithoutCiudadesInput>, Enumerable<ClientesUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<ClientesCreateOrConnectWithoutCiudadesInput>
    createMany?: ClientesCreateManyCiudadesInputEnvelope
    connect?: Enumerable<ClientesWhereUniqueInput>
  }

  export type DireccionesEnvioUncheckedCreateNestedManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<DireccionesEnvioCreateWithoutCiudadesInput>, Enumerable<DireccionesEnvioUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<DireccionesEnvioCreateOrConnectWithoutCiudadesInput>
    createMany?: DireccionesEnvioCreateManyCiudadesInputEnvelope
    connect?: Enumerable<DireccionesEnvioWhereUniqueInput>
  }

  export type EmpleadosUncheckedCreateNestedManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<EmpleadosCreateWithoutCiudadesInput>, Enumerable<EmpleadosUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<EmpleadosCreateOrConnectWithoutCiudadesInput>
    createMany?: EmpleadosCreateManyCiudadesInputEnvelope
    connect?: Enumerable<EmpleadosWhereUniqueInput>
  }

  export type EmpresasEnvioUncheckedCreateNestedManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<EmpresasEnvioCreateWithoutCiudadesInput>, Enumerable<EmpresasEnvioUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<EmpresasEnvioCreateOrConnectWithoutCiudadesInput>
    createMany?: EmpresasEnvioCreateManyCiudadesInputEnvelope
    connect?: Enumerable<EmpresasEnvioWhereUniqueInput>
  }

  export type ProveedoresUncheckedCreateNestedManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<ProveedoresCreateWithoutCiudadesInput>, Enumerable<ProveedoresUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<ProveedoresCreateOrConnectWithoutCiudadesInput>
    createMany?: ProveedoresCreateManyCiudadesInputEnvelope
    connect?: Enumerable<ProveedoresWhereUniqueInput>
  }

  export type DepartamentosUpdateOneRequiredWithoutCiudadesInput = {
    create?: XOR<DepartamentosCreateWithoutCiudadesInput, DepartamentosUncheckedCreateWithoutCiudadesInput>
    connectOrCreate?: DepartamentosCreateOrConnectWithoutCiudadesInput
    upsert?: DepartamentosUpsertWithoutCiudadesInput
    connect?: DepartamentosWhereUniqueInput
    update?: XOR<DepartamentosUpdateWithoutCiudadesInput, DepartamentosUncheckedUpdateWithoutCiudadesInput>
  }

  export type ClientesUpdateManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<ClientesCreateWithoutCiudadesInput>, Enumerable<ClientesUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<ClientesCreateOrConnectWithoutCiudadesInput>
    upsert?: Enumerable<ClientesUpsertWithWhereUniqueWithoutCiudadesInput>
    createMany?: ClientesCreateManyCiudadesInputEnvelope
    set?: Enumerable<ClientesWhereUniqueInput>
    disconnect?: Enumerable<ClientesWhereUniqueInput>
    delete?: Enumerable<ClientesWhereUniqueInput>
    connect?: Enumerable<ClientesWhereUniqueInput>
    update?: Enumerable<ClientesUpdateWithWhereUniqueWithoutCiudadesInput>
    updateMany?: Enumerable<ClientesUpdateManyWithWhereWithoutCiudadesInput>
    deleteMany?: Enumerable<ClientesScalarWhereInput>
  }

  export type DireccionesEnvioUpdateManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<DireccionesEnvioCreateWithoutCiudadesInput>, Enumerable<DireccionesEnvioUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<DireccionesEnvioCreateOrConnectWithoutCiudadesInput>
    upsert?: Enumerable<DireccionesEnvioUpsertWithWhereUniqueWithoutCiudadesInput>
    createMany?: DireccionesEnvioCreateManyCiudadesInputEnvelope
    set?: Enumerable<DireccionesEnvioWhereUniqueInput>
    disconnect?: Enumerable<DireccionesEnvioWhereUniqueInput>
    delete?: Enumerable<DireccionesEnvioWhereUniqueInput>
    connect?: Enumerable<DireccionesEnvioWhereUniqueInput>
    update?: Enumerable<DireccionesEnvioUpdateWithWhereUniqueWithoutCiudadesInput>
    updateMany?: Enumerable<DireccionesEnvioUpdateManyWithWhereWithoutCiudadesInput>
    deleteMany?: Enumerable<DireccionesEnvioScalarWhereInput>
  }

  export type EmpleadosUpdateManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<EmpleadosCreateWithoutCiudadesInput>, Enumerable<EmpleadosUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<EmpleadosCreateOrConnectWithoutCiudadesInput>
    upsert?: Enumerable<EmpleadosUpsertWithWhereUniqueWithoutCiudadesInput>
    createMany?: EmpleadosCreateManyCiudadesInputEnvelope
    set?: Enumerable<EmpleadosWhereUniqueInput>
    disconnect?: Enumerable<EmpleadosWhereUniqueInput>
    delete?: Enumerable<EmpleadosWhereUniqueInput>
    connect?: Enumerable<EmpleadosWhereUniqueInput>
    update?: Enumerable<EmpleadosUpdateWithWhereUniqueWithoutCiudadesInput>
    updateMany?: Enumerable<EmpleadosUpdateManyWithWhereWithoutCiudadesInput>
    deleteMany?: Enumerable<EmpleadosScalarWhereInput>
  }

  export type EmpresasEnvioUpdateManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<EmpresasEnvioCreateWithoutCiudadesInput>, Enumerable<EmpresasEnvioUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<EmpresasEnvioCreateOrConnectWithoutCiudadesInput>
    upsert?: Enumerable<EmpresasEnvioUpsertWithWhereUniqueWithoutCiudadesInput>
    createMany?: EmpresasEnvioCreateManyCiudadesInputEnvelope
    set?: Enumerable<EmpresasEnvioWhereUniqueInput>
    disconnect?: Enumerable<EmpresasEnvioWhereUniqueInput>
    delete?: Enumerable<EmpresasEnvioWhereUniqueInput>
    connect?: Enumerable<EmpresasEnvioWhereUniqueInput>
    update?: Enumerable<EmpresasEnvioUpdateWithWhereUniqueWithoutCiudadesInput>
    updateMany?: Enumerable<EmpresasEnvioUpdateManyWithWhereWithoutCiudadesInput>
    deleteMany?: Enumerable<EmpresasEnvioScalarWhereInput>
  }

  export type ProveedoresUpdateManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<ProveedoresCreateWithoutCiudadesInput>, Enumerable<ProveedoresUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<ProveedoresCreateOrConnectWithoutCiudadesInput>
    upsert?: Enumerable<ProveedoresUpsertWithWhereUniqueWithoutCiudadesInput>
    createMany?: ProveedoresCreateManyCiudadesInputEnvelope
    set?: Enumerable<ProveedoresWhereUniqueInput>
    disconnect?: Enumerable<ProveedoresWhereUniqueInput>
    delete?: Enumerable<ProveedoresWhereUniqueInput>
    connect?: Enumerable<ProveedoresWhereUniqueInput>
    update?: Enumerable<ProveedoresUpdateWithWhereUniqueWithoutCiudadesInput>
    updateMany?: Enumerable<ProveedoresUpdateManyWithWhereWithoutCiudadesInput>
    deleteMany?: Enumerable<ProveedoresScalarWhereInput>
  }

  export type ClientesUncheckedUpdateManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<ClientesCreateWithoutCiudadesInput>, Enumerable<ClientesUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<ClientesCreateOrConnectWithoutCiudadesInput>
    upsert?: Enumerable<ClientesUpsertWithWhereUniqueWithoutCiudadesInput>
    createMany?: ClientesCreateManyCiudadesInputEnvelope
    set?: Enumerable<ClientesWhereUniqueInput>
    disconnect?: Enumerable<ClientesWhereUniqueInput>
    delete?: Enumerable<ClientesWhereUniqueInput>
    connect?: Enumerable<ClientesWhereUniqueInput>
    update?: Enumerable<ClientesUpdateWithWhereUniqueWithoutCiudadesInput>
    updateMany?: Enumerable<ClientesUpdateManyWithWhereWithoutCiudadesInput>
    deleteMany?: Enumerable<ClientesScalarWhereInput>
  }

  export type DireccionesEnvioUncheckedUpdateManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<DireccionesEnvioCreateWithoutCiudadesInput>, Enumerable<DireccionesEnvioUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<DireccionesEnvioCreateOrConnectWithoutCiudadesInput>
    upsert?: Enumerable<DireccionesEnvioUpsertWithWhereUniqueWithoutCiudadesInput>
    createMany?: DireccionesEnvioCreateManyCiudadesInputEnvelope
    set?: Enumerable<DireccionesEnvioWhereUniqueInput>
    disconnect?: Enumerable<DireccionesEnvioWhereUniqueInput>
    delete?: Enumerable<DireccionesEnvioWhereUniqueInput>
    connect?: Enumerable<DireccionesEnvioWhereUniqueInput>
    update?: Enumerable<DireccionesEnvioUpdateWithWhereUniqueWithoutCiudadesInput>
    updateMany?: Enumerable<DireccionesEnvioUpdateManyWithWhereWithoutCiudadesInput>
    deleteMany?: Enumerable<DireccionesEnvioScalarWhereInput>
  }

  export type EmpleadosUncheckedUpdateManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<EmpleadosCreateWithoutCiudadesInput>, Enumerable<EmpleadosUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<EmpleadosCreateOrConnectWithoutCiudadesInput>
    upsert?: Enumerable<EmpleadosUpsertWithWhereUniqueWithoutCiudadesInput>
    createMany?: EmpleadosCreateManyCiudadesInputEnvelope
    set?: Enumerable<EmpleadosWhereUniqueInput>
    disconnect?: Enumerable<EmpleadosWhereUniqueInput>
    delete?: Enumerable<EmpleadosWhereUniqueInput>
    connect?: Enumerable<EmpleadosWhereUniqueInput>
    update?: Enumerable<EmpleadosUpdateWithWhereUniqueWithoutCiudadesInput>
    updateMany?: Enumerable<EmpleadosUpdateManyWithWhereWithoutCiudadesInput>
    deleteMany?: Enumerable<EmpleadosScalarWhereInput>
  }

  export type EmpresasEnvioUncheckedUpdateManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<EmpresasEnvioCreateWithoutCiudadesInput>, Enumerable<EmpresasEnvioUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<EmpresasEnvioCreateOrConnectWithoutCiudadesInput>
    upsert?: Enumerable<EmpresasEnvioUpsertWithWhereUniqueWithoutCiudadesInput>
    createMany?: EmpresasEnvioCreateManyCiudadesInputEnvelope
    set?: Enumerable<EmpresasEnvioWhereUniqueInput>
    disconnect?: Enumerable<EmpresasEnvioWhereUniqueInput>
    delete?: Enumerable<EmpresasEnvioWhereUniqueInput>
    connect?: Enumerable<EmpresasEnvioWhereUniqueInput>
    update?: Enumerable<EmpresasEnvioUpdateWithWhereUniqueWithoutCiudadesInput>
    updateMany?: Enumerable<EmpresasEnvioUpdateManyWithWhereWithoutCiudadesInput>
    deleteMany?: Enumerable<EmpresasEnvioScalarWhereInput>
  }

  export type ProveedoresUncheckedUpdateManyWithoutCiudadesInput = {
    create?: XOR<Enumerable<ProveedoresCreateWithoutCiudadesInput>, Enumerable<ProveedoresUncheckedCreateWithoutCiudadesInput>>
    connectOrCreate?: Enumerable<ProveedoresCreateOrConnectWithoutCiudadesInput>
    upsert?: Enumerable<ProveedoresUpsertWithWhereUniqueWithoutCiudadesInput>
    createMany?: ProveedoresCreateManyCiudadesInputEnvelope
    set?: Enumerable<ProveedoresWhereUniqueInput>
    disconnect?: Enumerable<ProveedoresWhereUniqueInput>
    delete?: Enumerable<ProveedoresWhereUniqueInput>
    connect?: Enumerable<ProveedoresWhereUniqueInput>
    update?: Enumerable<ProveedoresUpdateWithWhereUniqueWithoutCiudadesInput>
    updateMany?: Enumerable<ProveedoresUpdateManyWithWhereWithoutCiudadesInput>
    deleteMany?: Enumerable<ProveedoresScalarWhereInput>
  }

  export type CiudadesCreateNestedOneWithoutClientesInput = {
    create?: XOR<CiudadesCreateWithoutClientesInput, CiudadesUncheckedCreateWithoutClientesInput>
    connectOrCreate?: CiudadesCreateOrConnectWithoutClientesInput
    connect?: CiudadesWhereUniqueInput
  }

  export type usuariosClientesCreateNestedManyWithoutClientesInput = {
    create?: XOR<Enumerable<usuariosClientesCreateWithoutClientesInput>, Enumerable<usuariosClientesUncheckedCreateWithoutClientesInput>>
    connectOrCreate?: Enumerable<usuariosClientesCreateOrConnectWithoutClientesInput>
    createMany?: usuariosClientesCreateManyClientesInputEnvelope
    connect?: Enumerable<usuariosClientesWhereUniqueInput>
  }

  export type VentaCreateNestedManyWithoutClientesInput = {
    create?: XOR<Enumerable<VentaCreateWithoutClientesInput>, Enumerable<VentaUncheckedCreateWithoutClientesInput>>
    connectOrCreate?: Enumerable<VentaCreateOrConnectWithoutClientesInput>
    createMany?: VentaCreateManyClientesInputEnvelope
    connect?: Enumerable<VentaWhereUniqueInput>
  }

  export type usuariosClientesUncheckedCreateNestedManyWithoutClientesInput = {
    create?: XOR<Enumerable<usuariosClientesCreateWithoutClientesInput>, Enumerable<usuariosClientesUncheckedCreateWithoutClientesInput>>
    connectOrCreate?: Enumerable<usuariosClientesCreateOrConnectWithoutClientesInput>
    createMany?: usuariosClientesCreateManyClientesInputEnvelope
    connect?: Enumerable<usuariosClientesWhereUniqueInput>
  }

  export type VentaUncheckedCreateNestedManyWithoutClientesInput = {
    create?: XOR<Enumerable<VentaCreateWithoutClientesInput>, Enumerable<VentaUncheckedCreateWithoutClientesInput>>
    connectOrCreate?: Enumerable<VentaCreateOrConnectWithoutClientesInput>
    createMany?: VentaCreateManyClientesInputEnvelope
    connect?: Enumerable<VentaWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CiudadesUpdateOneRequiredWithoutClientesInput = {
    create?: XOR<CiudadesCreateWithoutClientesInput, CiudadesUncheckedCreateWithoutClientesInput>
    connectOrCreate?: CiudadesCreateOrConnectWithoutClientesInput
    upsert?: CiudadesUpsertWithoutClientesInput
    connect?: CiudadesWhereUniqueInput
    update?: XOR<CiudadesUpdateWithoutClientesInput, CiudadesUncheckedUpdateWithoutClientesInput>
  }

  export type usuariosClientesUpdateManyWithoutClientesInput = {
    create?: XOR<Enumerable<usuariosClientesCreateWithoutClientesInput>, Enumerable<usuariosClientesUncheckedCreateWithoutClientesInput>>
    connectOrCreate?: Enumerable<usuariosClientesCreateOrConnectWithoutClientesInput>
    upsert?: Enumerable<usuariosClientesUpsertWithWhereUniqueWithoutClientesInput>
    createMany?: usuariosClientesCreateManyClientesInputEnvelope
    set?: Enumerable<usuariosClientesWhereUniqueInput>
    disconnect?: Enumerable<usuariosClientesWhereUniqueInput>
    delete?: Enumerable<usuariosClientesWhereUniqueInput>
    connect?: Enumerable<usuariosClientesWhereUniqueInput>
    update?: Enumerable<usuariosClientesUpdateWithWhereUniqueWithoutClientesInput>
    updateMany?: Enumerable<usuariosClientesUpdateManyWithWhereWithoutClientesInput>
    deleteMany?: Enumerable<usuariosClientesScalarWhereInput>
  }

  export type VentaUpdateManyWithoutClientesInput = {
    create?: XOR<Enumerable<VentaCreateWithoutClientesInput>, Enumerable<VentaUncheckedCreateWithoutClientesInput>>
    connectOrCreate?: Enumerable<VentaCreateOrConnectWithoutClientesInput>
    upsert?: Enumerable<VentaUpsertWithWhereUniqueWithoutClientesInput>
    createMany?: VentaCreateManyClientesInputEnvelope
    set?: Enumerable<VentaWhereUniqueInput>
    disconnect?: Enumerable<VentaWhereUniqueInput>
    delete?: Enumerable<VentaWhereUniqueInput>
    connect?: Enumerable<VentaWhereUniqueInput>
    update?: Enumerable<VentaUpdateWithWhereUniqueWithoutClientesInput>
    updateMany?: Enumerable<VentaUpdateManyWithWhereWithoutClientesInput>
    deleteMany?: Enumerable<VentaScalarWhereInput>
  }

  export type usuariosClientesUncheckedUpdateManyWithoutClientesInput = {
    create?: XOR<Enumerable<usuariosClientesCreateWithoutClientesInput>, Enumerable<usuariosClientesUncheckedCreateWithoutClientesInput>>
    connectOrCreate?: Enumerable<usuariosClientesCreateOrConnectWithoutClientesInput>
    upsert?: Enumerable<usuariosClientesUpsertWithWhereUniqueWithoutClientesInput>
    createMany?: usuariosClientesCreateManyClientesInputEnvelope
    set?: Enumerable<usuariosClientesWhereUniqueInput>
    disconnect?: Enumerable<usuariosClientesWhereUniqueInput>
    delete?: Enumerable<usuariosClientesWhereUniqueInput>
    connect?: Enumerable<usuariosClientesWhereUniqueInput>
    update?: Enumerable<usuariosClientesUpdateWithWhereUniqueWithoutClientesInput>
    updateMany?: Enumerable<usuariosClientesUpdateManyWithWhereWithoutClientesInput>
    deleteMany?: Enumerable<usuariosClientesScalarWhereInput>
  }

  export type VentaUncheckedUpdateManyWithoutClientesInput = {
    create?: XOR<Enumerable<VentaCreateWithoutClientesInput>, Enumerable<VentaUncheckedCreateWithoutClientesInput>>
    connectOrCreate?: Enumerable<VentaCreateOrConnectWithoutClientesInput>
    upsert?: Enumerable<VentaUpsertWithWhereUniqueWithoutClientesInput>
    createMany?: VentaCreateManyClientesInputEnvelope
    set?: Enumerable<VentaWhereUniqueInput>
    disconnect?: Enumerable<VentaWhereUniqueInput>
    delete?: Enumerable<VentaWhereUniqueInput>
    connect?: Enumerable<VentaWhereUniqueInput>
    update?: Enumerable<VentaUpdateWithWhereUniqueWithoutClientesInput>
    updateMany?: Enumerable<VentaUpdateManyWithWhereWithoutClientesInput>
    deleteMany?: Enumerable<VentaScalarWhereInput>
  }

  export type EmpleadosCreateNestedOneWithoutComprasInput = {
    create?: XOR<EmpleadosCreateWithoutComprasInput, EmpleadosUncheckedCreateWithoutComprasInput>
    connectOrCreate?: EmpleadosCreateOrConnectWithoutComprasInput
    connect?: EmpleadosWhereUniqueInput
  }

  export type ProveedoresCreateNestedOneWithoutComprasInput = {
    create?: XOR<ProveedoresCreateWithoutComprasInput, ProveedoresUncheckedCreateWithoutComprasInput>
    connectOrCreate?: ProveedoresCreateOrConnectWithoutComprasInput
    connect?: ProveedoresWhereUniqueInput
  }

  export type DetalleComprasCreateNestedManyWithoutComprasInput = {
    create?: XOR<Enumerable<DetalleComprasCreateWithoutComprasInput>, Enumerable<DetalleComprasUncheckedCreateWithoutComprasInput>>
    connectOrCreate?: Enumerable<DetalleComprasCreateOrConnectWithoutComprasInput>
    createMany?: DetalleComprasCreateManyComprasInputEnvelope
    connect?: Enumerable<DetalleComprasWhereUniqueInput>
  }

  export type DetalleComprasUncheckedCreateNestedManyWithoutComprasInput = {
    create?: XOR<Enumerable<DetalleComprasCreateWithoutComprasInput>, Enumerable<DetalleComprasUncheckedCreateWithoutComprasInput>>
    connectOrCreate?: Enumerable<DetalleComprasCreateOrConnectWithoutComprasInput>
    createMany?: DetalleComprasCreateManyComprasInputEnvelope
    connect?: Enumerable<DetalleComprasWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmpleadosUpdateOneRequiredWithoutComprasInput = {
    create?: XOR<EmpleadosCreateWithoutComprasInput, EmpleadosUncheckedCreateWithoutComprasInput>
    connectOrCreate?: EmpleadosCreateOrConnectWithoutComprasInput
    upsert?: EmpleadosUpsertWithoutComprasInput
    connect?: EmpleadosWhereUniqueInput
    update?: XOR<EmpleadosUpdateWithoutComprasInput, EmpleadosUncheckedUpdateWithoutComprasInput>
  }

  export type ProveedoresUpdateOneRequiredWithoutComprasInput = {
    create?: XOR<ProveedoresCreateWithoutComprasInput, ProveedoresUncheckedCreateWithoutComprasInput>
    connectOrCreate?: ProveedoresCreateOrConnectWithoutComprasInput
    upsert?: ProveedoresUpsertWithoutComprasInput
    connect?: ProveedoresWhereUniqueInput
    update?: XOR<ProveedoresUpdateWithoutComprasInput, ProveedoresUncheckedUpdateWithoutComprasInput>
  }

  export type DetalleComprasUpdateManyWithoutComprasInput = {
    create?: XOR<Enumerable<DetalleComprasCreateWithoutComprasInput>, Enumerable<DetalleComprasUncheckedCreateWithoutComprasInput>>
    connectOrCreate?: Enumerable<DetalleComprasCreateOrConnectWithoutComprasInput>
    upsert?: Enumerable<DetalleComprasUpsertWithWhereUniqueWithoutComprasInput>
    createMany?: DetalleComprasCreateManyComprasInputEnvelope
    set?: Enumerable<DetalleComprasWhereUniqueInput>
    disconnect?: Enumerable<DetalleComprasWhereUniqueInput>
    delete?: Enumerable<DetalleComprasWhereUniqueInput>
    connect?: Enumerable<DetalleComprasWhereUniqueInput>
    update?: Enumerable<DetalleComprasUpdateWithWhereUniqueWithoutComprasInput>
    updateMany?: Enumerable<DetalleComprasUpdateManyWithWhereWithoutComprasInput>
    deleteMany?: Enumerable<DetalleComprasScalarWhereInput>
  }

  export type DetalleComprasUncheckedUpdateManyWithoutComprasInput = {
    create?: XOR<Enumerable<DetalleComprasCreateWithoutComprasInput>, Enumerable<DetalleComprasUncheckedCreateWithoutComprasInput>>
    connectOrCreate?: Enumerable<DetalleComprasCreateOrConnectWithoutComprasInput>
    upsert?: Enumerable<DetalleComprasUpsertWithWhereUniqueWithoutComprasInput>
    createMany?: DetalleComprasCreateManyComprasInputEnvelope
    set?: Enumerable<DetalleComprasWhereUniqueInput>
    disconnect?: Enumerable<DetalleComprasWhereUniqueInput>
    delete?: Enumerable<DetalleComprasWhereUniqueInput>
    connect?: Enumerable<DetalleComprasWhereUniqueInput>
    update?: Enumerable<DetalleComprasUpdateWithWhereUniqueWithoutComprasInput>
    updateMany?: Enumerable<DetalleComprasUpdateManyWithWhereWithoutComprasInput>
    deleteMany?: Enumerable<DetalleComprasScalarWhereInput>
  }

  export type CiudadesCreateNestedManyWithoutDepartamentosInput = {
    create?: XOR<Enumerable<CiudadesCreateWithoutDepartamentosInput>, Enumerable<CiudadesUncheckedCreateWithoutDepartamentosInput>>
    connectOrCreate?: Enumerable<CiudadesCreateOrConnectWithoutDepartamentosInput>
    createMany?: CiudadesCreateManyDepartamentosInputEnvelope
    connect?: Enumerable<CiudadesWhereUniqueInput>
  }

  export type CiudadesUncheckedCreateNestedManyWithoutDepartamentosInput = {
    create?: XOR<Enumerable<CiudadesCreateWithoutDepartamentosInput>, Enumerable<CiudadesUncheckedCreateWithoutDepartamentosInput>>
    connectOrCreate?: Enumerable<CiudadesCreateOrConnectWithoutDepartamentosInput>
    createMany?: CiudadesCreateManyDepartamentosInputEnvelope
    connect?: Enumerable<CiudadesWhereUniqueInput>
  }

  export type CiudadesUpdateManyWithoutDepartamentosInput = {
    create?: XOR<Enumerable<CiudadesCreateWithoutDepartamentosInput>, Enumerable<CiudadesUncheckedCreateWithoutDepartamentosInput>>
    connectOrCreate?: Enumerable<CiudadesCreateOrConnectWithoutDepartamentosInput>
    upsert?: Enumerable<CiudadesUpsertWithWhereUniqueWithoutDepartamentosInput>
    createMany?: CiudadesCreateManyDepartamentosInputEnvelope
    set?: Enumerable<CiudadesWhereUniqueInput>
    disconnect?: Enumerable<CiudadesWhereUniqueInput>
    delete?: Enumerable<CiudadesWhereUniqueInput>
    connect?: Enumerable<CiudadesWhereUniqueInput>
    update?: Enumerable<CiudadesUpdateWithWhereUniqueWithoutDepartamentosInput>
    updateMany?: Enumerable<CiudadesUpdateManyWithWhereWithoutDepartamentosInput>
    deleteMany?: Enumerable<CiudadesScalarWhereInput>
  }

  export type CiudadesUncheckedUpdateManyWithoutDepartamentosInput = {
    create?: XOR<Enumerable<CiudadesCreateWithoutDepartamentosInput>, Enumerable<CiudadesUncheckedCreateWithoutDepartamentosInput>>
    connectOrCreate?: Enumerable<CiudadesCreateOrConnectWithoutDepartamentosInput>
    upsert?: Enumerable<CiudadesUpsertWithWhereUniqueWithoutDepartamentosInput>
    createMany?: CiudadesCreateManyDepartamentosInputEnvelope
    set?: Enumerable<CiudadesWhereUniqueInput>
    disconnect?: Enumerable<CiudadesWhereUniqueInput>
    delete?: Enumerable<CiudadesWhereUniqueInput>
    connect?: Enumerable<CiudadesWhereUniqueInput>
    update?: Enumerable<CiudadesUpdateWithWhereUniqueWithoutDepartamentosInput>
    updateMany?: Enumerable<CiudadesUpdateManyWithWhereWithoutDepartamentosInput>
    deleteMany?: Enumerable<CiudadesScalarWhereInput>
  }

  export type ComprasCreateNestedOneWithoutDetalleComprasInput = {
    create?: XOR<ComprasCreateWithoutDetalleComprasInput, ComprasUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: ComprasCreateOrConnectWithoutDetalleComprasInput
    connect?: ComprasWhereUniqueInput
  }

  export type ProductosCreateNestedOneWithoutDetalleComprasInput = {
    create?: XOR<ProductosCreateWithoutDetalleComprasInput, ProductosUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutDetalleComprasInput
    connect?: ProductosWhereUniqueInput
  }

  export type ComprasUpdateOneRequiredWithoutDetalleComprasInput = {
    create?: XOR<ComprasCreateWithoutDetalleComprasInput, ComprasUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: ComprasCreateOrConnectWithoutDetalleComprasInput
    upsert?: ComprasUpsertWithoutDetalleComprasInput
    connect?: ComprasWhereUniqueInput
    update?: XOR<ComprasUpdateWithoutDetalleComprasInput, ComprasUncheckedUpdateWithoutDetalleComprasInput>
  }

  export type ProductosUpdateOneRequiredWithoutDetalleComprasInput = {
    create?: XOR<ProductosCreateWithoutDetalleComprasInput, ProductosUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutDetalleComprasInput
    upsert?: ProductosUpsertWithoutDetalleComprasInput
    connect?: ProductosWhereUniqueInput
    update?: XOR<ProductosUpdateWithoutDetalleComprasInput, ProductosUncheckedUpdateWithoutDetalleComprasInput>
  }

  export type ProductosCreateNestedOneWithoutDetallesVentasInput = {
    create?: XOR<ProductosCreateWithoutDetallesVentasInput, ProductosUncheckedCreateWithoutDetallesVentasInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutDetallesVentasInput
    connect?: ProductosWhereUniqueInput
  }

  export type VentaCreateNestedOneWithoutDetallesVentasInput = {
    create?: XOR<VentaCreateWithoutDetallesVentasInput, VentaUncheckedCreateWithoutDetallesVentasInput>
    connectOrCreate?: VentaCreateOrConnectWithoutDetallesVentasInput
    connect?: VentaWhereUniqueInput
  }

  export type ProductosUpdateOneRequiredWithoutDetallesVentasInput = {
    create?: XOR<ProductosCreateWithoutDetallesVentasInput, ProductosUncheckedCreateWithoutDetallesVentasInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutDetallesVentasInput
    upsert?: ProductosUpsertWithoutDetallesVentasInput
    connect?: ProductosWhereUniqueInput
    update?: XOR<ProductosUpdateWithoutDetallesVentasInput, ProductosUncheckedUpdateWithoutDetallesVentasInput>
  }

  export type VentaUpdateOneRequiredWithoutDetallesVentasInput = {
    create?: XOR<VentaCreateWithoutDetallesVentasInput, VentaUncheckedCreateWithoutDetallesVentasInput>
    connectOrCreate?: VentaCreateOrConnectWithoutDetallesVentasInput
    upsert?: VentaUpsertWithoutDetallesVentasInput
    connect?: VentaWhereUniqueInput
    update?: XOR<VentaUpdateWithoutDetallesVentasInput, VentaUncheckedUpdateWithoutDetallesVentasInput>
  }

  export type CiudadesCreateNestedOneWithoutDireccionesEnvioInput = {
    create?: XOR<CiudadesCreateWithoutDireccionesEnvioInput, CiudadesUncheckedCreateWithoutDireccionesEnvioInput>
    connectOrCreate?: CiudadesCreateOrConnectWithoutDireccionesEnvioInput
    connect?: CiudadesWhereUniqueInput
  }

  export type usuariosClientesCreateNestedOneWithoutDireccionesEnvioInput = {
    create?: XOR<usuariosClientesCreateWithoutDireccionesEnvioInput, usuariosClientesUncheckedCreateWithoutDireccionesEnvioInput>
    connectOrCreate?: usuariosClientesCreateOrConnectWithoutDireccionesEnvioInput
    connect?: usuariosClientesWhereUniqueInput
  }

  export type VentaCreateNestedManyWithoutDireccionesEnvioInput = {
    create?: XOR<Enumerable<VentaCreateWithoutDireccionesEnvioInput>, Enumerable<VentaUncheckedCreateWithoutDireccionesEnvioInput>>
    connectOrCreate?: Enumerable<VentaCreateOrConnectWithoutDireccionesEnvioInput>
    createMany?: VentaCreateManyDireccionesEnvioInputEnvelope
    connect?: Enumerable<VentaWhereUniqueInput>
  }

  export type VentaUncheckedCreateNestedManyWithoutDireccionesEnvioInput = {
    create?: XOR<Enumerable<VentaCreateWithoutDireccionesEnvioInput>, Enumerable<VentaUncheckedCreateWithoutDireccionesEnvioInput>>
    connectOrCreate?: Enumerable<VentaCreateOrConnectWithoutDireccionesEnvioInput>
    createMany?: VentaCreateManyDireccionesEnvioInputEnvelope
    connect?: Enumerable<VentaWhereUniqueInput>
  }

  export type CiudadesUpdateOneRequiredWithoutDireccionesEnvioInput = {
    create?: XOR<CiudadesCreateWithoutDireccionesEnvioInput, CiudadesUncheckedCreateWithoutDireccionesEnvioInput>
    connectOrCreate?: CiudadesCreateOrConnectWithoutDireccionesEnvioInput
    upsert?: CiudadesUpsertWithoutDireccionesEnvioInput
    connect?: CiudadesWhereUniqueInput
    update?: XOR<CiudadesUpdateWithoutDireccionesEnvioInput, CiudadesUncheckedUpdateWithoutDireccionesEnvioInput>
  }

  export type usuariosClientesUpdateOneRequiredWithoutDireccionesEnvioInput = {
    create?: XOR<usuariosClientesCreateWithoutDireccionesEnvioInput, usuariosClientesUncheckedCreateWithoutDireccionesEnvioInput>
    connectOrCreate?: usuariosClientesCreateOrConnectWithoutDireccionesEnvioInput
    upsert?: usuariosClientesUpsertWithoutDireccionesEnvioInput
    connect?: usuariosClientesWhereUniqueInput
    update?: XOR<usuariosClientesUpdateWithoutDireccionesEnvioInput, usuariosClientesUncheckedUpdateWithoutDireccionesEnvioInput>
  }

  export type VentaUpdateManyWithoutDireccionesEnvioInput = {
    create?: XOR<Enumerable<VentaCreateWithoutDireccionesEnvioInput>, Enumerable<VentaUncheckedCreateWithoutDireccionesEnvioInput>>
    connectOrCreate?: Enumerable<VentaCreateOrConnectWithoutDireccionesEnvioInput>
    upsert?: Enumerable<VentaUpsertWithWhereUniqueWithoutDireccionesEnvioInput>
    createMany?: VentaCreateManyDireccionesEnvioInputEnvelope
    set?: Enumerable<VentaWhereUniqueInput>
    disconnect?: Enumerable<VentaWhereUniqueInput>
    delete?: Enumerable<VentaWhereUniqueInput>
    connect?: Enumerable<VentaWhereUniqueInput>
    update?: Enumerable<VentaUpdateWithWhereUniqueWithoutDireccionesEnvioInput>
    updateMany?: Enumerable<VentaUpdateManyWithWhereWithoutDireccionesEnvioInput>
    deleteMany?: Enumerable<VentaScalarWhereInput>
  }

  export type VentaUncheckedUpdateManyWithoutDireccionesEnvioInput = {
    create?: XOR<Enumerable<VentaCreateWithoutDireccionesEnvioInput>, Enumerable<VentaUncheckedCreateWithoutDireccionesEnvioInput>>
    connectOrCreate?: Enumerable<VentaCreateOrConnectWithoutDireccionesEnvioInput>
    upsert?: Enumerable<VentaUpsertWithWhereUniqueWithoutDireccionesEnvioInput>
    createMany?: VentaCreateManyDireccionesEnvioInputEnvelope
    set?: Enumerable<VentaWhereUniqueInput>
    disconnect?: Enumerable<VentaWhereUniqueInput>
    delete?: Enumerable<VentaWhereUniqueInput>
    connect?: Enumerable<VentaWhereUniqueInput>
    update?: Enumerable<VentaUpdateWithWhereUniqueWithoutDireccionesEnvioInput>
    updateMany?: Enumerable<VentaUpdateManyWithWhereWithoutDireccionesEnvioInput>
    deleteMany?: Enumerable<VentaScalarWhereInput>
  }

  export type CiudadesCreateNestedOneWithoutEmpleadosInput = {
    create?: XOR<CiudadesCreateWithoutEmpleadosInput, CiudadesUncheckedCreateWithoutEmpleadosInput>
    connectOrCreate?: CiudadesCreateOrConnectWithoutEmpleadosInput
    connect?: CiudadesWhereUniqueInput
  }

  export type RolesEmpleadosCreateNestedOneWithoutEmpleadosInput = {
    create?: XOR<RolesEmpleadosCreateWithoutEmpleadosInput, RolesEmpleadosUncheckedCreateWithoutEmpleadosInput>
    connectOrCreate?: RolesEmpleadosCreateOrConnectWithoutEmpleadosInput
    connect?: RolesEmpleadosWhereUniqueInput
  }

  export type ComprasCreateNestedManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<ComprasCreateWithoutEmpleadosInput>, Enumerable<ComprasUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<ComprasCreateOrConnectWithoutEmpleadosInput>
    createMany?: ComprasCreateManyEmpleadosInputEnvelope
    connect?: Enumerable<ComprasWhereUniqueInput>
  }

  export type UsuarioEmpleadosCreateNestedManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<UsuarioEmpleadosCreateWithoutEmpleadosInput>, Enumerable<UsuarioEmpleadosUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<UsuarioEmpleadosCreateOrConnectWithoutEmpleadosInput>
    createMany?: UsuarioEmpleadosCreateManyEmpleadosInputEnvelope
    connect?: Enumerable<UsuarioEmpleadosWhereUniqueInput>
  }

  export type ComprasUncheckedCreateNestedManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<ComprasCreateWithoutEmpleadosInput>, Enumerable<ComprasUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<ComprasCreateOrConnectWithoutEmpleadosInput>
    createMany?: ComprasCreateManyEmpleadosInputEnvelope
    connect?: Enumerable<ComprasWhereUniqueInput>
  }

  export type UsuarioEmpleadosUncheckedCreateNestedManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<UsuarioEmpleadosCreateWithoutEmpleadosInput>, Enumerable<UsuarioEmpleadosUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<UsuarioEmpleadosCreateOrConnectWithoutEmpleadosInput>
    createMany?: UsuarioEmpleadosCreateManyEmpleadosInputEnvelope
    connect?: Enumerable<UsuarioEmpleadosWhereUniqueInput>
  }

  export type CiudadesUpdateOneRequiredWithoutEmpleadosInput = {
    create?: XOR<CiudadesCreateWithoutEmpleadosInput, CiudadesUncheckedCreateWithoutEmpleadosInput>
    connectOrCreate?: CiudadesCreateOrConnectWithoutEmpleadosInput
    upsert?: CiudadesUpsertWithoutEmpleadosInput
    connect?: CiudadesWhereUniqueInput
    update?: XOR<CiudadesUpdateWithoutEmpleadosInput, CiudadesUncheckedUpdateWithoutEmpleadosInput>
  }

  export type RolesEmpleadosUpdateOneRequiredWithoutEmpleadosInput = {
    create?: XOR<RolesEmpleadosCreateWithoutEmpleadosInput, RolesEmpleadosUncheckedCreateWithoutEmpleadosInput>
    connectOrCreate?: RolesEmpleadosCreateOrConnectWithoutEmpleadosInput
    upsert?: RolesEmpleadosUpsertWithoutEmpleadosInput
    connect?: RolesEmpleadosWhereUniqueInput
    update?: XOR<RolesEmpleadosUpdateWithoutEmpleadosInput, RolesEmpleadosUncheckedUpdateWithoutEmpleadosInput>
  }

  export type ComprasUpdateManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<ComprasCreateWithoutEmpleadosInput>, Enumerable<ComprasUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<ComprasCreateOrConnectWithoutEmpleadosInput>
    upsert?: Enumerable<ComprasUpsertWithWhereUniqueWithoutEmpleadosInput>
    createMany?: ComprasCreateManyEmpleadosInputEnvelope
    set?: Enumerable<ComprasWhereUniqueInput>
    disconnect?: Enumerable<ComprasWhereUniqueInput>
    delete?: Enumerable<ComprasWhereUniqueInput>
    connect?: Enumerable<ComprasWhereUniqueInput>
    update?: Enumerable<ComprasUpdateWithWhereUniqueWithoutEmpleadosInput>
    updateMany?: Enumerable<ComprasUpdateManyWithWhereWithoutEmpleadosInput>
    deleteMany?: Enumerable<ComprasScalarWhereInput>
  }

  export type UsuarioEmpleadosUpdateManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<UsuarioEmpleadosCreateWithoutEmpleadosInput>, Enumerable<UsuarioEmpleadosUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<UsuarioEmpleadosCreateOrConnectWithoutEmpleadosInput>
    upsert?: Enumerable<UsuarioEmpleadosUpsertWithWhereUniqueWithoutEmpleadosInput>
    createMany?: UsuarioEmpleadosCreateManyEmpleadosInputEnvelope
    set?: Enumerable<UsuarioEmpleadosWhereUniqueInput>
    disconnect?: Enumerable<UsuarioEmpleadosWhereUniqueInput>
    delete?: Enumerable<UsuarioEmpleadosWhereUniqueInput>
    connect?: Enumerable<UsuarioEmpleadosWhereUniqueInput>
    update?: Enumerable<UsuarioEmpleadosUpdateWithWhereUniqueWithoutEmpleadosInput>
    updateMany?: Enumerable<UsuarioEmpleadosUpdateManyWithWhereWithoutEmpleadosInput>
    deleteMany?: Enumerable<UsuarioEmpleadosScalarWhereInput>
  }

  export type ComprasUncheckedUpdateManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<ComprasCreateWithoutEmpleadosInput>, Enumerable<ComprasUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<ComprasCreateOrConnectWithoutEmpleadosInput>
    upsert?: Enumerable<ComprasUpsertWithWhereUniqueWithoutEmpleadosInput>
    createMany?: ComprasCreateManyEmpleadosInputEnvelope
    set?: Enumerable<ComprasWhereUniqueInput>
    disconnect?: Enumerable<ComprasWhereUniqueInput>
    delete?: Enumerable<ComprasWhereUniqueInput>
    connect?: Enumerable<ComprasWhereUniqueInput>
    update?: Enumerable<ComprasUpdateWithWhereUniqueWithoutEmpleadosInput>
    updateMany?: Enumerable<ComprasUpdateManyWithWhereWithoutEmpleadosInput>
    deleteMany?: Enumerable<ComprasScalarWhereInput>
  }

  export type UsuarioEmpleadosUncheckedUpdateManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<UsuarioEmpleadosCreateWithoutEmpleadosInput>, Enumerable<UsuarioEmpleadosUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<UsuarioEmpleadosCreateOrConnectWithoutEmpleadosInput>
    upsert?: Enumerable<UsuarioEmpleadosUpsertWithWhereUniqueWithoutEmpleadosInput>
    createMany?: UsuarioEmpleadosCreateManyEmpleadosInputEnvelope
    set?: Enumerable<UsuarioEmpleadosWhereUniqueInput>
    disconnect?: Enumerable<UsuarioEmpleadosWhereUniqueInput>
    delete?: Enumerable<UsuarioEmpleadosWhereUniqueInput>
    connect?: Enumerable<UsuarioEmpleadosWhereUniqueInput>
    update?: Enumerable<UsuarioEmpleadosUpdateWithWhereUniqueWithoutEmpleadosInput>
    updateMany?: Enumerable<UsuarioEmpleadosUpdateManyWithWhereWithoutEmpleadosInput>
    deleteMany?: Enumerable<UsuarioEmpleadosScalarWhereInput>
  }

  export type CiudadesCreateNestedOneWithoutEmpresasEnvioInput = {
    create?: XOR<CiudadesCreateWithoutEmpresasEnvioInput, CiudadesUncheckedCreateWithoutEmpresasEnvioInput>
    connectOrCreate?: CiudadesCreateOrConnectWithoutEmpresasEnvioInput
    connect?: CiudadesWhereUniqueInput
  }

  export type EnviosCreateNestedManyWithoutEmpresasEnvioInput = {
    create?: XOR<Enumerable<EnviosCreateWithoutEmpresasEnvioInput>, Enumerable<EnviosUncheckedCreateWithoutEmpresasEnvioInput>>
    connectOrCreate?: Enumerable<EnviosCreateOrConnectWithoutEmpresasEnvioInput>
    createMany?: EnviosCreateManyEmpresasEnvioInputEnvelope
    connect?: Enumerable<EnviosWhereUniqueInput>
  }

  export type EnviosUncheckedCreateNestedManyWithoutEmpresasEnvioInput = {
    create?: XOR<Enumerable<EnviosCreateWithoutEmpresasEnvioInput>, Enumerable<EnviosUncheckedCreateWithoutEmpresasEnvioInput>>
    connectOrCreate?: Enumerable<EnviosCreateOrConnectWithoutEmpresasEnvioInput>
    createMany?: EnviosCreateManyEmpresasEnvioInputEnvelope
    connect?: Enumerable<EnviosWhereUniqueInput>
  }

  export type CiudadesUpdateOneRequiredWithoutEmpresasEnvioInput = {
    create?: XOR<CiudadesCreateWithoutEmpresasEnvioInput, CiudadesUncheckedCreateWithoutEmpresasEnvioInput>
    connectOrCreate?: CiudadesCreateOrConnectWithoutEmpresasEnvioInput
    upsert?: CiudadesUpsertWithoutEmpresasEnvioInput
    connect?: CiudadesWhereUniqueInput
    update?: XOR<CiudadesUpdateWithoutEmpresasEnvioInput, CiudadesUncheckedUpdateWithoutEmpresasEnvioInput>
  }

  export type EnviosUpdateManyWithoutEmpresasEnvioInput = {
    create?: XOR<Enumerable<EnviosCreateWithoutEmpresasEnvioInput>, Enumerable<EnviosUncheckedCreateWithoutEmpresasEnvioInput>>
    connectOrCreate?: Enumerable<EnviosCreateOrConnectWithoutEmpresasEnvioInput>
    upsert?: Enumerable<EnviosUpsertWithWhereUniqueWithoutEmpresasEnvioInput>
    createMany?: EnviosCreateManyEmpresasEnvioInputEnvelope
    set?: Enumerable<EnviosWhereUniqueInput>
    disconnect?: Enumerable<EnviosWhereUniqueInput>
    delete?: Enumerable<EnviosWhereUniqueInput>
    connect?: Enumerable<EnviosWhereUniqueInput>
    update?: Enumerable<EnviosUpdateWithWhereUniqueWithoutEmpresasEnvioInput>
    updateMany?: Enumerable<EnviosUpdateManyWithWhereWithoutEmpresasEnvioInput>
    deleteMany?: Enumerable<EnviosScalarWhereInput>
  }

  export type EnviosUncheckedUpdateManyWithoutEmpresasEnvioInput = {
    create?: XOR<Enumerable<EnviosCreateWithoutEmpresasEnvioInput>, Enumerable<EnviosUncheckedCreateWithoutEmpresasEnvioInput>>
    connectOrCreate?: Enumerable<EnviosCreateOrConnectWithoutEmpresasEnvioInput>
    upsert?: Enumerable<EnviosUpsertWithWhereUniqueWithoutEmpresasEnvioInput>
    createMany?: EnviosCreateManyEmpresasEnvioInputEnvelope
    set?: Enumerable<EnviosWhereUniqueInput>
    disconnect?: Enumerable<EnviosWhereUniqueInput>
    delete?: Enumerable<EnviosWhereUniqueInput>
    connect?: Enumerable<EnviosWhereUniqueInput>
    update?: Enumerable<EnviosUpdateWithWhereUniqueWithoutEmpresasEnvioInput>
    updateMany?: Enumerable<EnviosUpdateManyWithWhereWithoutEmpresasEnvioInput>
    deleteMany?: Enumerable<EnviosScalarWhereInput>
  }

  export type EmpresasEnvioCreateNestedOneWithoutEnviosInput = {
    create?: XOR<EmpresasEnvioCreateWithoutEnviosInput, EmpresasEnvioUncheckedCreateWithoutEnviosInput>
    connectOrCreate?: EmpresasEnvioCreateOrConnectWithoutEnviosInput
    connect?: EmpresasEnvioWhereUniqueInput
  }

  export type VentaCreateNestedOneWithoutEnviosInput = {
    create?: XOR<VentaCreateWithoutEnviosInput, VentaUncheckedCreateWithoutEnviosInput>
    connectOrCreate?: VentaCreateOrConnectWithoutEnviosInput
    connect?: VentaWhereUniqueInput
  }

  export type EmpresasEnvioUpdateOneRequiredWithoutEnviosInput = {
    create?: XOR<EmpresasEnvioCreateWithoutEnviosInput, EmpresasEnvioUncheckedCreateWithoutEnviosInput>
    connectOrCreate?: EmpresasEnvioCreateOrConnectWithoutEnviosInput
    upsert?: EmpresasEnvioUpsertWithoutEnviosInput
    connect?: EmpresasEnvioWhereUniqueInput
    update?: XOR<EmpresasEnvioUpdateWithoutEnviosInput, EmpresasEnvioUncheckedUpdateWithoutEnviosInput>
  }

  export type VentaUpdateOneRequiredWithoutEnviosInput = {
    create?: XOR<VentaCreateWithoutEnviosInput, VentaUncheckedCreateWithoutEnviosInput>
    connectOrCreate?: VentaCreateOrConnectWithoutEnviosInput
    upsert?: VentaUpsertWithoutEnviosInput
    connect?: VentaWhereUniqueInput
    update?: XOR<VentaUpdateWithoutEnviosInput, VentaUncheckedUpdateWithoutEnviosInput>
  }

  export type ProductosCreateNestedManyWithoutMarcasInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutMarcasInput>, Enumerable<ProductosUncheckedCreateWithoutMarcasInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutMarcasInput>
    createMany?: ProductosCreateManyMarcasInputEnvelope
    connect?: Enumerable<ProductosWhereUniqueInput>
  }

  export type ProductosUncheckedCreateNestedManyWithoutMarcasInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutMarcasInput>, Enumerable<ProductosUncheckedCreateWithoutMarcasInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutMarcasInput>
    createMany?: ProductosCreateManyMarcasInputEnvelope
    connect?: Enumerable<ProductosWhereUniqueInput>
  }

  export type ProductosUpdateManyWithoutMarcasInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutMarcasInput>, Enumerable<ProductosUncheckedCreateWithoutMarcasInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutMarcasInput>
    upsert?: Enumerable<ProductosUpsertWithWhereUniqueWithoutMarcasInput>
    createMany?: ProductosCreateManyMarcasInputEnvelope
    set?: Enumerable<ProductosWhereUniqueInput>
    disconnect?: Enumerable<ProductosWhereUniqueInput>
    delete?: Enumerable<ProductosWhereUniqueInput>
    connect?: Enumerable<ProductosWhereUniqueInput>
    update?: Enumerable<ProductosUpdateWithWhereUniqueWithoutMarcasInput>
    updateMany?: Enumerable<ProductosUpdateManyWithWhereWithoutMarcasInput>
    deleteMany?: Enumerable<ProductosScalarWhereInput>
  }

  export type ProductosUncheckedUpdateManyWithoutMarcasInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutMarcasInput>, Enumerable<ProductosUncheckedCreateWithoutMarcasInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutMarcasInput>
    upsert?: Enumerable<ProductosUpsertWithWhereUniqueWithoutMarcasInput>
    createMany?: ProductosCreateManyMarcasInputEnvelope
    set?: Enumerable<ProductosWhereUniqueInput>
    disconnect?: Enumerable<ProductosWhereUniqueInput>
    delete?: Enumerable<ProductosWhereUniqueInput>
    connect?: Enumerable<ProductosWhereUniqueInput>
    update?: Enumerable<ProductosUpdateWithWhereUniqueWithoutMarcasInput>
    updateMany?: Enumerable<ProductosUpdateManyWithWhereWithoutMarcasInput>
    deleteMany?: Enumerable<ProductosScalarWhereInput>
  }

  export type CategoriasCreateNestedOneWithoutProductosInput = {
    create?: XOR<CategoriasCreateWithoutProductosInput, CategoriasUncheckedCreateWithoutProductosInput>
    connectOrCreate?: CategoriasCreateOrConnectWithoutProductosInput
    connect?: CategoriasWhereUniqueInput
  }

  export type MarcasCreateNestedOneWithoutProductosInput = {
    create?: XOR<MarcasCreateWithoutProductosInput, MarcasUncheckedCreateWithoutProductosInput>
    connectOrCreate?: MarcasCreateOrConnectWithoutProductosInput
    connect?: MarcasWhereUniqueInput
  }

  export type ProveedoresCreateNestedOneWithoutProductosInput = {
    create?: XOR<ProveedoresCreateWithoutProductosInput, ProveedoresUncheckedCreateWithoutProductosInput>
    connectOrCreate?: ProveedoresCreateOrConnectWithoutProductosInput
    connect?: ProveedoresWhereUniqueInput
  }

  export type CarritoItemCreateNestedManyWithoutProductosInput = {
    create?: XOR<Enumerable<CarritoItemCreateWithoutProductosInput>, Enumerable<CarritoItemUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<CarritoItemCreateOrConnectWithoutProductosInput>
    createMany?: CarritoItemCreateManyProductosInputEnvelope
    connect?: Enumerable<CarritoItemWhereUniqueInput>
  }

  export type DetalleComprasCreateNestedManyWithoutProductosInput = {
    create?: XOR<Enumerable<DetalleComprasCreateWithoutProductosInput>, Enumerable<DetalleComprasUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<DetalleComprasCreateOrConnectWithoutProductosInput>
    createMany?: DetalleComprasCreateManyProductosInputEnvelope
    connect?: Enumerable<DetalleComprasWhereUniqueInput>
  }

  export type DetallesVentasCreateNestedManyWithoutProductosInput = {
    create?: XOR<Enumerable<DetallesVentasCreateWithoutProductosInput>, Enumerable<DetallesVentasUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<DetallesVentasCreateOrConnectWithoutProductosInput>
    createMany?: DetallesVentasCreateManyProductosInputEnvelope
    connect?: Enumerable<DetallesVentasWhereUniqueInput>
  }

  export type CarritoItemUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<Enumerable<CarritoItemCreateWithoutProductosInput>, Enumerable<CarritoItemUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<CarritoItemCreateOrConnectWithoutProductosInput>
    createMany?: CarritoItemCreateManyProductosInputEnvelope
    connect?: Enumerable<CarritoItemWhereUniqueInput>
  }

  export type DetalleComprasUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<Enumerable<DetalleComprasCreateWithoutProductosInput>, Enumerable<DetalleComprasUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<DetalleComprasCreateOrConnectWithoutProductosInput>
    createMany?: DetalleComprasCreateManyProductosInputEnvelope
    connect?: Enumerable<DetalleComprasWhereUniqueInput>
  }

  export type DetallesVentasUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<Enumerable<DetallesVentasCreateWithoutProductosInput>, Enumerable<DetallesVentasUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<DetallesVentasCreateOrConnectWithoutProductosInput>
    createMany?: DetallesVentasCreateManyProductosInputEnvelope
    connect?: Enumerable<DetallesVentasWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoriasUpdateOneRequiredWithoutProductosInput = {
    create?: XOR<CategoriasCreateWithoutProductosInput, CategoriasUncheckedCreateWithoutProductosInput>
    connectOrCreate?: CategoriasCreateOrConnectWithoutProductosInput
    upsert?: CategoriasUpsertWithoutProductosInput
    connect?: CategoriasWhereUniqueInput
    update?: XOR<CategoriasUpdateWithoutProductosInput, CategoriasUncheckedUpdateWithoutProductosInput>
  }

  export type MarcasUpdateOneRequiredWithoutProductosInput = {
    create?: XOR<MarcasCreateWithoutProductosInput, MarcasUncheckedCreateWithoutProductosInput>
    connectOrCreate?: MarcasCreateOrConnectWithoutProductosInput
    upsert?: MarcasUpsertWithoutProductosInput
    connect?: MarcasWhereUniqueInput
    update?: XOR<MarcasUpdateWithoutProductosInput, MarcasUncheckedUpdateWithoutProductosInput>
  }

  export type ProveedoresUpdateOneRequiredWithoutProductosInput = {
    create?: XOR<ProveedoresCreateWithoutProductosInput, ProveedoresUncheckedCreateWithoutProductosInput>
    connectOrCreate?: ProveedoresCreateOrConnectWithoutProductosInput
    upsert?: ProveedoresUpsertWithoutProductosInput
    connect?: ProveedoresWhereUniqueInput
    update?: XOR<ProveedoresUpdateWithoutProductosInput, ProveedoresUncheckedUpdateWithoutProductosInput>
  }

  export type CarritoItemUpdateManyWithoutProductosInput = {
    create?: XOR<Enumerable<CarritoItemCreateWithoutProductosInput>, Enumerable<CarritoItemUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<CarritoItemCreateOrConnectWithoutProductosInput>
    upsert?: Enumerable<CarritoItemUpsertWithWhereUniqueWithoutProductosInput>
    createMany?: CarritoItemCreateManyProductosInputEnvelope
    set?: Enumerable<CarritoItemWhereUniqueInput>
    disconnect?: Enumerable<CarritoItemWhereUniqueInput>
    delete?: Enumerable<CarritoItemWhereUniqueInput>
    connect?: Enumerable<CarritoItemWhereUniqueInput>
    update?: Enumerable<CarritoItemUpdateWithWhereUniqueWithoutProductosInput>
    updateMany?: Enumerable<CarritoItemUpdateManyWithWhereWithoutProductosInput>
    deleteMany?: Enumerable<CarritoItemScalarWhereInput>
  }

  export type DetalleComprasUpdateManyWithoutProductosInput = {
    create?: XOR<Enumerable<DetalleComprasCreateWithoutProductosInput>, Enumerable<DetalleComprasUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<DetalleComprasCreateOrConnectWithoutProductosInput>
    upsert?: Enumerable<DetalleComprasUpsertWithWhereUniqueWithoutProductosInput>
    createMany?: DetalleComprasCreateManyProductosInputEnvelope
    set?: Enumerable<DetalleComprasWhereUniqueInput>
    disconnect?: Enumerable<DetalleComprasWhereUniqueInput>
    delete?: Enumerable<DetalleComprasWhereUniqueInput>
    connect?: Enumerable<DetalleComprasWhereUniqueInput>
    update?: Enumerable<DetalleComprasUpdateWithWhereUniqueWithoutProductosInput>
    updateMany?: Enumerable<DetalleComprasUpdateManyWithWhereWithoutProductosInput>
    deleteMany?: Enumerable<DetalleComprasScalarWhereInput>
  }

  export type DetallesVentasUpdateManyWithoutProductosInput = {
    create?: XOR<Enumerable<DetallesVentasCreateWithoutProductosInput>, Enumerable<DetallesVentasUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<DetallesVentasCreateOrConnectWithoutProductosInput>
    upsert?: Enumerable<DetallesVentasUpsertWithWhereUniqueWithoutProductosInput>
    createMany?: DetallesVentasCreateManyProductosInputEnvelope
    set?: Enumerable<DetallesVentasWhereUniqueInput>
    disconnect?: Enumerable<DetallesVentasWhereUniqueInput>
    delete?: Enumerable<DetallesVentasWhereUniqueInput>
    connect?: Enumerable<DetallesVentasWhereUniqueInput>
    update?: Enumerable<DetallesVentasUpdateWithWhereUniqueWithoutProductosInput>
    updateMany?: Enumerable<DetallesVentasUpdateManyWithWhereWithoutProductosInput>
    deleteMany?: Enumerable<DetallesVentasScalarWhereInput>
  }

  export type CarritoItemUncheckedUpdateManyWithoutProductosInput = {
    create?: XOR<Enumerable<CarritoItemCreateWithoutProductosInput>, Enumerable<CarritoItemUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<CarritoItemCreateOrConnectWithoutProductosInput>
    upsert?: Enumerable<CarritoItemUpsertWithWhereUniqueWithoutProductosInput>
    createMany?: CarritoItemCreateManyProductosInputEnvelope
    set?: Enumerable<CarritoItemWhereUniqueInput>
    disconnect?: Enumerable<CarritoItemWhereUniqueInput>
    delete?: Enumerable<CarritoItemWhereUniqueInput>
    connect?: Enumerable<CarritoItemWhereUniqueInput>
    update?: Enumerable<CarritoItemUpdateWithWhereUniqueWithoutProductosInput>
    updateMany?: Enumerable<CarritoItemUpdateManyWithWhereWithoutProductosInput>
    deleteMany?: Enumerable<CarritoItemScalarWhereInput>
  }

  export type DetalleComprasUncheckedUpdateManyWithoutProductosInput = {
    create?: XOR<Enumerable<DetalleComprasCreateWithoutProductosInput>, Enumerable<DetalleComprasUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<DetalleComprasCreateOrConnectWithoutProductosInput>
    upsert?: Enumerable<DetalleComprasUpsertWithWhereUniqueWithoutProductosInput>
    createMany?: DetalleComprasCreateManyProductosInputEnvelope
    set?: Enumerable<DetalleComprasWhereUniqueInput>
    disconnect?: Enumerable<DetalleComprasWhereUniqueInput>
    delete?: Enumerable<DetalleComprasWhereUniqueInput>
    connect?: Enumerable<DetalleComprasWhereUniqueInput>
    update?: Enumerable<DetalleComprasUpdateWithWhereUniqueWithoutProductosInput>
    updateMany?: Enumerable<DetalleComprasUpdateManyWithWhereWithoutProductosInput>
    deleteMany?: Enumerable<DetalleComprasScalarWhereInput>
  }

  export type DetallesVentasUncheckedUpdateManyWithoutProductosInput = {
    create?: XOR<Enumerable<DetallesVentasCreateWithoutProductosInput>, Enumerable<DetallesVentasUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<DetallesVentasCreateOrConnectWithoutProductosInput>
    upsert?: Enumerable<DetallesVentasUpsertWithWhereUniqueWithoutProductosInput>
    createMany?: DetallesVentasCreateManyProductosInputEnvelope
    set?: Enumerable<DetallesVentasWhereUniqueInput>
    disconnect?: Enumerable<DetallesVentasWhereUniqueInput>
    delete?: Enumerable<DetallesVentasWhereUniqueInput>
    connect?: Enumerable<DetallesVentasWhereUniqueInput>
    update?: Enumerable<DetallesVentasUpdateWithWhereUniqueWithoutProductosInput>
    updateMany?: Enumerable<DetallesVentasUpdateManyWithWhereWithoutProductosInput>
    deleteMany?: Enumerable<DetallesVentasScalarWhereInput>
  }

  export type CiudadesCreateNestedOneWithoutProveedoresInput = {
    create?: XOR<CiudadesCreateWithoutProveedoresInput, CiudadesUncheckedCreateWithoutProveedoresInput>
    connectOrCreate?: CiudadesCreateOrConnectWithoutProveedoresInput
    connect?: CiudadesWhereUniqueInput
  }

  export type ComprasCreateNestedManyWithoutProveedoresInput = {
    create?: XOR<Enumerable<ComprasCreateWithoutProveedoresInput>, Enumerable<ComprasUncheckedCreateWithoutProveedoresInput>>
    connectOrCreate?: Enumerable<ComprasCreateOrConnectWithoutProveedoresInput>
    createMany?: ComprasCreateManyProveedoresInputEnvelope
    connect?: Enumerable<ComprasWhereUniqueInput>
  }

  export type ProductosCreateNestedManyWithoutProveedoresInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutProveedoresInput>, Enumerable<ProductosUncheckedCreateWithoutProveedoresInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutProveedoresInput>
    createMany?: ProductosCreateManyProveedoresInputEnvelope
    connect?: Enumerable<ProductosWhereUniqueInput>
  }

  export type ComprasUncheckedCreateNestedManyWithoutProveedoresInput = {
    create?: XOR<Enumerable<ComprasCreateWithoutProveedoresInput>, Enumerable<ComprasUncheckedCreateWithoutProveedoresInput>>
    connectOrCreate?: Enumerable<ComprasCreateOrConnectWithoutProveedoresInput>
    createMany?: ComprasCreateManyProveedoresInputEnvelope
    connect?: Enumerable<ComprasWhereUniqueInput>
  }

  export type ProductosUncheckedCreateNestedManyWithoutProveedoresInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutProveedoresInput>, Enumerable<ProductosUncheckedCreateWithoutProveedoresInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutProveedoresInput>
    createMany?: ProductosCreateManyProveedoresInputEnvelope
    connect?: Enumerable<ProductosWhereUniqueInput>
  }

  export type CiudadesUpdateOneRequiredWithoutProveedoresInput = {
    create?: XOR<CiudadesCreateWithoutProveedoresInput, CiudadesUncheckedCreateWithoutProveedoresInput>
    connectOrCreate?: CiudadesCreateOrConnectWithoutProveedoresInput
    upsert?: CiudadesUpsertWithoutProveedoresInput
    connect?: CiudadesWhereUniqueInput
    update?: XOR<CiudadesUpdateWithoutProveedoresInput, CiudadesUncheckedUpdateWithoutProveedoresInput>
  }

  export type ComprasUpdateManyWithoutProveedoresInput = {
    create?: XOR<Enumerable<ComprasCreateWithoutProveedoresInput>, Enumerable<ComprasUncheckedCreateWithoutProveedoresInput>>
    connectOrCreate?: Enumerable<ComprasCreateOrConnectWithoutProveedoresInput>
    upsert?: Enumerable<ComprasUpsertWithWhereUniqueWithoutProveedoresInput>
    createMany?: ComprasCreateManyProveedoresInputEnvelope
    set?: Enumerable<ComprasWhereUniqueInput>
    disconnect?: Enumerable<ComprasWhereUniqueInput>
    delete?: Enumerable<ComprasWhereUniqueInput>
    connect?: Enumerable<ComprasWhereUniqueInput>
    update?: Enumerable<ComprasUpdateWithWhereUniqueWithoutProveedoresInput>
    updateMany?: Enumerable<ComprasUpdateManyWithWhereWithoutProveedoresInput>
    deleteMany?: Enumerable<ComprasScalarWhereInput>
  }

  export type ProductosUpdateManyWithoutProveedoresInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutProveedoresInput>, Enumerable<ProductosUncheckedCreateWithoutProveedoresInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutProveedoresInput>
    upsert?: Enumerable<ProductosUpsertWithWhereUniqueWithoutProveedoresInput>
    createMany?: ProductosCreateManyProveedoresInputEnvelope
    set?: Enumerable<ProductosWhereUniqueInput>
    disconnect?: Enumerable<ProductosWhereUniqueInput>
    delete?: Enumerable<ProductosWhereUniqueInput>
    connect?: Enumerable<ProductosWhereUniqueInput>
    update?: Enumerable<ProductosUpdateWithWhereUniqueWithoutProveedoresInput>
    updateMany?: Enumerable<ProductosUpdateManyWithWhereWithoutProveedoresInput>
    deleteMany?: Enumerable<ProductosScalarWhereInput>
  }

  export type ComprasUncheckedUpdateManyWithoutProveedoresInput = {
    create?: XOR<Enumerable<ComprasCreateWithoutProveedoresInput>, Enumerable<ComprasUncheckedCreateWithoutProveedoresInput>>
    connectOrCreate?: Enumerable<ComprasCreateOrConnectWithoutProveedoresInput>
    upsert?: Enumerable<ComprasUpsertWithWhereUniqueWithoutProveedoresInput>
    createMany?: ComprasCreateManyProveedoresInputEnvelope
    set?: Enumerable<ComprasWhereUniqueInput>
    disconnect?: Enumerable<ComprasWhereUniqueInput>
    delete?: Enumerable<ComprasWhereUniqueInput>
    connect?: Enumerable<ComprasWhereUniqueInput>
    update?: Enumerable<ComprasUpdateWithWhereUniqueWithoutProveedoresInput>
    updateMany?: Enumerable<ComprasUpdateManyWithWhereWithoutProveedoresInput>
    deleteMany?: Enumerable<ComprasScalarWhereInput>
  }

  export type ProductosUncheckedUpdateManyWithoutProveedoresInput = {
    create?: XOR<Enumerable<ProductosCreateWithoutProveedoresInput>, Enumerable<ProductosUncheckedCreateWithoutProveedoresInput>>
    connectOrCreate?: Enumerable<ProductosCreateOrConnectWithoutProveedoresInput>
    upsert?: Enumerable<ProductosUpsertWithWhereUniqueWithoutProveedoresInput>
    createMany?: ProductosCreateManyProveedoresInputEnvelope
    set?: Enumerable<ProductosWhereUniqueInput>
    disconnect?: Enumerable<ProductosWhereUniqueInput>
    delete?: Enumerable<ProductosWhereUniqueInput>
    connect?: Enumerable<ProductosWhereUniqueInput>
    update?: Enumerable<ProductosUpdateWithWhereUniqueWithoutProveedoresInput>
    updateMany?: Enumerable<ProductosUpdateManyWithWhereWithoutProveedoresInput>
    deleteMany?: Enumerable<ProductosScalarWhereInput>
  }

  export type EmpleadosCreateNestedManyWithoutRolesEmpleadosInput = {
    create?: XOR<Enumerable<EmpleadosCreateWithoutRolesEmpleadosInput>, Enumerable<EmpleadosUncheckedCreateWithoutRolesEmpleadosInput>>
    connectOrCreate?: Enumerable<EmpleadosCreateOrConnectWithoutRolesEmpleadosInput>
    createMany?: EmpleadosCreateManyRolesEmpleadosInputEnvelope
    connect?: Enumerable<EmpleadosWhereUniqueInput>
  }

  export type EmpleadosUncheckedCreateNestedManyWithoutRolesEmpleadosInput = {
    create?: XOR<Enumerable<EmpleadosCreateWithoutRolesEmpleadosInput>, Enumerable<EmpleadosUncheckedCreateWithoutRolesEmpleadosInput>>
    connectOrCreate?: Enumerable<EmpleadosCreateOrConnectWithoutRolesEmpleadosInput>
    createMany?: EmpleadosCreateManyRolesEmpleadosInputEnvelope
    connect?: Enumerable<EmpleadosWhereUniqueInput>
  }

  export type EmpleadosUpdateManyWithoutRolesEmpleadosInput = {
    create?: XOR<Enumerable<EmpleadosCreateWithoutRolesEmpleadosInput>, Enumerable<EmpleadosUncheckedCreateWithoutRolesEmpleadosInput>>
    connectOrCreate?: Enumerable<EmpleadosCreateOrConnectWithoutRolesEmpleadosInput>
    upsert?: Enumerable<EmpleadosUpsertWithWhereUniqueWithoutRolesEmpleadosInput>
    createMany?: EmpleadosCreateManyRolesEmpleadosInputEnvelope
    set?: Enumerable<EmpleadosWhereUniqueInput>
    disconnect?: Enumerable<EmpleadosWhereUniqueInput>
    delete?: Enumerable<EmpleadosWhereUniqueInput>
    connect?: Enumerable<EmpleadosWhereUniqueInput>
    update?: Enumerable<EmpleadosUpdateWithWhereUniqueWithoutRolesEmpleadosInput>
    updateMany?: Enumerable<EmpleadosUpdateManyWithWhereWithoutRolesEmpleadosInput>
    deleteMany?: Enumerable<EmpleadosScalarWhereInput>
  }

  export type EmpleadosUncheckedUpdateManyWithoutRolesEmpleadosInput = {
    create?: XOR<Enumerable<EmpleadosCreateWithoutRolesEmpleadosInput>, Enumerable<EmpleadosUncheckedCreateWithoutRolesEmpleadosInput>>
    connectOrCreate?: Enumerable<EmpleadosCreateOrConnectWithoutRolesEmpleadosInput>
    upsert?: Enumerable<EmpleadosUpsertWithWhereUniqueWithoutRolesEmpleadosInput>
    createMany?: EmpleadosCreateManyRolesEmpleadosInputEnvelope
    set?: Enumerable<EmpleadosWhereUniqueInput>
    disconnect?: Enumerable<EmpleadosWhereUniqueInput>
    delete?: Enumerable<EmpleadosWhereUniqueInput>
    connect?: Enumerable<EmpleadosWhereUniqueInput>
    update?: Enumerable<EmpleadosUpdateWithWhereUniqueWithoutRolesEmpleadosInput>
    updateMany?: Enumerable<EmpleadosUpdateManyWithWhereWithoutRolesEmpleadosInput>
    deleteMany?: Enumerable<EmpleadosScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type EmpleadosCreateNestedOneWithoutUsuarioEmpleadosInput = {
    create?: XOR<EmpleadosCreateWithoutUsuarioEmpleadosInput, EmpleadosUncheckedCreateWithoutUsuarioEmpleadosInput>
    connectOrCreate?: EmpleadosCreateOrConnectWithoutUsuarioEmpleadosInput
    connect?: EmpleadosWhereUniqueInput
  }

  export type EmpleadosUpdateOneRequiredWithoutUsuarioEmpleadosInput = {
    create?: XOR<EmpleadosCreateWithoutUsuarioEmpleadosInput, EmpleadosUncheckedCreateWithoutUsuarioEmpleadosInput>
    connectOrCreate?: EmpleadosCreateOrConnectWithoutUsuarioEmpleadosInput
    upsert?: EmpleadosUpsertWithoutUsuarioEmpleadosInput
    connect?: EmpleadosWhereUniqueInput
    update?: XOR<EmpleadosUpdateWithoutUsuarioEmpleadosInput, EmpleadosUncheckedUpdateWithoutUsuarioEmpleadosInput>
  }

  export type ClientesCreateNestedOneWithoutUsuariosClientesInput = {
    create?: XOR<ClientesCreateWithoutUsuariosClientesInput, ClientesUncheckedCreateWithoutUsuariosClientesInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutUsuariosClientesInput
    connect?: ClientesWhereUniqueInput
  }

  export type CarritoCreateNestedManyWithoutUsuariosClientesInput = {
    create?: XOR<Enumerable<CarritoCreateWithoutUsuariosClientesInput>, Enumerable<CarritoUncheckedCreateWithoutUsuariosClientesInput>>
    connectOrCreate?: Enumerable<CarritoCreateOrConnectWithoutUsuariosClientesInput>
    createMany?: CarritoCreateManyUsuariosClientesInputEnvelope
    connect?: Enumerable<CarritoWhereUniqueInput>
  }

  export type DireccionesEnvioCreateNestedManyWithoutUsuariosClientesInput = {
    create?: XOR<Enumerable<DireccionesEnvioCreateWithoutUsuariosClientesInput>, Enumerable<DireccionesEnvioUncheckedCreateWithoutUsuariosClientesInput>>
    connectOrCreate?: Enumerable<DireccionesEnvioCreateOrConnectWithoutUsuariosClientesInput>
    createMany?: DireccionesEnvioCreateManyUsuariosClientesInputEnvelope
    connect?: Enumerable<DireccionesEnvioWhereUniqueInput>
  }

  export type CarritoUncheckedCreateNestedManyWithoutUsuariosClientesInput = {
    create?: XOR<Enumerable<CarritoCreateWithoutUsuariosClientesInput>, Enumerable<CarritoUncheckedCreateWithoutUsuariosClientesInput>>
    connectOrCreate?: Enumerable<CarritoCreateOrConnectWithoutUsuariosClientesInput>
    createMany?: CarritoCreateManyUsuariosClientesInputEnvelope
    connect?: Enumerable<CarritoWhereUniqueInput>
  }

  export type DireccionesEnvioUncheckedCreateNestedManyWithoutUsuariosClientesInput = {
    create?: XOR<Enumerable<DireccionesEnvioCreateWithoutUsuariosClientesInput>, Enumerable<DireccionesEnvioUncheckedCreateWithoutUsuariosClientesInput>>
    connectOrCreate?: Enumerable<DireccionesEnvioCreateOrConnectWithoutUsuariosClientesInput>
    createMany?: DireccionesEnvioCreateManyUsuariosClientesInputEnvelope
    connect?: Enumerable<DireccionesEnvioWhereUniqueInput>
  }

  export type ClientesUpdateOneRequiredWithoutUsuariosClientesInput = {
    create?: XOR<ClientesCreateWithoutUsuariosClientesInput, ClientesUncheckedCreateWithoutUsuariosClientesInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutUsuariosClientesInput
    upsert?: ClientesUpsertWithoutUsuariosClientesInput
    connect?: ClientesWhereUniqueInput
    update?: XOR<ClientesUpdateWithoutUsuariosClientesInput, ClientesUncheckedUpdateWithoutUsuariosClientesInput>
  }

  export type CarritoUpdateManyWithoutUsuariosClientesInput = {
    create?: XOR<Enumerable<CarritoCreateWithoutUsuariosClientesInput>, Enumerable<CarritoUncheckedCreateWithoutUsuariosClientesInput>>
    connectOrCreate?: Enumerable<CarritoCreateOrConnectWithoutUsuariosClientesInput>
    upsert?: Enumerable<CarritoUpsertWithWhereUniqueWithoutUsuariosClientesInput>
    createMany?: CarritoCreateManyUsuariosClientesInputEnvelope
    set?: Enumerable<CarritoWhereUniqueInput>
    disconnect?: Enumerable<CarritoWhereUniqueInput>
    delete?: Enumerable<CarritoWhereUniqueInput>
    connect?: Enumerable<CarritoWhereUniqueInput>
    update?: Enumerable<CarritoUpdateWithWhereUniqueWithoutUsuariosClientesInput>
    updateMany?: Enumerable<CarritoUpdateManyWithWhereWithoutUsuariosClientesInput>
    deleteMany?: Enumerable<CarritoScalarWhereInput>
  }

  export type DireccionesEnvioUpdateManyWithoutUsuariosClientesInput = {
    create?: XOR<Enumerable<DireccionesEnvioCreateWithoutUsuariosClientesInput>, Enumerable<DireccionesEnvioUncheckedCreateWithoutUsuariosClientesInput>>
    connectOrCreate?: Enumerable<DireccionesEnvioCreateOrConnectWithoutUsuariosClientesInput>
    upsert?: Enumerable<DireccionesEnvioUpsertWithWhereUniqueWithoutUsuariosClientesInput>
    createMany?: DireccionesEnvioCreateManyUsuariosClientesInputEnvelope
    set?: Enumerable<DireccionesEnvioWhereUniqueInput>
    disconnect?: Enumerable<DireccionesEnvioWhereUniqueInput>
    delete?: Enumerable<DireccionesEnvioWhereUniqueInput>
    connect?: Enumerable<DireccionesEnvioWhereUniqueInput>
    update?: Enumerable<DireccionesEnvioUpdateWithWhereUniqueWithoutUsuariosClientesInput>
    updateMany?: Enumerable<DireccionesEnvioUpdateManyWithWhereWithoutUsuariosClientesInput>
    deleteMany?: Enumerable<DireccionesEnvioScalarWhereInput>
  }

  export type CarritoUncheckedUpdateManyWithoutUsuariosClientesInput = {
    create?: XOR<Enumerable<CarritoCreateWithoutUsuariosClientesInput>, Enumerable<CarritoUncheckedCreateWithoutUsuariosClientesInput>>
    connectOrCreate?: Enumerable<CarritoCreateOrConnectWithoutUsuariosClientesInput>
    upsert?: Enumerable<CarritoUpsertWithWhereUniqueWithoutUsuariosClientesInput>
    createMany?: CarritoCreateManyUsuariosClientesInputEnvelope
    set?: Enumerable<CarritoWhereUniqueInput>
    disconnect?: Enumerable<CarritoWhereUniqueInput>
    delete?: Enumerable<CarritoWhereUniqueInput>
    connect?: Enumerable<CarritoWhereUniqueInput>
    update?: Enumerable<CarritoUpdateWithWhereUniqueWithoutUsuariosClientesInput>
    updateMany?: Enumerable<CarritoUpdateManyWithWhereWithoutUsuariosClientesInput>
    deleteMany?: Enumerable<CarritoScalarWhereInput>
  }

  export type DireccionesEnvioUncheckedUpdateManyWithoutUsuariosClientesInput = {
    create?: XOR<Enumerable<DireccionesEnvioCreateWithoutUsuariosClientesInput>, Enumerable<DireccionesEnvioUncheckedCreateWithoutUsuariosClientesInput>>
    connectOrCreate?: Enumerable<DireccionesEnvioCreateOrConnectWithoutUsuariosClientesInput>
    upsert?: Enumerable<DireccionesEnvioUpsertWithWhereUniqueWithoutUsuariosClientesInput>
    createMany?: DireccionesEnvioCreateManyUsuariosClientesInputEnvelope
    set?: Enumerable<DireccionesEnvioWhereUniqueInput>
    disconnect?: Enumerable<DireccionesEnvioWhereUniqueInput>
    delete?: Enumerable<DireccionesEnvioWhereUniqueInput>
    connect?: Enumerable<DireccionesEnvioWhereUniqueInput>
    update?: Enumerable<DireccionesEnvioUpdateWithWhereUniqueWithoutUsuariosClientesInput>
    updateMany?: Enumerable<DireccionesEnvioUpdateManyWithWhereWithoutUsuariosClientesInput>
    deleteMany?: Enumerable<DireccionesEnvioScalarWhereInput>
  }

  export type ClientesCreateNestedOneWithoutVentaInput = {
    create?: XOR<ClientesCreateWithoutVentaInput, ClientesUncheckedCreateWithoutVentaInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutVentaInput
    connect?: ClientesWhereUniqueInput
  }

  export type DireccionesEnvioCreateNestedOneWithoutVentaInput = {
    create?: XOR<DireccionesEnvioCreateWithoutVentaInput, DireccionesEnvioUncheckedCreateWithoutVentaInput>
    connectOrCreate?: DireccionesEnvioCreateOrConnectWithoutVentaInput
    connect?: DireccionesEnvioWhereUniqueInput
  }

  export type DetallesVentasCreateNestedManyWithoutVentaInput = {
    create?: XOR<Enumerable<DetallesVentasCreateWithoutVentaInput>, Enumerable<DetallesVentasUncheckedCreateWithoutVentaInput>>
    connectOrCreate?: Enumerable<DetallesVentasCreateOrConnectWithoutVentaInput>
    createMany?: DetallesVentasCreateManyVentaInputEnvelope
    connect?: Enumerable<DetallesVentasWhereUniqueInput>
  }

  export type EnviosCreateNestedManyWithoutVentaInput = {
    create?: XOR<Enumerable<EnviosCreateWithoutVentaInput>, Enumerable<EnviosUncheckedCreateWithoutVentaInput>>
    connectOrCreate?: Enumerable<EnviosCreateOrConnectWithoutVentaInput>
    createMany?: EnviosCreateManyVentaInputEnvelope
    connect?: Enumerable<EnviosWhereUniqueInput>
  }

  export type DetallesVentasUncheckedCreateNestedManyWithoutVentaInput = {
    create?: XOR<Enumerable<DetallesVentasCreateWithoutVentaInput>, Enumerable<DetallesVentasUncheckedCreateWithoutVentaInput>>
    connectOrCreate?: Enumerable<DetallesVentasCreateOrConnectWithoutVentaInput>
    createMany?: DetallesVentasCreateManyVentaInputEnvelope
    connect?: Enumerable<DetallesVentasWhereUniqueInput>
  }

  export type EnviosUncheckedCreateNestedManyWithoutVentaInput = {
    create?: XOR<Enumerable<EnviosCreateWithoutVentaInput>, Enumerable<EnviosUncheckedCreateWithoutVentaInput>>
    connectOrCreate?: Enumerable<EnviosCreateOrConnectWithoutVentaInput>
    createMany?: EnviosCreateManyVentaInputEnvelope
    connect?: Enumerable<EnviosWhereUniqueInput>
  }

  export type ClientesUpdateOneRequiredWithoutVentaInput = {
    create?: XOR<ClientesCreateWithoutVentaInput, ClientesUncheckedCreateWithoutVentaInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutVentaInput
    upsert?: ClientesUpsertWithoutVentaInput
    connect?: ClientesWhereUniqueInput
    update?: XOR<ClientesUpdateWithoutVentaInput, ClientesUncheckedUpdateWithoutVentaInput>
  }

  export type DireccionesEnvioUpdateOneRequiredWithoutVentaInput = {
    create?: XOR<DireccionesEnvioCreateWithoutVentaInput, DireccionesEnvioUncheckedCreateWithoutVentaInput>
    connectOrCreate?: DireccionesEnvioCreateOrConnectWithoutVentaInput
    upsert?: DireccionesEnvioUpsertWithoutVentaInput
    connect?: DireccionesEnvioWhereUniqueInput
    update?: XOR<DireccionesEnvioUpdateWithoutVentaInput, DireccionesEnvioUncheckedUpdateWithoutVentaInput>
  }

  export type DetallesVentasUpdateManyWithoutVentaInput = {
    create?: XOR<Enumerable<DetallesVentasCreateWithoutVentaInput>, Enumerable<DetallesVentasUncheckedCreateWithoutVentaInput>>
    connectOrCreate?: Enumerable<DetallesVentasCreateOrConnectWithoutVentaInput>
    upsert?: Enumerable<DetallesVentasUpsertWithWhereUniqueWithoutVentaInput>
    createMany?: DetallesVentasCreateManyVentaInputEnvelope
    set?: Enumerable<DetallesVentasWhereUniqueInput>
    disconnect?: Enumerable<DetallesVentasWhereUniqueInput>
    delete?: Enumerable<DetallesVentasWhereUniqueInput>
    connect?: Enumerable<DetallesVentasWhereUniqueInput>
    update?: Enumerable<DetallesVentasUpdateWithWhereUniqueWithoutVentaInput>
    updateMany?: Enumerable<DetallesVentasUpdateManyWithWhereWithoutVentaInput>
    deleteMany?: Enumerable<DetallesVentasScalarWhereInput>
  }

  export type EnviosUpdateManyWithoutVentaInput = {
    create?: XOR<Enumerable<EnviosCreateWithoutVentaInput>, Enumerable<EnviosUncheckedCreateWithoutVentaInput>>
    connectOrCreate?: Enumerable<EnviosCreateOrConnectWithoutVentaInput>
    upsert?: Enumerable<EnviosUpsertWithWhereUniqueWithoutVentaInput>
    createMany?: EnviosCreateManyVentaInputEnvelope
    set?: Enumerable<EnviosWhereUniqueInput>
    disconnect?: Enumerable<EnviosWhereUniqueInput>
    delete?: Enumerable<EnviosWhereUniqueInput>
    connect?: Enumerable<EnviosWhereUniqueInput>
    update?: Enumerable<EnviosUpdateWithWhereUniqueWithoutVentaInput>
    updateMany?: Enumerable<EnviosUpdateManyWithWhereWithoutVentaInput>
    deleteMany?: Enumerable<EnviosScalarWhereInput>
  }

  export type DetallesVentasUncheckedUpdateManyWithoutVentaInput = {
    create?: XOR<Enumerable<DetallesVentasCreateWithoutVentaInput>, Enumerable<DetallesVentasUncheckedCreateWithoutVentaInput>>
    connectOrCreate?: Enumerable<DetallesVentasCreateOrConnectWithoutVentaInput>
    upsert?: Enumerable<DetallesVentasUpsertWithWhereUniqueWithoutVentaInput>
    createMany?: DetallesVentasCreateManyVentaInputEnvelope
    set?: Enumerable<DetallesVentasWhereUniqueInput>
    disconnect?: Enumerable<DetallesVentasWhereUniqueInput>
    delete?: Enumerable<DetallesVentasWhereUniqueInput>
    connect?: Enumerable<DetallesVentasWhereUniqueInput>
    update?: Enumerable<DetallesVentasUpdateWithWhereUniqueWithoutVentaInput>
    updateMany?: Enumerable<DetallesVentasUpdateManyWithWhereWithoutVentaInput>
    deleteMany?: Enumerable<DetallesVentasScalarWhereInput>
  }

  export type EnviosUncheckedUpdateManyWithoutVentaInput = {
    create?: XOR<Enumerable<EnviosCreateWithoutVentaInput>, Enumerable<EnviosUncheckedCreateWithoutVentaInput>>
    connectOrCreate?: Enumerable<EnviosCreateOrConnectWithoutVentaInput>
    upsert?: Enumerable<EnviosUpsertWithWhereUniqueWithoutVentaInput>
    createMany?: EnviosCreateManyVentaInputEnvelope
    set?: Enumerable<EnviosWhereUniqueInput>
    disconnect?: Enumerable<EnviosWhereUniqueInput>
    delete?: Enumerable<EnviosWhereUniqueInput>
    connect?: Enumerable<EnviosWhereUniqueInput>
    update?: Enumerable<EnviosUpdateWithWhereUniqueWithoutVentaInput>
    updateMany?: Enumerable<EnviosUpdateManyWithWhereWithoutVentaInput>
    deleteMany?: Enumerable<EnviosScalarWhereInput>
  }

  export type usuariosClientesCreateNestedOneWithoutCarritoInput = {
    create?: XOR<usuariosClientesCreateWithoutCarritoInput, usuariosClientesUncheckedCreateWithoutCarritoInput>
    connectOrCreate?: usuariosClientesCreateOrConnectWithoutCarritoInput
    connect?: usuariosClientesWhereUniqueInput
  }

  export type CarritoItemCreateNestedManyWithoutCarritoInput = {
    create?: XOR<Enumerable<CarritoItemCreateWithoutCarritoInput>, Enumerable<CarritoItemUncheckedCreateWithoutCarritoInput>>
    connectOrCreate?: Enumerable<CarritoItemCreateOrConnectWithoutCarritoInput>
    createMany?: CarritoItemCreateManyCarritoInputEnvelope
    connect?: Enumerable<CarritoItemWhereUniqueInput>
  }

  export type CarritoItemUncheckedCreateNestedManyWithoutCarritoInput = {
    create?: XOR<Enumerable<CarritoItemCreateWithoutCarritoInput>, Enumerable<CarritoItemUncheckedCreateWithoutCarritoInput>>
    connectOrCreate?: Enumerable<CarritoItemCreateOrConnectWithoutCarritoInput>
    createMany?: CarritoItemCreateManyCarritoInputEnvelope
    connect?: Enumerable<CarritoItemWhereUniqueInput>
  }

  export type usuariosClientesUpdateOneRequiredWithoutCarritoInput = {
    create?: XOR<usuariosClientesCreateWithoutCarritoInput, usuariosClientesUncheckedCreateWithoutCarritoInput>
    connectOrCreate?: usuariosClientesCreateOrConnectWithoutCarritoInput
    upsert?: usuariosClientesUpsertWithoutCarritoInput
    connect?: usuariosClientesWhereUniqueInput
    update?: XOR<usuariosClientesUpdateWithoutCarritoInput, usuariosClientesUncheckedUpdateWithoutCarritoInput>
  }

  export type CarritoItemUpdateManyWithoutCarritoInput = {
    create?: XOR<Enumerable<CarritoItemCreateWithoutCarritoInput>, Enumerable<CarritoItemUncheckedCreateWithoutCarritoInput>>
    connectOrCreate?: Enumerable<CarritoItemCreateOrConnectWithoutCarritoInput>
    upsert?: Enumerable<CarritoItemUpsertWithWhereUniqueWithoutCarritoInput>
    createMany?: CarritoItemCreateManyCarritoInputEnvelope
    set?: Enumerable<CarritoItemWhereUniqueInput>
    disconnect?: Enumerable<CarritoItemWhereUniqueInput>
    delete?: Enumerable<CarritoItemWhereUniqueInput>
    connect?: Enumerable<CarritoItemWhereUniqueInput>
    update?: Enumerable<CarritoItemUpdateWithWhereUniqueWithoutCarritoInput>
    updateMany?: Enumerable<CarritoItemUpdateManyWithWhereWithoutCarritoInput>
    deleteMany?: Enumerable<CarritoItemScalarWhereInput>
  }

  export type CarritoItemUncheckedUpdateManyWithoutCarritoInput = {
    create?: XOR<Enumerable<CarritoItemCreateWithoutCarritoInput>, Enumerable<CarritoItemUncheckedCreateWithoutCarritoInput>>
    connectOrCreate?: Enumerable<CarritoItemCreateOrConnectWithoutCarritoInput>
    upsert?: Enumerable<CarritoItemUpsertWithWhereUniqueWithoutCarritoInput>
    createMany?: CarritoItemCreateManyCarritoInputEnvelope
    set?: Enumerable<CarritoItemWhereUniqueInput>
    disconnect?: Enumerable<CarritoItemWhereUniqueInput>
    delete?: Enumerable<CarritoItemWhereUniqueInput>
    connect?: Enumerable<CarritoItemWhereUniqueInput>
    update?: Enumerable<CarritoItemUpdateWithWhereUniqueWithoutCarritoInput>
    updateMany?: Enumerable<CarritoItemUpdateManyWithWhereWithoutCarritoInput>
    deleteMany?: Enumerable<CarritoItemScalarWhereInput>
  }

  export type CarritoCreateNestedOneWithoutCarritoItemInput = {
    create?: XOR<CarritoCreateWithoutCarritoItemInput, CarritoUncheckedCreateWithoutCarritoItemInput>
    connectOrCreate?: CarritoCreateOrConnectWithoutCarritoItemInput
    connect?: CarritoWhereUniqueInput
  }

  export type ProductosCreateNestedOneWithoutCarritoItemInput = {
    create?: XOR<ProductosCreateWithoutCarritoItemInput, ProductosUncheckedCreateWithoutCarritoItemInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutCarritoItemInput
    connect?: ProductosWhereUniqueInput
  }

  export type CarritoUpdateOneRequiredWithoutCarritoItemInput = {
    create?: XOR<CarritoCreateWithoutCarritoItemInput, CarritoUncheckedCreateWithoutCarritoItemInput>
    connectOrCreate?: CarritoCreateOrConnectWithoutCarritoItemInput
    upsert?: CarritoUpsertWithoutCarritoItemInput
    connect?: CarritoWhereUniqueInput
    update?: XOR<CarritoUpdateWithoutCarritoItemInput, CarritoUncheckedUpdateWithoutCarritoItemInput>
  }

  export type ProductosUpdateOneRequiredWithoutCarritoItemInput = {
    create?: XOR<ProductosCreateWithoutCarritoItemInput, ProductosUncheckedCreateWithoutCarritoItemInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutCarritoItemInput
    upsert?: ProductosUpsertWithoutCarritoItemInput
    connect?: ProductosWhereUniqueInput
    update?: XOR<ProductosUpdateWithoutCarritoItemInput, ProductosUncheckedUpdateWithoutCarritoItemInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedBytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedBytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type ProductosCreateWithoutCategoriasInput = {
    descripcion_producto: string
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    Marcas: MarcasCreateNestedOneWithoutProductosInput
    Proveedores: ProveedoresCreateNestedOneWithoutProductosInput
    CarritoItem?: CarritoItemCreateNestedManyWithoutProductosInput
    DetalleCompras?: DetalleComprasCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutCategoriasInput = {
    id_producto?: number
    descripcion_producto: string
    id_marca: number
    id_proveedor: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    CarritoItem?: CarritoItemUncheckedCreateNestedManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUncheckedCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutCategoriasInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutCategoriasInput, ProductosUncheckedCreateWithoutCategoriasInput>
  }

  export type ProductosCreateManyCategoriasInputEnvelope = {
    data: Enumerable<ProductosCreateManyCategoriasInput>
  }

  export type ProductosUpsertWithWhereUniqueWithoutCategoriasInput = {
    where: ProductosWhereUniqueInput
    update: XOR<ProductosUpdateWithoutCategoriasInput, ProductosUncheckedUpdateWithoutCategoriasInput>
    create: XOR<ProductosCreateWithoutCategoriasInput, ProductosUncheckedCreateWithoutCategoriasInput>
  }

  export type ProductosUpdateWithWhereUniqueWithoutCategoriasInput = {
    where: ProductosWhereUniqueInput
    data: XOR<ProductosUpdateWithoutCategoriasInput, ProductosUncheckedUpdateWithoutCategoriasInput>
  }

  export type ProductosUpdateManyWithWhereWithoutCategoriasInput = {
    where: ProductosScalarWhereInput
    data: XOR<ProductosUpdateManyMutationInput, ProductosUncheckedUpdateManyWithoutProductosInput>
  }

  export type ProductosScalarWhereInput = {
    AND?: Enumerable<ProductosScalarWhereInput>
    OR?: Enumerable<ProductosScalarWhereInput>
    NOT?: Enumerable<ProductosScalarWhereInput>
    id_producto?: IntFilter | number
    descripcion_producto?: StringFilter | string
    id_marca?: IntFilter | number
    id_categoria?: IntFilter | number
    id_proveedor?: IntFilter | number
    cantidad_por_unidad?: StringFilter | string
    costo_producto?: FloatFilter | number
    precio_actual?: FloatFilter | number
    stock?: FloatFilter | number
    descuento?: FloatNullableFilter | number | null
    estado?: BoolFilter | boolean
    imagen?: StringNullableFilter | string | null
  }

  export type DepartamentosCreateWithoutCiudadesInput = {
    nombreDepartamento: string
  }

  export type DepartamentosUncheckedCreateWithoutCiudadesInput = {
    id_departamento?: number
    nombreDepartamento: string
  }

  export type DepartamentosCreateOrConnectWithoutCiudadesInput = {
    where: DepartamentosWhereUniqueInput
    create: XOR<DepartamentosCreateWithoutCiudadesInput, DepartamentosUncheckedCreateWithoutCiudadesInput>
  }

  export type ClientesCreateWithoutCiudadesInput = {
    nom_cliente: string
    apellido_cliente: string
    RTN?: string | null
    direccion_cliente: string
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
    usuariosClientes?: usuariosClientesCreateNestedManyWithoutClientesInput
    Venta?: VentaCreateNestedManyWithoutClientesInput
  }

  export type ClientesUncheckedCreateWithoutCiudadesInput = {
    id_cliente?: number
    nom_cliente: string
    apellido_cliente: string
    RTN?: string | null
    direccion_cliente: string
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
    usuariosClientes?: usuariosClientesUncheckedCreateNestedManyWithoutClientesInput
    Venta?: VentaUncheckedCreateNestedManyWithoutClientesInput
  }

  export type ClientesCreateOrConnectWithoutCiudadesInput = {
    where: ClientesWhereUniqueInput
    create: XOR<ClientesCreateWithoutCiudadesInput, ClientesUncheckedCreateWithoutCiudadesInput>
  }

  export type ClientesCreateManyCiudadesInputEnvelope = {
    data: Enumerable<ClientesCreateManyCiudadesInput>
  }

  export type DireccionesEnvioCreateWithoutCiudadesInput = {
    direccion: string
    direccion_opcional: string
    usuariosClientes: usuariosClientesCreateNestedOneWithoutDireccionesEnvioInput
    Venta?: VentaCreateNestedManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioUncheckedCreateWithoutCiudadesInput = {
    id_direccionEnvio?: number
    direccion: string
    id_usuarioCliente: number
    direccion_opcional: string
    Venta?: VentaUncheckedCreateNestedManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioCreateOrConnectWithoutCiudadesInput = {
    where: DireccionesEnvioWhereUniqueInput
    create: XOR<DireccionesEnvioCreateWithoutCiudadesInput, DireccionesEnvioUncheckedCreateWithoutCiudadesInput>
  }

  export type DireccionesEnvioCreateManyCiudadesInputEnvelope = {
    data: Enumerable<DireccionesEnvioCreateManyCiudadesInput>
  }

  export type EmpleadosCreateWithoutCiudadesInput = {
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    fnacimiento_empleado: number
    Estado: boolean
    RolesEmpleados: RolesEmpleadosCreateNestedOneWithoutEmpleadosInput
    Compras?: ComprasCreateNestedManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosCreateNestedManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedCreateWithoutCiudadesInput = {
    id_empleado?: number
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    id_rol: number
    fnacimiento_empleado: number
    Estado: boolean
    Compras?: ComprasUncheckedCreateNestedManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosUncheckedCreateNestedManyWithoutEmpleadosInput
  }

  export type EmpleadosCreateOrConnectWithoutCiudadesInput = {
    where: EmpleadosWhereUniqueInput
    create: XOR<EmpleadosCreateWithoutCiudadesInput, EmpleadosUncheckedCreateWithoutCiudadesInput>
  }

  export type EmpleadosCreateManyCiudadesInputEnvelope = {
    data: Enumerable<EmpleadosCreateManyCiudadesInput>
  }

  export type EmpresasEnvioCreateWithoutCiudadesInput = {
    nombre_empresa: string
    direccion_empresa: string
    telefono_empresa: string
    estado: boolean
    correo_empresa: string
    Envios?: EnviosCreateNestedManyWithoutEmpresasEnvioInput
  }

  export type EmpresasEnvioUncheckedCreateWithoutCiudadesInput = {
    id_empresaEnvio?: number
    nombre_empresa: string
    direccion_empresa: string
    telefono_empresa: string
    estado: boolean
    correo_empresa: string
    Envios?: EnviosUncheckedCreateNestedManyWithoutEmpresasEnvioInput
  }

  export type EmpresasEnvioCreateOrConnectWithoutCiudadesInput = {
    where: EmpresasEnvioWhereUniqueInput
    create: XOR<EmpresasEnvioCreateWithoutCiudadesInput, EmpresasEnvioUncheckedCreateWithoutCiudadesInput>
  }

  export type EmpresasEnvioCreateManyCiudadesInputEnvelope = {
    data: Enumerable<EmpresasEnvioCreateManyCiudadesInput>
  }

  export type ProveedoresCreateWithoutCiudadesInput = {
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    Estado: boolean
    Compras?: ComprasCreateNestedManyWithoutProveedoresInput
    Productos?: ProductosCreateNestedManyWithoutProveedoresInput
  }

  export type ProveedoresUncheckedCreateWithoutCiudadesInput = {
    id_prov?: number
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    Estado: boolean
    Compras?: ComprasUncheckedCreateNestedManyWithoutProveedoresInput
    Productos?: ProductosUncheckedCreateNestedManyWithoutProveedoresInput
  }

  export type ProveedoresCreateOrConnectWithoutCiudadesInput = {
    where: ProveedoresWhereUniqueInput
    create: XOR<ProveedoresCreateWithoutCiudadesInput, ProveedoresUncheckedCreateWithoutCiudadesInput>
  }

  export type ProveedoresCreateManyCiudadesInputEnvelope = {
    data: Enumerable<ProveedoresCreateManyCiudadesInput>
  }

  export type DepartamentosUpsertWithoutCiudadesInput = {
    update: XOR<DepartamentosUpdateWithoutCiudadesInput, DepartamentosUncheckedUpdateWithoutCiudadesInput>
    create: XOR<DepartamentosCreateWithoutCiudadesInput, DepartamentosUncheckedCreateWithoutCiudadesInput>
  }

  export type DepartamentosUpdateWithoutCiudadesInput = {
    nombreDepartamento?: StringFieldUpdateOperationsInput | string
  }

  export type DepartamentosUncheckedUpdateWithoutCiudadesInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombreDepartamento?: StringFieldUpdateOperationsInput | string
  }

  export type ClientesUpsertWithWhereUniqueWithoutCiudadesInput = {
    where: ClientesWhereUniqueInput
    update: XOR<ClientesUpdateWithoutCiudadesInput, ClientesUncheckedUpdateWithoutCiudadesInput>
    create: XOR<ClientesCreateWithoutCiudadesInput, ClientesUncheckedCreateWithoutCiudadesInput>
  }

  export type ClientesUpdateWithWhereUniqueWithoutCiudadesInput = {
    where: ClientesWhereUniqueInput
    data: XOR<ClientesUpdateWithoutCiudadesInput, ClientesUncheckedUpdateWithoutCiudadesInput>
  }

  export type ClientesUpdateManyWithWhereWithoutCiudadesInput = {
    where: ClientesScalarWhereInput
    data: XOR<ClientesUpdateManyMutationInput, ClientesUncheckedUpdateManyWithoutClientesInput>
  }

  export type ClientesScalarWhereInput = {
    AND?: Enumerable<ClientesScalarWhereInput>
    OR?: Enumerable<ClientesScalarWhereInput>
    NOT?: Enumerable<ClientesScalarWhereInput>
    id_cliente?: IntFilter | number
    nom_cliente?: StringFilter | string
    apellido_cliente?: StringFilter | string
    RTN?: StringNullableFilter | string | null
    direccion_cliente?: StringFilter | string
    id_ciudad?: IntFilter | number
    tel_cliente?: StringFilter | string
    estado?: BoolFilter | boolean
    DNI_Cliente?: StringFilter | string
  }

  export type DireccionesEnvioUpsertWithWhereUniqueWithoutCiudadesInput = {
    where: DireccionesEnvioWhereUniqueInput
    update: XOR<DireccionesEnvioUpdateWithoutCiudadesInput, DireccionesEnvioUncheckedUpdateWithoutCiudadesInput>
    create: XOR<DireccionesEnvioCreateWithoutCiudadesInput, DireccionesEnvioUncheckedCreateWithoutCiudadesInput>
  }

  export type DireccionesEnvioUpdateWithWhereUniqueWithoutCiudadesInput = {
    where: DireccionesEnvioWhereUniqueInput
    data: XOR<DireccionesEnvioUpdateWithoutCiudadesInput, DireccionesEnvioUncheckedUpdateWithoutCiudadesInput>
  }

  export type DireccionesEnvioUpdateManyWithWhereWithoutCiudadesInput = {
    where: DireccionesEnvioScalarWhereInput
    data: XOR<DireccionesEnvioUpdateManyMutationInput, DireccionesEnvioUncheckedUpdateManyWithoutDireccionesEnvioInput>
  }

  export type DireccionesEnvioScalarWhereInput = {
    AND?: Enumerable<DireccionesEnvioScalarWhereInput>
    OR?: Enumerable<DireccionesEnvioScalarWhereInput>
    NOT?: Enumerable<DireccionesEnvioScalarWhereInput>
    id_direccionEnvio?: IntFilter | number
    direccion?: StringFilter | string
    id_ciudad?: IntFilter | number
    id_usuarioCliente?: IntFilter | number
    direccion_opcional?: StringFilter | string
  }

  export type EmpleadosUpsertWithWhereUniqueWithoutCiudadesInput = {
    where: EmpleadosWhereUniqueInput
    update: XOR<EmpleadosUpdateWithoutCiudadesInput, EmpleadosUncheckedUpdateWithoutCiudadesInput>
    create: XOR<EmpleadosCreateWithoutCiudadesInput, EmpleadosUncheckedCreateWithoutCiudadesInput>
  }

  export type EmpleadosUpdateWithWhereUniqueWithoutCiudadesInput = {
    where: EmpleadosWhereUniqueInput
    data: XOR<EmpleadosUpdateWithoutCiudadesInput, EmpleadosUncheckedUpdateWithoutCiudadesInput>
  }

  export type EmpleadosUpdateManyWithWhereWithoutCiudadesInput = {
    where: EmpleadosScalarWhereInput
    data: XOR<EmpleadosUpdateManyMutationInput, EmpleadosUncheckedUpdateManyWithoutEmpleadosInput>
  }

  export type EmpleadosScalarWhereInput = {
    AND?: Enumerable<EmpleadosScalarWhereInput>
    OR?: Enumerable<EmpleadosScalarWhereInput>
    NOT?: Enumerable<EmpleadosScalarWhereInput>
    id_empleado?: IntFilter | number
    nom_empleado?: StringFilter | string
    apellido_empleado?: StringFilter | string
    telefono_empleado?: StringFilter | string
    direccion_empleado?: StringFilter | string
    id_ciudad?: IntFilter | number
    id_rol?: IntFilter | number
    fnacimiento_empleado?: IntFilter | number
    Estado?: BoolFilter | boolean
  }

  export type EmpresasEnvioUpsertWithWhereUniqueWithoutCiudadesInput = {
    where: EmpresasEnvioWhereUniqueInput
    update: XOR<EmpresasEnvioUpdateWithoutCiudadesInput, EmpresasEnvioUncheckedUpdateWithoutCiudadesInput>
    create: XOR<EmpresasEnvioCreateWithoutCiudadesInput, EmpresasEnvioUncheckedCreateWithoutCiudadesInput>
  }

  export type EmpresasEnvioUpdateWithWhereUniqueWithoutCiudadesInput = {
    where: EmpresasEnvioWhereUniqueInput
    data: XOR<EmpresasEnvioUpdateWithoutCiudadesInput, EmpresasEnvioUncheckedUpdateWithoutCiudadesInput>
  }

  export type EmpresasEnvioUpdateManyWithWhereWithoutCiudadesInput = {
    where: EmpresasEnvioScalarWhereInput
    data: XOR<EmpresasEnvioUpdateManyMutationInput, EmpresasEnvioUncheckedUpdateManyWithoutEmpresasEnvioInput>
  }

  export type EmpresasEnvioScalarWhereInput = {
    AND?: Enumerable<EmpresasEnvioScalarWhereInput>
    OR?: Enumerable<EmpresasEnvioScalarWhereInput>
    NOT?: Enumerable<EmpresasEnvioScalarWhereInput>
    id_empresaEnvio?: IntFilter | number
    nombre_empresa?: StringFilter | string
    direccion_empresa?: StringFilter | string
    telefono_empresa?: StringFilter | string
    id_ciudad?: IntFilter | number
    estado?: BoolFilter | boolean
    correo_empresa?: StringFilter | string
  }

  export type ProveedoresUpsertWithWhereUniqueWithoutCiudadesInput = {
    where: ProveedoresWhereUniqueInput
    update: XOR<ProveedoresUpdateWithoutCiudadesInput, ProveedoresUncheckedUpdateWithoutCiudadesInput>
    create: XOR<ProveedoresCreateWithoutCiudadesInput, ProveedoresUncheckedCreateWithoutCiudadesInput>
  }

  export type ProveedoresUpdateWithWhereUniqueWithoutCiudadesInput = {
    where: ProveedoresWhereUniqueInput
    data: XOR<ProveedoresUpdateWithoutCiudadesInput, ProveedoresUncheckedUpdateWithoutCiudadesInput>
  }

  export type ProveedoresUpdateManyWithWhereWithoutCiudadesInput = {
    where: ProveedoresScalarWhereInput
    data: XOR<ProveedoresUpdateManyMutationInput, ProveedoresUncheckedUpdateManyWithoutProveedoresInput>
  }

  export type ProveedoresScalarWhereInput = {
    AND?: Enumerable<ProveedoresScalarWhereInput>
    OR?: Enumerable<ProveedoresScalarWhereInput>
    NOT?: Enumerable<ProveedoresScalarWhereInput>
    id_prov?: IntFilter | number
    nom_prov?: StringFilter | string
    telefono_prov?: StringFilter | string
    correo_prov?: StringFilter | string
    direccion_prov?: StringFilter | string
    id_ciudad?: IntFilter | number
    Estado?: BoolFilter | boolean
  }

  export type CiudadesCreateWithoutClientesInput = {
    nombre_ciudad: string
    codigoPostal: string
    Departamentos: DepartamentosCreateNestedOneWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedCreateWithoutClientesInput = {
    id_ciudad?: number
    nombre_ciudad: string
    codigoPostal: string
    id_departamento: number
    DireccionesEnvio?: DireccionesEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesCreateOrConnectWithoutClientesInput = {
    where: CiudadesWhereUniqueInput
    create: XOR<CiudadesCreateWithoutClientesInput, CiudadesUncheckedCreateWithoutClientesInput>
  }

  export type usuariosClientesCreateWithoutClientesInput = {
    nombre_usuario: string
    contraenia_usuario: string
    correo_usuario: string
    estado: boolean
    Carrito?: CarritoCreateNestedManyWithoutUsuariosClientesInput
    DireccionesEnvio?: DireccionesEnvioCreateNestedManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesUncheckedCreateWithoutClientesInput = {
    id_usuarioCliente?: number
    nombre_usuario: string
    contraenia_usuario: string
    correo_usuario: string
    estado: boolean
    Carrito?: CarritoUncheckedCreateNestedManyWithoutUsuariosClientesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedCreateNestedManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesCreateOrConnectWithoutClientesInput = {
    where: usuariosClientesWhereUniqueInput
    create: XOR<usuariosClientesCreateWithoutClientesInput, usuariosClientesUncheckedCreateWithoutClientesInput>
  }

  export type usuariosClientesCreateManyClientesInputEnvelope = {
    data: Enumerable<usuariosClientesCreateManyClientesInput>
  }

  export type VentaCreateWithoutClientesInput = {
    fecha: Date | string
    RTN_estado: boolean
    ISV: number
    descuento: number
    DireccionesEnvio: DireccionesEnvioCreateNestedOneWithoutVentaInput
    DetallesVentas?: DetallesVentasCreateNestedManyWithoutVentaInput
    Envios?: EnviosCreateNestedManyWithoutVentaInput
  }

  export type VentaUncheckedCreateWithoutClientesInput = {
    id_Venta?: number
    fecha: Date | string
    RTN_estado: boolean
    ISV: number
    id_direccionEnvio: number
    descuento: number
    DetallesVentas?: DetallesVentasUncheckedCreateNestedManyWithoutVentaInput
    Envios?: EnviosUncheckedCreateNestedManyWithoutVentaInput
  }

  export type VentaCreateOrConnectWithoutClientesInput = {
    where: VentaWhereUniqueInput
    create: XOR<VentaCreateWithoutClientesInput, VentaUncheckedCreateWithoutClientesInput>
  }

  export type VentaCreateManyClientesInputEnvelope = {
    data: Enumerable<VentaCreateManyClientesInput>
  }

  export type CiudadesUpsertWithoutClientesInput = {
    update: XOR<CiudadesUpdateWithoutClientesInput, CiudadesUncheckedUpdateWithoutClientesInput>
    create: XOR<CiudadesCreateWithoutClientesInput, CiudadesUncheckedCreateWithoutClientesInput>
  }

  export type CiudadesUpdateWithoutClientesInput = {
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    Departamentos?: DepartamentosUpdateOneRequiredWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUpdateManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedUpdateWithoutClientesInput = {
    id_ciudad?: IntFieldUpdateOperationsInput | number
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    id_departamento?: IntFieldUpdateOperationsInput | number
    DireccionesEnvio?: DireccionesEnvioUncheckedUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedUpdateManyWithoutCiudadesInput
  }

  export type usuariosClientesUpsertWithWhereUniqueWithoutClientesInput = {
    where: usuariosClientesWhereUniqueInput
    update: XOR<usuariosClientesUpdateWithoutClientesInput, usuariosClientesUncheckedUpdateWithoutClientesInput>
    create: XOR<usuariosClientesCreateWithoutClientesInput, usuariosClientesUncheckedCreateWithoutClientesInput>
  }

  export type usuariosClientesUpdateWithWhereUniqueWithoutClientesInput = {
    where: usuariosClientesWhereUniqueInput
    data: XOR<usuariosClientesUpdateWithoutClientesInput, usuariosClientesUncheckedUpdateWithoutClientesInput>
  }

  export type usuariosClientesUpdateManyWithWhereWithoutClientesInput = {
    where: usuariosClientesScalarWhereInput
    data: XOR<usuariosClientesUpdateManyMutationInput, usuariosClientesUncheckedUpdateManyWithoutUsuariosClientesInput>
  }

  export type usuariosClientesScalarWhereInput = {
    AND?: Enumerable<usuariosClientesScalarWhereInput>
    OR?: Enumerable<usuariosClientesScalarWhereInput>
    NOT?: Enumerable<usuariosClientesScalarWhereInput>
    id_usuarioCliente?: IntFilter | number
    nombre_usuario?: StringFilter | string
    contraenia_usuario?: StringFilter | string
    id_cliente?: IntFilter | number
    correo_usuario?: StringFilter | string
    estado?: BoolFilter | boolean
  }

  export type VentaUpsertWithWhereUniqueWithoutClientesInput = {
    where: VentaWhereUniqueInput
    update: XOR<VentaUpdateWithoutClientesInput, VentaUncheckedUpdateWithoutClientesInput>
    create: XOR<VentaCreateWithoutClientesInput, VentaUncheckedCreateWithoutClientesInput>
  }

  export type VentaUpdateWithWhereUniqueWithoutClientesInput = {
    where: VentaWhereUniqueInput
    data: XOR<VentaUpdateWithoutClientesInput, VentaUncheckedUpdateWithoutClientesInput>
  }

  export type VentaUpdateManyWithWhereWithoutClientesInput = {
    where: VentaScalarWhereInput
    data: XOR<VentaUpdateManyMutationInput, VentaUncheckedUpdateManyWithoutVentaInput>
  }

  export type VentaScalarWhereInput = {
    AND?: Enumerable<VentaScalarWhereInput>
    OR?: Enumerable<VentaScalarWhereInput>
    NOT?: Enumerable<VentaScalarWhereInput>
    id_Venta?: IntFilter | number
    fecha?: DateTimeFilter | Date | string
    id_cliente?: IntFilter | number
    RTN_estado?: BoolFilter | boolean
    ISV?: FloatFilter | number
    id_direccionEnvio?: IntFilter | number
    descuento?: FloatFilter | number
  }

  export type EmpleadosCreateWithoutComprasInput = {
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    fnacimiento_empleado: number
    Estado: boolean
    Ciudades: CiudadesCreateNestedOneWithoutEmpleadosInput
    RolesEmpleados: RolesEmpleadosCreateNestedOneWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosCreateNestedManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedCreateWithoutComprasInput = {
    id_empleado?: number
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    id_ciudad: number
    id_rol: number
    fnacimiento_empleado: number
    Estado: boolean
    UsuarioEmpleados?: UsuarioEmpleadosUncheckedCreateNestedManyWithoutEmpleadosInput
  }

  export type EmpleadosCreateOrConnectWithoutComprasInput = {
    where: EmpleadosWhereUniqueInput
    create: XOR<EmpleadosCreateWithoutComprasInput, EmpleadosUncheckedCreateWithoutComprasInput>
  }

  export type ProveedoresCreateWithoutComprasInput = {
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    Estado: boolean
    Ciudades: CiudadesCreateNestedOneWithoutProveedoresInput
    Productos?: ProductosCreateNestedManyWithoutProveedoresInput
  }

  export type ProveedoresUncheckedCreateWithoutComprasInput = {
    id_prov?: number
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    id_ciudad: number
    Estado: boolean
    Productos?: ProductosUncheckedCreateNestedManyWithoutProveedoresInput
  }

  export type ProveedoresCreateOrConnectWithoutComprasInput = {
    where: ProveedoresWhereUniqueInput
    create: XOR<ProveedoresCreateWithoutComprasInput, ProveedoresUncheckedCreateWithoutComprasInput>
  }

  export type DetalleComprasCreateWithoutComprasInput = {
    precio: number
    cantidad: number
    Productos: ProductosCreateNestedOneWithoutDetalleComprasInput
  }

  export type DetalleComprasUncheckedCreateWithoutComprasInput = {
    id_detalleCompra?: number
    id_producto: number
    precio: number
    cantidad: number
  }

  export type DetalleComprasCreateOrConnectWithoutComprasInput = {
    where: DetalleComprasWhereUniqueInput
    create: XOR<DetalleComprasCreateWithoutComprasInput, DetalleComprasUncheckedCreateWithoutComprasInput>
  }

  export type DetalleComprasCreateManyComprasInputEnvelope = {
    data: Enumerable<DetalleComprasCreateManyComprasInput>
  }

  export type EmpleadosUpsertWithoutComprasInput = {
    update: XOR<EmpleadosUpdateWithoutComprasInput, EmpleadosUncheckedUpdateWithoutComprasInput>
    create: XOR<EmpleadosCreateWithoutComprasInput, EmpleadosUncheckedCreateWithoutComprasInput>
  }

  export type EmpleadosUpdateWithoutComprasInput = {
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Ciudades?: CiudadesUpdateOneRequiredWithoutEmpleadosInput
    RolesEmpleados?: RolesEmpleadosUpdateOneRequiredWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosUpdateManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedUpdateWithoutComprasInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    id_rol?: IntFieldUpdateOperationsInput | number
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    UsuarioEmpleados?: UsuarioEmpleadosUncheckedUpdateManyWithoutEmpleadosInput
  }

  export type ProveedoresUpsertWithoutComprasInput = {
    update: XOR<ProveedoresUpdateWithoutComprasInput, ProveedoresUncheckedUpdateWithoutComprasInput>
    create: XOR<ProveedoresCreateWithoutComprasInput, ProveedoresUncheckedCreateWithoutComprasInput>
  }

  export type ProveedoresUpdateWithoutComprasInput = {
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Ciudades?: CiudadesUpdateOneRequiredWithoutProveedoresInput
    Productos?: ProductosUpdateManyWithoutProveedoresInput
  }

  export type ProveedoresUncheckedUpdateWithoutComprasInput = {
    id_prov?: IntFieldUpdateOperationsInput | number
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Productos?: ProductosUncheckedUpdateManyWithoutProveedoresInput
  }

  export type DetalleComprasUpsertWithWhereUniqueWithoutComprasInput = {
    where: DetalleComprasWhereUniqueInput
    update: XOR<DetalleComprasUpdateWithoutComprasInput, DetalleComprasUncheckedUpdateWithoutComprasInput>
    create: XOR<DetalleComprasCreateWithoutComprasInput, DetalleComprasUncheckedCreateWithoutComprasInput>
  }

  export type DetalleComprasUpdateWithWhereUniqueWithoutComprasInput = {
    where: DetalleComprasWhereUniqueInput
    data: XOR<DetalleComprasUpdateWithoutComprasInput, DetalleComprasUncheckedUpdateWithoutComprasInput>
  }

  export type DetalleComprasUpdateManyWithWhereWithoutComprasInput = {
    where: DetalleComprasScalarWhereInput
    data: XOR<DetalleComprasUpdateManyMutationInput, DetalleComprasUncheckedUpdateManyWithoutDetalleComprasInput>
  }

  export type DetalleComprasScalarWhereInput = {
    AND?: Enumerable<DetalleComprasScalarWhereInput>
    OR?: Enumerable<DetalleComprasScalarWhereInput>
    NOT?: Enumerable<DetalleComprasScalarWhereInput>
    id_detalleCompra?: IntFilter | number
    id_producto?: IntFilter | number
    id_compra?: IntFilter | number
    precio?: FloatFilter | number
    cantidad?: FloatFilter | number
  }

  export type CiudadesCreateWithoutDepartamentosInput = {
    nombre_ciudad: string
    codigoPostal: string
    Clientes?: ClientesCreateNestedManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedCreateWithoutDepartamentosInput = {
    id_ciudad?: number
    nombre_ciudad: string
    codigoPostal: string
    Clientes?: ClientesUncheckedCreateNestedManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesCreateOrConnectWithoutDepartamentosInput = {
    where: CiudadesWhereUniqueInput
    create: XOR<CiudadesCreateWithoutDepartamentosInput, CiudadesUncheckedCreateWithoutDepartamentosInput>
  }

  export type CiudadesCreateManyDepartamentosInputEnvelope = {
    data: Enumerable<CiudadesCreateManyDepartamentosInput>
  }

  export type CiudadesUpsertWithWhereUniqueWithoutDepartamentosInput = {
    where: CiudadesWhereUniqueInput
    update: XOR<CiudadesUpdateWithoutDepartamentosInput, CiudadesUncheckedUpdateWithoutDepartamentosInput>
    create: XOR<CiudadesCreateWithoutDepartamentosInput, CiudadesUncheckedCreateWithoutDepartamentosInput>
  }

  export type CiudadesUpdateWithWhereUniqueWithoutDepartamentosInput = {
    where: CiudadesWhereUniqueInput
    data: XOR<CiudadesUpdateWithoutDepartamentosInput, CiudadesUncheckedUpdateWithoutDepartamentosInput>
  }

  export type CiudadesUpdateManyWithWhereWithoutDepartamentosInput = {
    where: CiudadesScalarWhereInput
    data: XOR<CiudadesUpdateManyMutationInput, CiudadesUncheckedUpdateManyWithoutCiudadesInput>
  }

  export type CiudadesScalarWhereInput = {
    AND?: Enumerable<CiudadesScalarWhereInput>
    OR?: Enumerable<CiudadesScalarWhereInput>
    NOT?: Enumerable<CiudadesScalarWhereInput>
    id_ciudad?: IntFilter | number
    nombre_ciudad?: StringFilter | string
    codigoPostal?: StringFilter | string
    id_departamento?: IntFilter | number
  }

  export type ComprasCreateWithoutDetalleComprasInput = {
    fecha_compra: Date | string
    isv: number
    descuento: number
    Empleados: EmpleadosCreateNestedOneWithoutComprasInput
    Proveedores: ProveedoresCreateNestedOneWithoutComprasInput
  }

  export type ComprasUncheckedCreateWithoutDetalleComprasInput = {
    id_compra?: number
    fecha_compra: Date | string
    id_prov: number
    id_empleado: number
    isv: number
    descuento: number
  }

  export type ComprasCreateOrConnectWithoutDetalleComprasInput = {
    where: ComprasWhereUniqueInput
    create: XOR<ComprasCreateWithoutDetalleComprasInput, ComprasUncheckedCreateWithoutDetalleComprasInput>
  }

  export type ProductosCreateWithoutDetalleComprasInput = {
    descripcion_producto: string
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    Categorias: CategoriasCreateNestedOneWithoutProductosInput
    Marcas: MarcasCreateNestedOneWithoutProductosInput
    Proveedores: ProveedoresCreateNestedOneWithoutProductosInput
    CarritoItem?: CarritoItemCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutDetalleComprasInput = {
    id_producto?: number
    descripcion_producto: string
    id_marca: number
    id_categoria: number
    id_proveedor: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    CarritoItem?: CarritoItemUncheckedCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutDetalleComprasInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutDetalleComprasInput, ProductosUncheckedCreateWithoutDetalleComprasInput>
  }

  export type ComprasUpsertWithoutDetalleComprasInput = {
    update: XOR<ComprasUpdateWithoutDetalleComprasInput, ComprasUncheckedUpdateWithoutDetalleComprasInput>
    create: XOR<ComprasCreateWithoutDetalleComprasInput, ComprasUncheckedCreateWithoutDetalleComprasInput>
  }

  export type ComprasUpdateWithoutDetalleComprasInput = {
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    Empleados?: EmpleadosUpdateOneRequiredWithoutComprasInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutComprasInput
  }

  export type ComprasUncheckedUpdateWithoutDetalleComprasInput = {
    id_compra?: IntFieldUpdateOperationsInput | number
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    id_prov?: IntFieldUpdateOperationsInput | number
    id_empleado?: IntFieldUpdateOperationsInput | number
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
  }

  export type ProductosUpsertWithoutDetalleComprasInput = {
    update: XOR<ProductosUpdateWithoutDetalleComprasInput, ProductosUncheckedUpdateWithoutDetalleComprasInput>
    create: XOR<ProductosCreateWithoutDetalleComprasInput, ProductosUncheckedCreateWithoutDetalleComprasInput>
  }

  export type ProductosUpdateWithoutDetalleComprasInput = {
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    Categorias?: CategoriasUpdateOneRequiredWithoutProductosInput
    Marcas?: MarcasUpdateOneRequiredWithoutProductosInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutProductosInput
    CarritoItem?: CarritoItemUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUpdateManyWithoutProductosInput
  }

  export type ProductosUncheckedUpdateWithoutDetalleComprasInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    id_marca?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_proveedor?: IntFieldUpdateOperationsInput | number
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    CarritoItem?: CarritoItemUncheckedUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedUpdateManyWithoutProductosInput
  }

  export type ProductosCreateWithoutDetallesVentasInput = {
    descripcion_producto: string
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    Categorias: CategoriasCreateNestedOneWithoutProductosInput
    Marcas: MarcasCreateNestedOneWithoutProductosInput
    Proveedores: ProveedoresCreateNestedOneWithoutProductosInput
    CarritoItem?: CarritoItemCreateNestedManyWithoutProductosInput
    DetalleCompras?: DetalleComprasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutDetallesVentasInput = {
    id_producto?: number
    descripcion_producto: string
    id_marca: number
    id_categoria: number
    id_proveedor: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    CarritoItem?: CarritoItemUncheckedCreateNestedManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutDetallesVentasInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutDetallesVentasInput, ProductosUncheckedCreateWithoutDetallesVentasInput>
  }

  export type VentaCreateWithoutDetallesVentasInput = {
    fecha: Date | string
    RTN_estado: boolean
    ISV: number
    descuento: number
    Clientes: ClientesCreateNestedOneWithoutVentaInput
    DireccionesEnvio: DireccionesEnvioCreateNestedOneWithoutVentaInput
    Envios?: EnviosCreateNestedManyWithoutVentaInput
  }

  export type VentaUncheckedCreateWithoutDetallesVentasInput = {
    id_Venta?: number
    fecha: Date | string
    id_cliente: number
    RTN_estado: boolean
    ISV: number
    id_direccionEnvio: number
    descuento: number
    Envios?: EnviosUncheckedCreateNestedManyWithoutVentaInput
  }

  export type VentaCreateOrConnectWithoutDetallesVentasInput = {
    where: VentaWhereUniqueInput
    create: XOR<VentaCreateWithoutDetallesVentasInput, VentaUncheckedCreateWithoutDetallesVentasInput>
  }

  export type ProductosUpsertWithoutDetallesVentasInput = {
    update: XOR<ProductosUpdateWithoutDetallesVentasInput, ProductosUncheckedUpdateWithoutDetallesVentasInput>
    create: XOR<ProductosCreateWithoutDetallesVentasInput, ProductosUncheckedCreateWithoutDetallesVentasInput>
  }

  export type ProductosUpdateWithoutDetallesVentasInput = {
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    Categorias?: CategoriasUpdateOneRequiredWithoutProductosInput
    Marcas?: MarcasUpdateOneRequiredWithoutProductosInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutProductosInput
    CarritoItem?: CarritoItemUpdateManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUpdateManyWithoutProductosInput
  }

  export type ProductosUncheckedUpdateWithoutDetallesVentasInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    id_marca?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_proveedor?: IntFieldUpdateOperationsInput | number
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    CarritoItem?: CarritoItemUncheckedUpdateManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUncheckedUpdateManyWithoutProductosInput
  }

  export type VentaUpsertWithoutDetallesVentasInput = {
    update: XOR<VentaUpdateWithoutDetallesVentasInput, VentaUncheckedUpdateWithoutDetallesVentasInput>
    create: XOR<VentaCreateWithoutDetallesVentasInput, VentaUncheckedCreateWithoutDetallesVentasInput>
  }

  export type VentaUpdateWithoutDetallesVentasInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    Clientes?: ClientesUpdateOneRequiredWithoutVentaInput
    DireccionesEnvio?: DireccionesEnvioUpdateOneRequiredWithoutVentaInput
    Envios?: EnviosUpdateManyWithoutVentaInput
  }

  export type VentaUncheckedUpdateWithoutDetallesVentasInput = {
    id_Venta?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    Envios?: EnviosUncheckedUpdateManyWithoutVentaInput
  }

  export type CiudadesCreateWithoutDireccionesEnvioInput = {
    nombre_ciudad: string
    codigoPostal: string
    Departamentos: DepartamentosCreateNestedOneWithoutCiudadesInput
    Clientes?: ClientesCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedCreateWithoutDireccionesEnvioInput = {
    id_ciudad?: number
    nombre_ciudad: string
    codigoPostal: string
    id_departamento: number
    Clientes?: ClientesUncheckedCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesCreateOrConnectWithoutDireccionesEnvioInput = {
    where: CiudadesWhereUniqueInput
    create: XOR<CiudadesCreateWithoutDireccionesEnvioInput, CiudadesUncheckedCreateWithoutDireccionesEnvioInput>
  }

  export type usuariosClientesCreateWithoutDireccionesEnvioInput = {
    nombre_usuario: string
    contraenia_usuario: string
    correo_usuario: string
    estado: boolean
    Clientes: ClientesCreateNestedOneWithoutUsuariosClientesInput
    Carrito?: CarritoCreateNestedManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesUncheckedCreateWithoutDireccionesEnvioInput = {
    id_usuarioCliente?: number
    nombre_usuario: string
    contraenia_usuario: string
    id_cliente: number
    correo_usuario: string
    estado: boolean
    Carrito?: CarritoUncheckedCreateNestedManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesCreateOrConnectWithoutDireccionesEnvioInput = {
    where: usuariosClientesWhereUniqueInput
    create: XOR<usuariosClientesCreateWithoutDireccionesEnvioInput, usuariosClientesUncheckedCreateWithoutDireccionesEnvioInput>
  }

  export type VentaCreateWithoutDireccionesEnvioInput = {
    fecha: Date | string
    RTN_estado: boolean
    ISV: number
    descuento: number
    Clientes: ClientesCreateNestedOneWithoutVentaInput
    DetallesVentas?: DetallesVentasCreateNestedManyWithoutVentaInput
    Envios?: EnviosCreateNestedManyWithoutVentaInput
  }

  export type VentaUncheckedCreateWithoutDireccionesEnvioInput = {
    id_Venta?: number
    fecha: Date | string
    id_cliente: number
    RTN_estado: boolean
    ISV: number
    descuento: number
    DetallesVentas?: DetallesVentasUncheckedCreateNestedManyWithoutVentaInput
    Envios?: EnviosUncheckedCreateNestedManyWithoutVentaInput
  }

  export type VentaCreateOrConnectWithoutDireccionesEnvioInput = {
    where: VentaWhereUniqueInput
    create: XOR<VentaCreateWithoutDireccionesEnvioInput, VentaUncheckedCreateWithoutDireccionesEnvioInput>
  }

  export type VentaCreateManyDireccionesEnvioInputEnvelope = {
    data: Enumerable<VentaCreateManyDireccionesEnvioInput>
  }

  export type CiudadesUpsertWithoutDireccionesEnvioInput = {
    update: XOR<CiudadesUpdateWithoutDireccionesEnvioInput, CiudadesUncheckedUpdateWithoutDireccionesEnvioInput>
    create: XOR<CiudadesCreateWithoutDireccionesEnvioInput, CiudadesUncheckedCreateWithoutDireccionesEnvioInput>
  }

  export type CiudadesUpdateWithoutDireccionesEnvioInput = {
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    Departamentos?: DepartamentosUpdateOneRequiredWithoutCiudadesInput
    Clientes?: ClientesUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUpdateManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedUpdateWithoutDireccionesEnvioInput = {
    id_ciudad?: IntFieldUpdateOperationsInput | number
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    id_departamento?: IntFieldUpdateOperationsInput | number
    Clientes?: ClientesUncheckedUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedUpdateManyWithoutCiudadesInput
  }

  export type usuariosClientesUpsertWithoutDireccionesEnvioInput = {
    update: XOR<usuariosClientesUpdateWithoutDireccionesEnvioInput, usuariosClientesUncheckedUpdateWithoutDireccionesEnvioInput>
    create: XOR<usuariosClientesCreateWithoutDireccionesEnvioInput, usuariosClientesUncheckedCreateWithoutDireccionesEnvioInput>
  }

  export type usuariosClientesUpdateWithoutDireccionesEnvioInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Clientes?: ClientesUpdateOneRequiredWithoutUsuariosClientesInput
    Carrito?: CarritoUpdateManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesUncheckedUpdateWithoutDireccionesEnvioInput = {
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Carrito?: CarritoUncheckedUpdateManyWithoutUsuariosClientesInput
  }

  export type VentaUpsertWithWhereUniqueWithoutDireccionesEnvioInput = {
    where: VentaWhereUniqueInput
    update: XOR<VentaUpdateWithoutDireccionesEnvioInput, VentaUncheckedUpdateWithoutDireccionesEnvioInput>
    create: XOR<VentaCreateWithoutDireccionesEnvioInput, VentaUncheckedCreateWithoutDireccionesEnvioInput>
  }

  export type VentaUpdateWithWhereUniqueWithoutDireccionesEnvioInput = {
    where: VentaWhereUniqueInput
    data: XOR<VentaUpdateWithoutDireccionesEnvioInput, VentaUncheckedUpdateWithoutDireccionesEnvioInput>
  }

  export type VentaUpdateManyWithWhereWithoutDireccionesEnvioInput = {
    where: VentaScalarWhereInput
    data: XOR<VentaUpdateManyMutationInput, VentaUncheckedUpdateManyWithoutVentaInput>
  }

  export type CiudadesCreateWithoutEmpleadosInput = {
    nombre_ciudad: string
    codigoPostal: string
    Departamentos: DepartamentosCreateNestedOneWithoutCiudadesInput
    Clientes?: ClientesCreateNestedManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedCreateWithoutEmpleadosInput = {
    id_ciudad?: number
    nombre_ciudad: string
    codigoPostal: string
    id_departamento: number
    Clientes?: ClientesUncheckedCreateNestedManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesCreateOrConnectWithoutEmpleadosInput = {
    where: CiudadesWhereUniqueInput
    create: XOR<CiudadesCreateWithoutEmpleadosInput, CiudadesUncheckedCreateWithoutEmpleadosInput>
  }

  export type RolesEmpleadosCreateWithoutEmpleadosInput = {
    descripcion: string
  }

  export type RolesEmpleadosUncheckedCreateWithoutEmpleadosInput = {
    id_rol?: number
    descripcion: string
  }

  export type RolesEmpleadosCreateOrConnectWithoutEmpleadosInput = {
    where: RolesEmpleadosWhereUniqueInput
    create: XOR<RolesEmpleadosCreateWithoutEmpleadosInput, RolesEmpleadosUncheckedCreateWithoutEmpleadosInput>
  }

  export type ComprasCreateWithoutEmpleadosInput = {
    fecha_compra: Date | string
    isv: number
    descuento: number
    Proveedores: ProveedoresCreateNestedOneWithoutComprasInput
    DetalleCompras?: DetalleComprasCreateNestedManyWithoutComprasInput
  }

  export type ComprasUncheckedCreateWithoutEmpleadosInput = {
    id_compra?: number
    fecha_compra: Date | string
    id_prov: number
    isv: number
    descuento: number
    DetalleCompras?: DetalleComprasUncheckedCreateNestedManyWithoutComprasInput
  }

  export type ComprasCreateOrConnectWithoutEmpleadosInput = {
    where: ComprasWhereUniqueInput
    create: XOR<ComprasCreateWithoutEmpleadosInput, ComprasUncheckedCreateWithoutEmpleadosInput>
  }

  export type ComprasCreateManyEmpleadosInputEnvelope = {
    data: Enumerable<ComprasCreateManyEmpleadosInput>
  }

  export type UsuarioEmpleadosCreateWithoutEmpleadosInput = {
    nom_usuarioEmpleado: string
    estado: boolean
    contrasenia_empleado: string
    correo_empleado: string
  }

  export type UsuarioEmpleadosUncheckedCreateWithoutEmpleadosInput = {
    id_usuarioEmpleado?: number
    nom_usuarioEmpleado: string
    estado: boolean
    contrasenia_empleado: string
    correo_empleado: string
  }

  export type UsuarioEmpleadosCreateOrConnectWithoutEmpleadosInput = {
    where: UsuarioEmpleadosWhereUniqueInput
    create: XOR<UsuarioEmpleadosCreateWithoutEmpleadosInput, UsuarioEmpleadosUncheckedCreateWithoutEmpleadosInput>
  }

  export type UsuarioEmpleadosCreateManyEmpleadosInputEnvelope = {
    data: Enumerable<UsuarioEmpleadosCreateManyEmpleadosInput>
  }

  export type CiudadesUpsertWithoutEmpleadosInput = {
    update: XOR<CiudadesUpdateWithoutEmpleadosInput, CiudadesUncheckedUpdateWithoutEmpleadosInput>
    create: XOR<CiudadesCreateWithoutEmpleadosInput, CiudadesUncheckedCreateWithoutEmpleadosInput>
  }

  export type CiudadesUpdateWithoutEmpleadosInput = {
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    Departamentos?: DepartamentosUpdateOneRequiredWithoutCiudadesInput
    Clientes?: ClientesUpdateManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUpdateManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedUpdateWithoutEmpleadosInput = {
    id_ciudad?: IntFieldUpdateOperationsInput | number
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    id_departamento?: IntFieldUpdateOperationsInput | number
    Clientes?: ClientesUncheckedUpdateManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedUpdateManyWithoutCiudadesInput
  }

  export type RolesEmpleadosUpsertWithoutEmpleadosInput = {
    update: XOR<RolesEmpleadosUpdateWithoutEmpleadosInput, RolesEmpleadosUncheckedUpdateWithoutEmpleadosInput>
    create: XOR<RolesEmpleadosCreateWithoutEmpleadosInput, RolesEmpleadosUncheckedCreateWithoutEmpleadosInput>
  }

  export type RolesEmpleadosUpdateWithoutEmpleadosInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type RolesEmpleadosUncheckedUpdateWithoutEmpleadosInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type ComprasUpsertWithWhereUniqueWithoutEmpleadosInput = {
    where: ComprasWhereUniqueInput
    update: XOR<ComprasUpdateWithoutEmpleadosInput, ComprasUncheckedUpdateWithoutEmpleadosInput>
    create: XOR<ComprasCreateWithoutEmpleadosInput, ComprasUncheckedCreateWithoutEmpleadosInput>
  }

  export type ComprasUpdateWithWhereUniqueWithoutEmpleadosInput = {
    where: ComprasWhereUniqueInput
    data: XOR<ComprasUpdateWithoutEmpleadosInput, ComprasUncheckedUpdateWithoutEmpleadosInput>
  }

  export type ComprasUpdateManyWithWhereWithoutEmpleadosInput = {
    where: ComprasScalarWhereInput
    data: XOR<ComprasUpdateManyMutationInput, ComprasUncheckedUpdateManyWithoutComprasInput>
  }

  export type ComprasScalarWhereInput = {
    AND?: Enumerable<ComprasScalarWhereInput>
    OR?: Enumerable<ComprasScalarWhereInput>
    NOT?: Enumerable<ComprasScalarWhereInput>
    id_compra?: IntFilter | number
    fecha_compra?: DateTimeFilter | Date | string
    id_prov?: IntFilter | number
    id_empleado?: IntFilter | number
    isv?: FloatFilter | number
    descuento?: FloatFilter | number
  }

  export type UsuarioEmpleadosUpsertWithWhereUniqueWithoutEmpleadosInput = {
    where: UsuarioEmpleadosWhereUniqueInput
    update: XOR<UsuarioEmpleadosUpdateWithoutEmpleadosInput, UsuarioEmpleadosUncheckedUpdateWithoutEmpleadosInput>
    create: XOR<UsuarioEmpleadosCreateWithoutEmpleadosInput, UsuarioEmpleadosUncheckedCreateWithoutEmpleadosInput>
  }

  export type UsuarioEmpleadosUpdateWithWhereUniqueWithoutEmpleadosInput = {
    where: UsuarioEmpleadosWhereUniqueInput
    data: XOR<UsuarioEmpleadosUpdateWithoutEmpleadosInput, UsuarioEmpleadosUncheckedUpdateWithoutEmpleadosInput>
  }

  export type UsuarioEmpleadosUpdateManyWithWhereWithoutEmpleadosInput = {
    where: UsuarioEmpleadosScalarWhereInput
    data: XOR<UsuarioEmpleadosUpdateManyMutationInput, UsuarioEmpleadosUncheckedUpdateManyWithoutUsuarioEmpleadosInput>
  }

  export type UsuarioEmpleadosScalarWhereInput = {
    AND?: Enumerable<UsuarioEmpleadosScalarWhereInput>
    OR?: Enumerable<UsuarioEmpleadosScalarWhereInput>
    NOT?: Enumerable<UsuarioEmpleadosScalarWhereInput>
    id_usuarioEmpleado?: IntFilter | number
    nom_usuarioEmpleado?: StringFilter | string
    estado?: BoolFilter | boolean
    contrasenia_empleado?: StringFilter | string
    correo_empleado?: StringFilter | string
    id_empleado?: IntFilter | number
  }

  export type CiudadesCreateWithoutEmpresasEnvioInput = {
    nombre_ciudad: string
    codigoPostal: string
    Departamentos: DepartamentosCreateNestedOneWithoutCiudadesInput
    Clientes?: ClientesCreateNestedManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedCreateWithoutEmpresasEnvioInput = {
    id_ciudad?: number
    nombre_ciudad: string
    codigoPostal: string
    id_departamento: number
    Clientes?: ClientesUncheckedCreateNestedManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedCreateNestedManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesCreateOrConnectWithoutEmpresasEnvioInput = {
    where: CiudadesWhereUniqueInput
    create: XOR<CiudadesCreateWithoutEmpresasEnvioInput, CiudadesUncheckedCreateWithoutEmpresasEnvioInput>
  }

  export type EnviosCreateWithoutEmpresasEnvioInput = {
    num_rastreo: string
    Venta: VentaCreateNestedOneWithoutEnviosInput
  }

  export type EnviosUncheckedCreateWithoutEmpresasEnvioInput = {
    id_envio?: number
    num_rastreo: string
    id_venta: number
  }

  export type EnviosCreateOrConnectWithoutEmpresasEnvioInput = {
    where: EnviosWhereUniqueInput
    create: XOR<EnviosCreateWithoutEmpresasEnvioInput, EnviosUncheckedCreateWithoutEmpresasEnvioInput>
  }

  export type EnviosCreateManyEmpresasEnvioInputEnvelope = {
    data: Enumerable<EnviosCreateManyEmpresasEnvioInput>
  }

  export type CiudadesUpsertWithoutEmpresasEnvioInput = {
    update: XOR<CiudadesUpdateWithoutEmpresasEnvioInput, CiudadesUncheckedUpdateWithoutEmpresasEnvioInput>
    create: XOR<CiudadesCreateWithoutEmpresasEnvioInput, CiudadesUncheckedCreateWithoutEmpresasEnvioInput>
  }

  export type CiudadesUpdateWithoutEmpresasEnvioInput = {
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    Departamentos?: DepartamentosUpdateOneRequiredWithoutCiudadesInput
    Clientes?: ClientesUpdateManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUpdateManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedUpdateWithoutEmpresasEnvioInput = {
    id_ciudad?: IntFieldUpdateOperationsInput | number
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    id_departamento?: IntFieldUpdateOperationsInput | number
    Clientes?: ClientesUncheckedUpdateManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedUpdateManyWithoutCiudadesInput
  }

  export type EnviosUpsertWithWhereUniqueWithoutEmpresasEnvioInput = {
    where: EnviosWhereUniqueInput
    update: XOR<EnviosUpdateWithoutEmpresasEnvioInput, EnviosUncheckedUpdateWithoutEmpresasEnvioInput>
    create: XOR<EnviosCreateWithoutEmpresasEnvioInput, EnviosUncheckedCreateWithoutEmpresasEnvioInput>
  }

  export type EnviosUpdateWithWhereUniqueWithoutEmpresasEnvioInput = {
    where: EnviosWhereUniqueInput
    data: XOR<EnviosUpdateWithoutEmpresasEnvioInput, EnviosUncheckedUpdateWithoutEmpresasEnvioInput>
  }

  export type EnviosUpdateManyWithWhereWithoutEmpresasEnvioInput = {
    where: EnviosScalarWhereInput
    data: XOR<EnviosUpdateManyMutationInput, EnviosUncheckedUpdateManyWithoutEnviosInput>
  }

  export type EnviosScalarWhereInput = {
    AND?: Enumerable<EnviosScalarWhereInput>
    OR?: Enumerable<EnviosScalarWhereInput>
    NOT?: Enumerable<EnviosScalarWhereInput>
    id_envio?: IntFilter | number
    num_rastreo?: StringFilter | string
    id_venta?: IntFilter | number
    id_empresaEnvio?: IntFilter | number
  }

  export type EmpresasEnvioCreateWithoutEnviosInput = {
    nombre_empresa: string
    direccion_empresa: string
    telefono_empresa: string
    estado: boolean
    correo_empresa: string
    Ciudades: CiudadesCreateNestedOneWithoutEmpresasEnvioInput
  }

  export type EmpresasEnvioUncheckedCreateWithoutEnviosInput = {
    id_empresaEnvio?: number
    nombre_empresa: string
    direccion_empresa: string
    telefono_empresa: string
    id_ciudad: number
    estado: boolean
    correo_empresa: string
  }

  export type EmpresasEnvioCreateOrConnectWithoutEnviosInput = {
    where: EmpresasEnvioWhereUniqueInput
    create: XOR<EmpresasEnvioCreateWithoutEnviosInput, EmpresasEnvioUncheckedCreateWithoutEnviosInput>
  }

  export type VentaCreateWithoutEnviosInput = {
    fecha: Date | string
    RTN_estado: boolean
    ISV: number
    descuento: number
    Clientes: ClientesCreateNestedOneWithoutVentaInput
    DireccionesEnvio: DireccionesEnvioCreateNestedOneWithoutVentaInput
    DetallesVentas?: DetallesVentasCreateNestedManyWithoutVentaInput
  }

  export type VentaUncheckedCreateWithoutEnviosInput = {
    id_Venta?: number
    fecha: Date | string
    id_cliente: number
    RTN_estado: boolean
    ISV: number
    id_direccionEnvio: number
    descuento: number
    DetallesVentas?: DetallesVentasUncheckedCreateNestedManyWithoutVentaInput
  }

  export type VentaCreateOrConnectWithoutEnviosInput = {
    where: VentaWhereUniqueInput
    create: XOR<VentaCreateWithoutEnviosInput, VentaUncheckedCreateWithoutEnviosInput>
  }

  export type EmpresasEnvioUpsertWithoutEnviosInput = {
    update: XOR<EmpresasEnvioUpdateWithoutEnviosInput, EmpresasEnvioUncheckedUpdateWithoutEnviosInput>
    create: XOR<EmpresasEnvioCreateWithoutEnviosInput, EmpresasEnvioUncheckedCreateWithoutEnviosInput>
  }

  export type EmpresasEnvioUpdateWithoutEnviosInput = {
    nombre_empresa?: StringFieldUpdateOperationsInput | string
    direccion_empresa?: StringFieldUpdateOperationsInput | string
    telefono_empresa?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    correo_empresa?: StringFieldUpdateOperationsInput | string
    Ciudades?: CiudadesUpdateOneRequiredWithoutEmpresasEnvioInput
  }

  export type EmpresasEnvioUncheckedUpdateWithoutEnviosInput = {
    id_empresaEnvio?: IntFieldUpdateOperationsInput | number
    nombre_empresa?: StringFieldUpdateOperationsInput | string
    direccion_empresa?: StringFieldUpdateOperationsInput | string
    telefono_empresa?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    correo_empresa?: StringFieldUpdateOperationsInput | string
  }

  export type VentaUpsertWithoutEnviosInput = {
    update: XOR<VentaUpdateWithoutEnviosInput, VentaUncheckedUpdateWithoutEnviosInput>
    create: XOR<VentaCreateWithoutEnviosInput, VentaUncheckedCreateWithoutEnviosInput>
  }

  export type VentaUpdateWithoutEnviosInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    Clientes?: ClientesUpdateOneRequiredWithoutVentaInput
    DireccionesEnvio?: DireccionesEnvioUpdateOneRequiredWithoutVentaInput
    DetallesVentas?: DetallesVentasUpdateManyWithoutVentaInput
  }

  export type VentaUncheckedUpdateWithoutEnviosInput = {
    id_Venta?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    DetallesVentas?: DetallesVentasUncheckedUpdateManyWithoutVentaInput
  }

  export type ProductosCreateWithoutMarcasInput = {
    descripcion_producto: string
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    Categorias: CategoriasCreateNestedOneWithoutProductosInput
    Proveedores: ProveedoresCreateNestedOneWithoutProductosInput
    CarritoItem?: CarritoItemCreateNestedManyWithoutProductosInput
    DetalleCompras?: DetalleComprasCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutMarcasInput = {
    id_producto?: number
    descripcion_producto: string
    id_categoria: number
    id_proveedor: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    CarritoItem?: CarritoItemUncheckedCreateNestedManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUncheckedCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutMarcasInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutMarcasInput, ProductosUncheckedCreateWithoutMarcasInput>
  }

  export type ProductosCreateManyMarcasInputEnvelope = {
    data: Enumerable<ProductosCreateManyMarcasInput>
  }

  export type ProductosUpsertWithWhereUniqueWithoutMarcasInput = {
    where: ProductosWhereUniqueInput
    update: XOR<ProductosUpdateWithoutMarcasInput, ProductosUncheckedUpdateWithoutMarcasInput>
    create: XOR<ProductosCreateWithoutMarcasInput, ProductosUncheckedCreateWithoutMarcasInput>
  }

  export type ProductosUpdateWithWhereUniqueWithoutMarcasInput = {
    where: ProductosWhereUniqueInput
    data: XOR<ProductosUpdateWithoutMarcasInput, ProductosUncheckedUpdateWithoutMarcasInput>
  }

  export type ProductosUpdateManyWithWhereWithoutMarcasInput = {
    where: ProductosScalarWhereInput
    data: XOR<ProductosUpdateManyMutationInput, ProductosUncheckedUpdateManyWithoutProductosInput>
  }

  export type CategoriasCreateWithoutProductosInput = {
    descripcion_categoria: string
    estado: boolean
  }

  export type CategoriasUncheckedCreateWithoutProductosInput = {
    id_categoria?: number
    descripcion_categoria: string
    estado: boolean
  }

  export type CategoriasCreateOrConnectWithoutProductosInput = {
    where: CategoriasWhereUniqueInput
    create: XOR<CategoriasCreateWithoutProductosInput, CategoriasUncheckedCreateWithoutProductosInput>
  }

  export type MarcasCreateWithoutProductosInput = {
    descripcion_marca: string
    estado: boolean
  }

  export type MarcasUncheckedCreateWithoutProductosInput = {
    id_marca?: number
    descripcion_marca: string
    estado: boolean
  }

  export type MarcasCreateOrConnectWithoutProductosInput = {
    where: MarcasWhereUniqueInput
    create: XOR<MarcasCreateWithoutProductosInput, MarcasUncheckedCreateWithoutProductosInput>
  }

  export type ProveedoresCreateWithoutProductosInput = {
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    Estado: boolean
    Ciudades: CiudadesCreateNestedOneWithoutProveedoresInput
    Compras?: ComprasCreateNestedManyWithoutProveedoresInput
  }

  export type ProveedoresUncheckedCreateWithoutProductosInput = {
    id_prov?: number
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    id_ciudad: number
    Estado: boolean
    Compras?: ComprasUncheckedCreateNestedManyWithoutProveedoresInput
  }

  export type ProveedoresCreateOrConnectWithoutProductosInput = {
    where: ProveedoresWhereUniqueInput
    create: XOR<ProveedoresCreateWithoutProductosInput, ProveedoresUncheckedCreateWithoutProductosInput>
  }

  export type CarritoItemCreateWithoutProductosInput = {
    cantidad: number
    Carrito: CarritoCreateNestedOneWithoutCarritoItemInput
  }

  export type CarritoItemUncheckedCreateWithoutProductosInput = {
    id_itemCarrito?: number
    id_Carrito: number
    cantidad: number
  }

  export type CarritoItemCreateOrConnectWithoutProductosInput = {
    where: CarritoItemWhereUniqueInput
    create: XOR<CarritoItemCreateWithoutProductosInput, CarritoItemUncheckedCreateWithoutProductosInput>
  }

  export type CarritoItemCreateManyProductosInputEnvelope = {
    data: Enumerable<CarritoItemCreateManyProductosInput>
  }

  export type DetalleComprasCreateWithoutProductosInput = {
    precio: number
    cantidad: number
    Compras: ComprasCreateNestedOneWithoutDetalleComprasInput
  }

  export type DetalleComprasUncheckedCreateWithoutProductosInput = {
    id_detalleCompra?: number
    id_compra: number
    precio: number
    cantidad: number
  }

  export type DetalleComprasCreateOrConnectWithoutProductosInput = {
    where: DetalleComprasWhereUniqueInput
    create: XOR<DetalleComprasCreateWithoutProductosInput, DetalleComprasUncheckedCreateWithoutProductosInput>
  }

  export type DetalleComprasCreateManyProductosInputEnvelope = {
    data: Enumerable<DetalleComprasCreateManyProductosInput>
  }

  export type DetallesVentasCreateWithoutProductosInput = {
    precio: number
    cantidad: number
    Venta: VentaCreateNestedOneWithoutDetallesVentasInput
  }

  export type DetallesVentasUncheckedCreateWithoutProductosInput = {
    id_detalleVenta?: number
    id_venta: number
    precio: number
    cantidad: number
  }

  export type DetallesVentasCreateOrConnectWithoutProductosInput = {
    where: DetallesVentasWhereUniqueInput
    create: XOR<DetallesVentasCreateWithoutProductosInput, DetallesVentasUncheckedCreateWithoutProductosInput>
  }

  export type DetallesVentasCreateManyProductosInputEnvelope = {
    data: Enumerable<DetallesVentasCreateManyProductosInput>
  }

  export type CategoriasUpsertWithoutProductosInput = {
    update: XOR<CategoriasUpdateWithoutProductosInput, CategoriasUncheckedUpdateWithoutProductosInput>
    create: XOR<CategoriasCreateWithoutProductosInput, CategoriasUncheckedCreateWithoutProductosInput>
  }

  export type CategoriasUpdateWithoutProductosInput = {
    descripcion_categoria?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoriasUncheckedUpdateWithoutProductosInput = {
    id_categoria?: IntFieldUpdateOperationsInput | number
    descripcion_categoria?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MarcasUpsertWithoutProductosInput = {
    update: XOR<MarcasUpdateWithoutProductosInput, MarcasUncheckedUpdateWithoutProductosInput>
    create: XOR<MarcasCreateWithoutProductosInput, MarcasUncheckedCreateWithoutProductosInput>
  }

  export type MarcasUpdateWithoutProductosInput = {
    descripcion_marca?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MarcasUncheckedUpdateWithoutProductosInput = {
    id_marca?: IntFieldUpdateOperationsInput | number
    descripcion_marca?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProveedoresUpsertWithoutProductosInput = {
    update: XOR<ProveedoresUpdateWithoutProductosInput, ProveedoresUncheckedUpdateWithoutProductosInput>
    create: XOR<ProveedoresCreateWithoutProductosInput, ProveedoresUncheckedCreateWithoutProductosInput>
  }

  export type ProveedoresUpdateWithoutProductosInput = {
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Ciudades?: CiudadesUpdateOneRequiredWithoutProveedoresInput
    Compras?: ComprasUpdateManyWithoutProveedoresInput
  }

  export type ProveedoresUncheckedUpdateWithoutProductosInput = {
    id_prov?: IntFieldUpdateOperationsInput | number
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUncheckedUpdateManyWithoutProveedoresInput
  }

  export type CarritoItemUpsertWithWhereUniqueWithoutProductosInput = {
    where: CarritoItemWhereUniqueInput
    update: XOR<CarritoItemUpdateWithoutProductosInput, CarritoItemUncheckedUpdateWithoutProductosInput>
    create: XOR<CarritoItemCreateWithoutProductosInput, CarritoItemUncheckedCreateWithoutProductosInput>
  }

  export type CarritoItemUpdateWithWhereUniqueWithoutProductosInput = {
    where: CarritoItemWhereUniqueInput
    data: XOR<CarritoItemUpdateWithoutProductosInput, CarritoItemUncheckedUpdateWithoutProductosInput>
  }

  export type CarritoItemUpdateManyWithWhereWithoutProductosInput = {
    where: CarritoItemScalarWhereInput
    data: XOR<CarritoItemUpdateManyMutationInput, CarritoItemUncheckedUpdateManyWithoutCarritoItemInput>
  }

  export type CarritoItemScalarWhereInput = {
    AND?: Enumerable<CarritoItemScalarWhereInput>
    OR?: Enumerable<CarritoItemScalarWhereInput>
    NOT?: Enumerable<CarritoItemScalarWhereInput>
    id_itemCarrito?: IntFilter | number
    id_Carrito?: IntFilter | number
    id_producto?: IntFilter | number
    cantidad?: IntFilter | number
  }

  export type DetalleComprasUpsertWithWhereUniqueWithoutProductosInput = {
    where: DetalleComprasWhereUniqueInput
    update: XOR<DetalleComprasUpdateWithoutProductosInput, DetalleComprasUncheckedUpdateWithoutProductosInput>
    create: XOR<DetalleComprasCreateWithoutProductosInput, DetalleComprasUncheckedCreateWithoutProductosInput>
  }

  export type DetalleComprasUpdateWithWhereUniqueWithoutProductosInput = {
    where: DetalleComprasWhereUniqueInput
    data: XOR<DetalleComprasUpdateWithoutProductosInput, DetalleComprasUncheckedUpdateWithoutProductosInput>
  }

  export type DetalleComprasUpdateManyWithWhereWithoutProductosInput = {
    where: DetalleComprasScalarWhereInput
    data: XOR<DetalleComprasUpdateManyMutationInput, DetalleComprasUncheckedUpdateManyWithoutDetalleComprasInput>
  }

  export type DetallesVentasUpsertWithWhereUniqueWithoutProductosInput = {
    where: DetallesVentasWhereUniqueInput
    update: XOR<DetallesVentasUpdateWithoutProductosInput, DetallesVentasUncheckedUpdateWithoutProductosInput>
    create: XOR<DetallesVentasCreateWithoutProductosInput, DetallesVentasUncheckedCreateWithoutProductosInput>
  }

  export type DetallesVentasUpdateWithWhereUniqueWithoutProductosInput = {
    where: DetallesVentasWhereUniqueInput
    data: XOR<DetallesVentasUpdateWithoutProductosInput, DetallesVentasUncheckedUpdateWithoutProductosInput>
  }

  export type DetallesVentasUpdateManyWithWhereWithoutProductosInput = {
    where: DetallesVentasScalarWhereInput
    data: XOR<DetallesVentasUpdateManyMutationInput, DetallesVentasUncheckedUpdateManyWithoutDetallesVentasInput>
  }

  export type DetallesVentasScalarWhereInput = {
    AND?: Enumerable<DetallesVentasScalarWhereInput>
    OR?: Enumerable<DetallesVentasScalarWhereInput>
    NOT?: Enumerable<DetallesVentasScalarWhereInput>
    id_detalleVenta?: IntFilter | number
    id_producto?: IntFilter | number
    id_venta?: IntFilter | number
    precio?: FloatFilter | number
    cantidad?: FloatFilter | number
  }

  export type CiudadesCreateWithoutProveedoresInput = {
    nombre_ciudad: string
    codigoPostal: string
    Departamentos: DepartamentosCreateNestedOneWithoutCiudadesInput
    Clientes?: ClientesCreateNestedManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedCreateWithoutProveedoresInput = {
    id_ciudad?: number
    nombre_ciudad: string
    codigoPostal: string
    id_departamento: number
    Clientes?: ClientesUncheckedCreateNestedManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedCreateNestedManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedCreateNestedManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedCreateNestedManyWithoutCiudadesInput
  }

  export type CiudadesCreateOrConnectWithoutProveedoresInput = {
    where: CiudadesWhereUniqueInput
    create: XOR<CiudadesCreateWithoutProveedoresInput, CiudadesUncheckedCreateWithoutProveedoresInput>
  }

  export type ComprasCreateWithoutProveedoresInput = {
    fecha_compra: Date | string
    isv: number
    descuento: number
    Empleados: EmpleadosCreateNestedOneWithoutComprasInput
    DetalleCompras?: DetalleComprasCreateNestedManyWithoutComprasInput
  }

  export type ComprasUncheckedCreateWithoutProveedoresInput = {
    id_compra?: number
    fecha_compra: Date | string
    id_empleado: number
    isv: number
    descuento: number
    DetalleCompras?: DetalleComprasUncheckedCreateNestedManyWithoutComprasInput
  }

  export type ComprasCreateOrConnectWithoutProveedoresInput = {
    where: ComprasWhereUniqueInput
    create: XOR<ComprasCreateWithoutProveedoresInput, ComprasUncheckedCreateWithoutProveedoresInput>
  }

  export type ComprasCreateManyProveedoresInputEnvelope = {
    data: Enumerable<ComprasCreateManyProveedoresInput>
  }

  export type ProductosCreateWithoutProveedoresInput = {
    descripcion_producto: string
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    Categorias: CategoriasCreateNestedOneWithoutProductosInput
    Marcas: MarcasCreateNestedOneWithoutProductosInput
    CarritoItem?: CarritoItemCreateNestedManyWithoutProductosInput
    DetalleCompras?: DetalleComprasCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutProveedoresInput = {
    id_producto?: number
    descripcion_producto: string
    id_marca: number
    id_categoria: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    CarritoItem?: CarritoItemUncheckedCreateNestedManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUncheckedCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutProveedoresInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutProveedoresInput, ProductosUncheckedCreateWithoutProveedoresInput>
  }

  export type ProductosCreateManyProveedoresInputEnvelope = {
    data: Enumerable<ProductosCreateManyProveedoresInput>
  }

  export type CiudadesUpsertWithoutProveedoresInput = {
    update: XOR<CiudadesUpdateWithoutProveedoresInput, CiudadesUncheckedUpdateWithoutProveedoresInput>
    create: XOR<CiudadesCreateWithoutProveedoresInput, CiudadesUncheckedCreateWithoutProveedoresInput>
  }

  export type CiudadesUpdateWithoutProveedoresInput = {
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    Departamentos?: DepartamentosUpdateOneRequiredWithoutCiudadesInput
    Clientes?: ClientesUpdateManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUpdateManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedUpdateWithoutProveedoresInput = {
    id_ciudad?: IntFieldUpdateOperationsInput | number
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    id_departamento?: IntFieldUpdateOperationsInput | number
    Clientes?: ClientesUncheckedUpdateManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedUpdateManyWithoutCiudadesInput
  }

  export type ComprasUpsertWithWhereUniqueWithoutProveedoresInput = {
    where: ComprasWhereUniqueInput
    update: XOR<ComprasUpdateWithoutProveedoresInput, ComprasUncheckedUpdateWithoutProveedoresInput>
    create: XOR<ComprasCreateWithoutProveedoresInput, ComprasUncheckedCreateWithoutProveedoresInput>
  }

  export type ComprasUpdateWithWhereUniqueWithoutProveedoresInput = {
    where: ComprasWhereUniqueInput
    data: XOR<ComprasUpdateWithoutProveedoresInput, ComprasUncheckedUpdateWithoutProveedoresInput>
  }

  export type ComprasUpdateManyWithWhereWithoutProveedoresInput = {
    where: ComprasScalarWhereInput
    data: XOR<ComprasUpdateManyMutationInput, ComprasUncheckedUpdateManyWithoutComprasInput>
  }

  export type ProductosUpsertWithWhereUniqueWithoutProveedoresInput = {
    where: ProductosWhereUniqueInput
    update: XOR<ProductosUpdateWithoutProveedoresInput, ProductosUncheckedUpdateWithoutProveedoresInput>
    create: XOR<ProductosCreateWithoutProveedoresInput, ProductosUncheckedCreateWithoutProveedoresInput>
  }

  export type ProductosUpdateWithWhereUniqueWithoutProveedoresInput = {
    where: ProductosWhereUniqueInput
    data: XOR<ProductosUpdateWithoutProveedoresInput, ProductosUncheckedUpdateWithoutProveedoresInput>
  }

  export type ProductosUpdateManyWithWhereWithoutProveedoresInput = {
    where: ProductosScalarWhereInput
    data: XOR<ProductosUpdateManyMutationInput, ProductosUncheckedUpdateManyWithoutProductosInput>
  }

  export type EmpleadosCreateWithoutRolesEmpleadosInput = {
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    fnacimiento_empleado: number
    Estado: boolean
    Ciudades: CiudadesCreateNestedOneWithoutEmpleadosInput
    Compras?: ComprasCreateNestedManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosCreateNestedManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedCreateWithoutRolesEmpleadosInput = {
    id_empleado?: number
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    id_ciudad: number
    fnacimiento_empleado: number
    Estado: boolean
    Compras?: ComprasUncheckedCreateNestedManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosUncheckedCreateNestedManyWithoutEmpleadosInput
  }

  export type EmpleadosCreateOrConnectWithoutRolesEmpleadosInput = {
    where: EmpleadosWhereUniqueInput
    create: XOR<EmpleadosCreateWithoutRolesEmpleadosInput, EmpleadosUncheckedCreateWithoutRolesEmpleadosInput>
  }

  export type EmpleadosCreateManyRolesEmpleadosInputEnvelope = {
    data: Enumerable<EmpleadosCreateManyRolesEmpleadosInput>
  }

  export type EmpleadosUpsertWithWhereUniqueWithoutRolesEmpleadosInput = {
    where: EmpleadosWhereUniqueInput
    update: XOR<EmpleadosUpdateWithoutRolesEmpleadosInput, EmpleadosUncheckedUpdateWithoutRolesEmpleadosInput>
    create: XOR<EmpleadosCreateWithoutRolesEmpleadosInput, EmpleadosUncheckedCreateWithoutRolesEmpleadosInput>
  }

  export type EmpleadosUpdateWithWhereUniqueWithoutRolesEmpleadosInput = {
    where: EmpleadosWhereUniqueInput
    data: XOR<EmpleadosUpdateWithoutRolesEmpleadosInput, EmpleadosUncheckedUpdateWithoutRolesEmpleadosInput>
  }

  export type EmpleadosUpdateManyWithWhereWithoutRolesEmpleadosInput = {
    where: EmpleadosScalarWhereInput
    data: XOR<EmpleadosUpdateManyMutationInput, EmpleadosUncheckedUpdateManyWithoutEmpleadosInput>
  }

  export type EmpleadosCreateWithoutUsuarioEmpleadosInput = {
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    fnacimiento_empleado: number
    Estado: boolean
    Ciudades: CiudadesCreateNestedOneWithoutEmpleadosInput
    RolesEmpleados: RolesEmpleadosCreateNestedOneWithoutEmpleadosInput
    Compras?: ComprasCreateNestedManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedCreateWithoutUsuarioEmpleadosInput = {
    id_empleado?: number
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    id_ciudad: number
    id_rol: number
    fnacimiento_empleado: number
    Estado: boolean
    Compras?: ComprasUncheckedCreateNestedManyWithoutEmpleadosInput
  }

  export type EmpleadosCreateOrConnectWithoutUsuarioEmpleadosInput = {
    where: EmpleadosWhereUniqueInput
    create: XOR<EmpleadosCreateWithoutUsuarioEmpleadosInput, EmpleadosUncheckedCreateWithoutUsuarioEmpleadosInput>
  }

  export type EmpleadosUpsertWithoutUsuarioEmpleadosInput = {
    update: XOR<EmpleadosUpdateWithoutUsuarioEmpleadosInput, EmpleadosUncheckedUpdateWithoutUsuarioEmpleadosInput>
    create: XOR<EmpleadosCreateWithoutUsuarioEmpleadosInput, EmpleadosUncheckedCreateWithoutUsuarioEmpleadosInput>
  }

  export type EmpleadosUpdateWithoutUsuarioEmpleadosInput = {
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Ciudades?: CiudadesUpdateOneRequiredWithoutEmpleadosInput
    RolesEmpleados?: RolesEmpleadosUpdateOneRequiredWithoutEmpleadosInput
    Compras?: ComprasUpdateManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedUpdateWithoutUsuarioEmpleadosInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    id_rol?: IntFieldUpdateOperationsInput | number
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUncheckedUpdateManyWithoutEmpleadosInput
  }

  export type ClientesCreateWithoutUsuariosClientesInput = {
    nom_cliente: string
    apellido_cliente: string
    RTN?: string | null
    direccion_cliente: string
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
    Ciudades: CiudadesCreateNestedOneWithoutClientesInput
    Venta?: VentaCreateNestedManyWithoutClientesInput
  }

  export type ClientesUncheckedCreateWithoutUsuariosClientesInput = {
    id_cliente?: number
    nom_cliente: string
    apellido_cliente: string
    RTN?: string | null
    direccion_cliente: string
    id_ciudad: number
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
    Venta?: VentaUncheckedCreateNestedManyWithoutClientesInput
  }

  export type ClientesCreateOrConnectWithoutUsuariosClientesInput = {
    where: ClientesWhereUniqueInput
    create: XOR<ClientesCreateWithoutUsuariosClientesInput, ClientesUncheckedCreateWithoutUsuariosClientesInput>
  }

  export type CarritoCreateWithoutUsuariosClientesInput = {
    CarritoItem?: CarritoItemCreateNestedManyWithoutCarritoInput
  }

  export type CarritoUncheckedCreateWithoutUsuariosClientesInput = {
    id_carrito?: number
    CarritoItem?: CarritoItemUncheckedCreateNestedManyWithoutCarritoInput
  }

  export type CarritoCreateOrConnectWithoutUsuariosClientesInput = {
    where: CarritoWhereUniqueInput
    create: XOR<CarritoCreateWithoutUsuariosClientesInput, CarritoUncheckedCreateWithoutUsuariosClientesInput>
  }

  export type CarritoCreateManyUsuariosClientesInputEnvelope = {
    data: Enumerable<CarritoCreateManyUsuariosClientesInput>
  }

  export type DireccionesEnvioCreateWithoutUsuariosClientesInput = {
    direccion: string
    direccion_opcional: string
    Ciudades: CiudadesCreateNestedOneWithoutDireccionesEnvioInput
    Venta?: VentaCreateNestedManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioUncheckedCreateWithoutUsuariosClientesInput = {
    id_direccionEnvio?: number
    direccion: string
    id_ciudad: number
    direccion_opcional: string
    Venta?: VentaUncheckedCreateNestedManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioCreateOrConnectWithoutUsuariosClientesInput = {
    where: DireccionesEnvioWhereUniqueInput
    create: XOR<DireccionesEnvioCreateWithoutUsuariosClientesInput, DireccionesEnvioUncheckedCreateWithoutUsuariosClientesInput>
  }

  export type DireccionesEnvioCreateManyUsuariosClientesInputEnvelope = {
    data: Enumerable<DireccionesEnvioCreateManyUsuariosClientesInput>
  }

  export type ClientesUpsertWithoutUsuariosClientesInput = {
    update: XOR<ClientesUpdateWithoutUsuariosClientesInput, ClientesUncheckedUpdateWithoutUsuariosClientesInput>
    create: XOR<ClientesCreateWithoutUsuariosClientesInput, ClientesUncheckedCreateWithoutUsuariosClientesInput>
  }

  export type ClientesUpdateWithoutUsuariosClientesInput = {
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
    Ciudades?: CiudadesUpdateOneRequiredWithoutClientesInput
    Venta?: VentaUpdateManyWithoutClientesInput
  }

  export type ClientesUncheckedUpdateWithoutUsuariosClientesInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
    Venta?: VentaUncheckedUpdateManyWithoutClientesInput
  }

  export type CarritoUpsertWithWhereUniqueWithoutUsuariosClientesInput = {
    where: CarritoWhereUniqueInput
    update: XOR<CarritoUpdateWithoutUsuariosClientesInput, CarritoUncheckedUpdateWithoutUsuariosClientesInput>
    create: XOR<CarritoCreateWithoutUsuariosClientesInput, CarritoUncheckedCreateWithoutUsuariosClientesInput>
  }

  export type CarritoUpdateWithWhereUniqueWithoutUsuariosClientesInput = {
    where: CarritoWhereUniqueInput
    data: XOR<CarritoUpdateWithoutUsuariosClientesInput, CarritoUncheckedUpdateWithoutUsuariosClientesInput>
  }

  export type CarritoUpdateManyWithWhereWithoutUsuariosClientesInput = {
    where: CarritoScalarWhereInput
    data: XOR<CarritoUpdateManyMutationInput, CarritoUncheckedUpdateManyWithoutCarritoInput>
  }

  export type CarritoScalarWhereInput = {
    AND?: Enumerable<CarritoScalarWhereInput>
    OR?: Enumerable<CarritoScalarWhereInput>
    NOT?: Enumerable<CarritoScalarWhereInput>
    id_carrito?: IntFilter | number
    id_usuarioCliente?: IntFilter | number
  }

  export type DireccionesEnvioUpsertWithWhereUniqueWithoutUsuariosClientesInput = {
    where: DireccionesEnvioWhereUniqueInput
    update: XOR<DireccionesEnvioUpdateWithoutUsuariosClientesInput, DireccionesEnvioUncheckedUpdateWithoutUsuariosClientesInput>
    create: XOR<DireccionesEnvioCreateWithoutUsuariosClientesInput, DireccionesEnvioUncheckedCreateWithoutUsuariosClientesInput>
  }

  export type DireccionesEnvioUpdateWithWhereUniqueWithoutUsuariosClientesInput = {
    where: DireccionesEnvioWhereUniqueInput
    data: XOR<DireccionesEnvioUpdateWithoutUsuariosClientesInput, DireccionesEnvioUncheckedUpdateWithoutUsuariosClientesInput>
  }

  export type DireccionesEnvioUpdateManyWithWhereWithoutUsuariosClientesInput = {
    where: DireccionesEnvioScalarWhereInput
    data: XOR<DireccionesEnvioUpdateManyMutationInput, DireccionesEnvioUncheckedUpdateManyWithoutDireccionesEnvioInput>
  }

  export type ClientesCreateWithoutVentaInput = {
    nom_cliente: string
    apellido_cliente: string
    RTN?: string | null
    direccion_cliente: string
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
    Ciudades: CiudadesCreateNestedOneWithoutClientesInput
    usuariosClientes?: usuariosClientesCreateNestedManyWithoutClientesInput
  }

  export type ClientesUncheckedCreateWithoutVentaInput = {
    id_cliente?: number
    nom_cliente: string
    apellido_cliente: string
    RTN?: string | null
    direccion_cliente: string
    id_ciudad: number
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
    usuariosClientes?: usuariosClientesUncheckedCreateNestedManyWithoutClientesInput
  }

  export type ClientesCreateOrConnectWithoutVentaInput = {
    where: ClientesWhereUniqueInput
    create: XOR<ClientesCreateWithoutVentaInput, ClientesUncheckedCreateWithoutVentaInput>
  }

  export type DireccionesEnvioCreateWithoutVentaInput = {
    direccion: string
    direccion_opcional: string
    Ciudades: CiudadesCreateNestedOneWithoutDireccionesEnvioInput
    usuariosClientes: usuariosClientesCreateNestedOneWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioUncheckedCreateWithoutVentaInput = {
    id_direccionEnvio?: number
    direccion: string
    id_ciudad: number
    id_usuarioCliente: number
    direccion_opcional: string
  }

  export type DireccionesEnvioCreateOrConnectWithoutVentaInput = {
    where: DireccionesEnvioWhereUniqueInput
    create: XOR<DireccionesEnvioCreateWithoutVentaInput, DireccionesEnvioUncheckedCreateWithoutVentaInput>
  }

  export type DetallesVentasCreateWithoutVentaInput = {
    precio: number
    cantidad: number
    Productos: ProductosCreateNestedOneWithoutDetallesVentasInput
  }

  export type DetallesVentasUncheckedCreateWithoutVentaInput = {
    id_detalleVenta?: number
    id_producto: number
    precio: number
    cantidad: number
  }

  export type DetallesVentasCreateOrConnectWithoutVentaInput = {
    where: DetallesVentasWhereUniqueInput
    create: XOR<DetallesVentasCreateWithoutVentaInput, DetallesVentasUncheckedCreateWithoutVentaInput>
  }

  export type DetallesVentasCreateManyVentaInputEnvelope = {
    data: Enumerable<DetallesVentasCreateManyVentaInput>
  }

  export type EnviosCreateWithoutVentaInput = {
    num_rastreo: string
    EmpresasEnvio: EmpresasEnvioCreateNestedOneWithoutEnviosInput
  }

  export type EnviosUncheckedCreateWithoutVentaInput = {
    id_envio?: number
    num_rastreo: string
    id_empresaEnvio: number
  }

  export type EnviosCreateOrConnectWithoutVentaInput = {
    where: EnviosWhereUniqueInput
    create: XOR<EnviosCreateWithoutVentaInput, EnviosUncheckedCreateWithoutVentaInput>
  }

  export type EnviosCreateManyVentaInputEnvelope = {
    data: Enumerable<EnviosCreateManyVentaInput>
  }

  export type ClientesUpsertWithoutVentaInput = {
    update: XOR<ClientesUpdateWithoutVentaInput, ClientesUncheckedUpdateWithoutVentaInput>
    create: XOR<ClientesCreateWithoutVentaInput, ClientesUncheckedCreateWithoutVentaInput>
  }

  export type ClientesUpdateWithoutVentaInput = {
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
    Ciudades?: CiudadesUpdateOneRequiredWithoutClientesInput
    usuariosClientes?: usuariosClientesUpdateManyWithoutClientesInput
  }

  export type ClientesUncheckedUpdateWithoutVentaInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
    usuariosClientes?: usuariosClientesUncheckedUpdateManyWithoutClientesInput
  }

  export type DireccionesEnvioUpsertWithoutVentaInput = {
    update: XOR<DireccionesEnvioUpdateWithoutVentaInput, DireccionesEnvioUncheckedUpdateWithoutVentaInput>
    create: XOR<DireccionesEnvioCreateWithoutVentaInput, DireccionesEnvioUncheckedCreateWithoutVentaInput>
  }

  export type DireccionesEnvioUpdateWithoutVentaInput = {
    direccion?: StringFieldUpdateOperationsInput | string
    direccion_opcional?: StringFieldUpdateOperationsInput | string
    Ciudades?: CiudadesUpdateOneRequiredWithoutDireccionesEnvioInput
    usuariosClientes?: usuariosClientesUpdateOneRequiredWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioUncheckedUpdateWithoutVentaInput = {
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    direccion?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    direccion_opcional?: StringFieldUpdateOperationsInput | string
  }

  export type DetallesVentasUpsertWithWhereUniqueWithoutVentaInput = {
    where: DetallesVentasWhereUniqueInput
    update: XOR<DetallesVentasUpdateWithoutVentaInput, DetallesVentasUncheckedUpdateWithoutVentaInput>
    create: XOR<DetallesVentasCreateWithoutVentaInput, DetallesVentasUncheckedCreateWithoutVentaInput>
  }

  export type DetallesVentasUpdateWithWhereUniqueWithoutVentaInput = {
    where: DetallesVentasWhereUniqueInput
    data: XOR<DetallesVentasUpdateWithoutVentaInput, DetallesVentasUncheckedUpdateWithoutVentaInput>
  }

  export type DetallesVentasUpdateManyWithWhereWithoutVentaInput = {
    where: DetallesVentasScalarWhereInput
    data: XOR<DetallesVentasUpdateManyMutationInput, DetallesVentasUncheckedUpdateManyWithoutDetallesVentasInput>
  }

  export type EnviosUpsertWithWhereUniqueWithoutVentaInput = {
    where: EnviosWhereUniqueInput
    update: XOR<EnviosUpdateWithoutVentaInput, EnviosUncheckedUpdateWithoutVentaInput>
    create: XOR<EnviosCreateWithoutVentaInput, EnviosUncheckedCreateWithoutVentaInput>
  }

  export type EnviosUpdateWithWhereUniqueWithoutVentaInput = {
    where: EnviosWhereUniqueInput
    data: XOR<EnviosUpdateWithoutVentaInput, EnviosUncheckedUpdateWithoutVentaInput>
  }

  export type EnviosUpdateManyWithWhereWithoutVentaInput = {
    where: EnviosScalarWhereInput
    data: XOR<EnviosUpdateManyMutationInput, EnviosUncheckedUpdateManyWithoutEnviosInput>
  }

  export type usuariosClientesCreateWithoutCarritoInput = {
    nombre_usuario: string
    contraenia_usuario: string
    correo_usuario: string
    estado: boolean
    Clientes: ClientesCreateNestedOneWithoutUsuariosClientesInput
    DireccionesEnvio?: DireccionesEnvioCreateNestedManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesUncheckedCreateWithoutCarritoInput = {
    id_usuarioCliente?: number
    nombre_usuario: string
    contraenia_usuario: string
    id_cliente: number
    correo_usuario: string
    estado: boolean
    DireccionesEnvio?: DireccionesEnvioUncheckedCreateNestedManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesCreateOrConnectWithoutCarritoInput = {
    where: usuariosClientesWhereUniqueInput
    create: XOR<usuariosClientesCreateWithoutCarritoInput, usuariosClientesUncheckedCreateWithoutCarritoInput>
  }

  export type CarritoItemCreateWithoutCarritoInput = {
    cantidad: number
    Productos: ProductosCreateNestedOneWithoutCarritoItemInput
  }

  export type CarritoItemUncheckedCreateWithoutCarritoInput = {
    id_itemCarrito?: number
    id_producto: number
    cantidad: number
  }

  export type CarritoItemCreateOrConnectWithoutCarritoInput = {
    where: CarritoItemWhereUniqueInput
    create: XOR<CarritoItemCreateWithoutCarritoInput, CarritoItemUncheckedCreateWithoutCarritoInput>
  }

  export type CarritoItemCreateManyCarritoInputEnvelope = {
    data: Enumerable<CarritoItemCreateManyCarritoInput>
  }

  export type usuariosClientesUpsertWithoutCarritoInput = {
    update: XOR<usuariosClientesUpdateWithoutCarritoInput, usuariosClientesUncheckedUpdateWithoutCarritoInput>
    create: XOR<usuariosClientesCreateWithoutCarritoInput, usuariosClientesUncheckedCreateWithoutCarritoInput>
  }

  export type usuariosClientesUpdateWithoutCarritoInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Clientes?: ClientesUpdateOneRequiredWithoutUsuariosClientesInput
    DireccionesEnvio?: DireccionesEnvioUpdateManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesUncheckedUpdateWithoutCarritoInput = {
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DireccionesEnvio?: DireccionesEnvioUncheckedUpdateManyWithoutUsuariosClientesInput
  }

  export type CarritoItemUpsertWithWhereUniqueWithoutCarritoInput = {
    where: CarritoItemWhereUniqueInput
    update: XOR<CarritoItemUpdateWithoutCarritoInput, CarritoItemUncheckedUpdateWithoutCarritoInput>
    create: XOR<CarritoItemCreateWithoutCarritoInput, CarritoItemUncheckedCreateWithoutCarritoInput>
  }

  export type CarritoItemUpdateWithWhereUniqueWithoutCarritoInput = {
    where: CarritoItemWhereUniqueInput
    data: XOR<CarritoItemUpdateWithoutCarritoInput, CarritoItemUncheckedUpdateWithoutCarritoInput>
  }

  export type CarritoItemUpdateManyWithWhereWithoutCarritoInput = {
    where: CarritoItemScalarWhereInput
    data: XOR<CarritoItemUpdateManyMutationInput, CarritoItemUncheckedUpdateManyWithoutCarritoItemInput>
  }

  export type CarritoCreateWithoutCarritoItemInput = {
    usuariosClientes: usuariosClientesCreateNestedOneWithoutCarritoInput
  }

  export type CarritoUncheckedCreateWithoutCarritoItemInput = {
    id_carrito?: number
    id_usuarioCliente: number
  }

  export type CarritoCreateOrConnectWithoutCarritoItemInput = {
    where: CarritoWhereUniqueInput
    create: XOR<CarritoCreateWithoutCarritoItemInput, CarritoUncheckedCreateWithoutCarritoItemInput>
  }

  export type ProductosCreateWithoutCarritoItemInput = {
    descripcion_producto: string
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    Categorias: CategoriasCreateNestedOneWithoutProductosInput
    Marcas: MarcasCreateNestedOneWithoutProductosInput
    Proveedores: ProveedoresCreateNestedOneWithoutProductosInput
    DetalleCompras?: DetalleComprasCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutCarritoItemInput = {
    id_producto?: number
    descripcion_producto: string
    id_marca: number
    id_categoria: number
    id_proveedor: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
    DetalleCompras?: DetalleComprasUncheckedCreateNestedManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutCarritoItemInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutCarritoItemInput, ProductosUncheckedCreateWithoutCarritoItemInput>
  }

  export type CarritoUpsertWithoutCarritoItemInput = {
    update: XOR<CarritoUpdateWithoutCarritoItemInput, CarritoUncheckedUpdateWithoutCarritoItemInput>
    create: XOR<CarritoCreateWithoutCarritoItemInput, CarritoUncheckedCreateWithoutCarritoItemInput>
  }

  export type CarritoUpdateWithoutCarritoItemInput = {
    usuariosClientes?: usuariosClientesUpdateOneRequiredWithoutCarritoInput
  }

  export type CarritoUncheckedUpdateWithoutCarritoItemInput = {
    id_carrito?: IntFieldUpdateOperationsInput | number
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
  }

  export type ProductosUpsertWithoutCarritoItemInput = {
    update: XOR<ProductosUpdateWithoutCarritoItemInput, ProductosUncheckedUpdateWithoutCarritoItemInput>
    create: XOR<ProductosCreateWithoutCarritoItemInput, ProductosUncheckedCreateWithoutCarritoItemInput>
  }

  export type ProductosUpdateWithoutCarritoItemInput = {
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    Categorias?: CategoriasUpdateOneRequiredWithoutProductosInput
    Marcas?: MarcasUpdateOneRequiredWithoutProductosInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutProductosInput
    DetalleCompras?: DetalleComprasUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUpdateManyWithoutProductosInput
  }

  export type ProductosUncheckedUpdateWithoutCarritoItemInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    id_marca?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_proveedor?: IntFieldUpdateOperationsInput | number
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    DetalleCompras?: DetalleComprasUncheckedUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedUpdateManyWithoutProductosInput
  }

  export type ProductosCreateManyCategoriasInput = {
    descripcion_producto: string
    id_marca: number
    id_proveedor: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
  }

  export type ProductosUpdateWithoutCategoriasInput = {
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    Marcas?: MarcasUpdateOneRequiredWithoutProductosInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutProductosInput
    CarritoItem?: CarritoItemUpdateManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUpdateManyWithoutProductosInput
  }

  export type ProductosUncheckedUpdateWithoutCategoriasInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    id_marca?: IntFieldUpdateOperationsInput | number
    id_proveedor?: IntFieldUpdateOperationsInput | number
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    CarritoItem?: CarritoItemUncheckedUpdateManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUncheckedUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedUpdateManyWithoutProductosInput
  }

  export type ProductosUncheckedUpdateManyWithoutProductosInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    id_marca?: IntFieldUpdateOperationsInput | number
    id_proveedor?: IntFieldUpdateOperationsInput | number
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientesCreateManyCiudadesInput = {
    nom_cliente: string
    apellido_cliente: string
    RTN?: string | null
    direccion_cliente: string
    tel_cliente: string
    estado: boolean
    DNI_Cliente: string
  }

  export type DireccionesEnvioCreateManyCiudadesInput = {
    direccion: string
    id_usuarioCliente: number
    direccion_opcional: string
  }

  export type EmpleadosCreateManyCiudadesInput = {
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    id_rol: number
    fnacimiento_empleado: number
    Estado: boolean
  }

  export type EmpresasEnvioCreateManyCiudadesInput = {
    nombre_empresa: string
    direccion_empresa: string
    telefono_empresa: string
    estado: boolean
    correo_empresa: string
  }

  export type ProveedoresCreateManyCiudadesInput = {
    nom_prov: string
    telefono_prov: string
    correo_prov: string
    direccion_prov: string
    Estado: boolean
  }

  export type ClientesUpdateWithoutCiudadesInput = {
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
    usuariosClientes?: usuariosClientesUpdateManyWithoutClientesInput
    Venta?: VentaUpdateManyWithoutClientesInput
  }

  export type ClientesUncheckedUpdateWithoutCiudadesInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
    usuariosClientes?: usuariosClientesUncheckedUpdateManyWithoutClientesInput
    Venta?: VentaUncheckedUpdateManyWithoutClientesInput
  }

  export type ClientesUncheckedUpdateManyWithoutClientesInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nom_cliente?: StringFieldUpdateOperationsInput | string
    apellido_cliente?: StringFieldUpdateOperationsInput | string
    RTN?: NullableStringFieldUpdateOperationsInput | string | null
    direccion_cliente?: StringFieldUpdateOperationsInput | string
    tel_cliente?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    DNI_Cliente?: StringFieldUpdateOperationsInput | string
  }

  export type DireccionesEnvioUpdateWithoutCiudadesInput = {
    direccion?: StringFieldUpdateOperationsInput | string
    direccion_opcional?: StringFieldUpdateOperationsInput | string
    usuariosClientes?: usuariosClientesUpdateOneRequiredWithoutDireccionesEnvioInput
    Venta?: VentaUpdateManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioUncheckedUpdateWithoutCiudadesInput = {
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    direccion?: StringFieldUpdateOperationsInput | string
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    direccion_opcional?: StringFieldUpdateOperationsInput | string
    Venta?: VentaUncheckedUpdateManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioUncheckedUpdateManyWithoutDireccionesEnvioInput = {
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    direccion?: StringFieldUpdateOperationsInput | string
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    direccion_opcional?: StringFieldUpdateOperationsInput | string
  }

  export type EmpleadosUpdateWithoutCiudadesInput = {
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    RolesEmpleados?: RolesEmpleadosUpdateOneRequiredWithoutEmpleadosInput
    Compras?: ComprasUpdateManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosUpdateManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedUpdateWithoutCiudadesInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    id_rol?: IntFieldUpdateOperationsInput | number
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUncheckedUpdateManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosUncheckedUpdateManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedUpdateManyWithoutEmpleadosInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    id_rol?: IntFieldUpdateOperationsInput | number
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmpresasEnvioUpdateWithoutCiudadesInput = {
    nombre_empresa?: StringFieldUpdateOperationsInput | string
    direccion_empresa?: StringFieldUpdateOperationsInput | string
    telefono_empresa?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    correo_empresa?: StringFieldUpdateOperationsInput | string
    Envios?: EnviosUpdateManyWithoutEmpresasEnvioInput
  }

  export type EmpresasEnvioUncheckedUpdateWithoutCiudadesInput = {
    id_empresaEnvio?: IntFieldUpdateOperationsInput | number
    nombre_empresa?: StringFieldUpdateOperationsInput | string
    direccion_empresa?: StringFieldUpdateOperationsInput | string
    telefono_empresa?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    correo_empresa?: StringFieldUpdateOperationsInput | string
    Envios?: EnviosUncheckedUpdateManyWithoutEmpresasEnvioInput
  }

  export type EmpresasEnvioUncheckedUpdateManyWithoutEmpresasEnvioInput = {
    id_empresaEnvio?: IntFieldUpdateOperationsInput | number
    nombre_empresa?: StringFieldUpdateOperationsInput | string
    direccion_empresa?: StringFieldUpdateOperationsInput | string
    telefono_empresa?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    correo_empresa?: StringFieldUpdateOperationsInput | string
  }

  export type ProveedoresUpdateWithoutCiudadesInput = {
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUpdateManyWithoutProveedoresInput
    Productos?: ProductosUpdateManyWithoutProveedoresInput
  }

  export type ProveedoresUncheckedUpdateWithoutCiudadesInput = {
    id_prov?: IntFieldUpdateOperationsInput | number
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUncheckedUpdateManyWithoutProveedoresInput
    Productos?: ProductosUncheckedUpdateManyWithoutProveedoresInput
  }

  export type ProveedoresUncheckedUpdateManyWithoutProveedoresInput = {
    id_prov?: IntFieldUpdateOperationsInput | number
    nom_prov?: StringFieldUpdateOperationsInput | string
    telefono_prov?: StringFieldUpdateOperationsInput | string
    correo_prov?: StringFieldUpdateOperationsInput | string
    direccion_prov?: StringFieldUpdateOperationsInput | string
    Estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usuariosClientesCreateManyClientesInput = {
    nombre_usuario: string
    contraenia_usuario: string
    correo_usuario: string
    estado: boolean
  }

  export type VentaCreateManyClientesInput = {
    fecha: Date | string
    RTN_estado: boolean
    ISV: number
    id_direccionEnvio: number
    descuento: number
  }

  export type usuariosClientesUpdateWithoutClientesInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Carrito?: CarritoUpdateManyWithoutUsuariosClientesInput
    DireccionesEnvio?: DireccionesEnvioUpdateManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesUncheckedUpdateWithoutClientesInput = {
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Carrito?: CarritoUncheckedUpdateManyWithoutUsuariosClientesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedUpdateManyWithoutUsuariosClientesInput
  }

  export type usuariosClientesUncheckedUpdateManyWithoutUsuariosClientesInput = {
    id_usuarioCliente?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    contraenia_usuario?: StringFieldUpdateOperationsInput | string
    correo_usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VentaUpdateWithoutClientesInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    DireccionesEnvio?: DireccionesEnvioUpdateOneRequiredWithoutVentaInput
    DetallesVentas?: DetallesVentasUpdateManyWithoutVentaInput
    Envios?: EnviosUpdateManyWithoutVentaInput
  }

  export type VentaUncheckedUpdateWithoutClientesInput = {
    id_Venta?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    DetallesVentas?: DetallesVentasUncheckedUpdateManyWithoutVentaInput
    Envios?: EnviosUncheckedUpdateManyWithoutVentaInput
  }

  export type VentaUncheckedUpdateManyWithoutVentaInput = {
    id_Venta?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
  }

  export type DetalleComprasCreateManyComprasInput = {
    id_producto: number
    precio: number
    cantidad: number
  }

  export type DetalleComprasUpdateWithoutComprasInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
    Productos?: ProductosUpdateOneRequiredWithoutDetalleComprasInput
  }

  export type DetalleComprasUncheckedUpdateWithoutComprasInput = {
    id_detalleCompra?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type DetalleComprasUncheckedUpdateManyWithoutDetalleComprasInput = {
    id_detalleCompra?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type CiudadesCreateManyDepartamentosInput = {
    nombre_ciudad: string
    codigoPostal: string
  }

  export type CiudadesUpdateWithoutDepartamentosInput = {
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    Clientes?: ClientesUpdateManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUpdateManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedUpdateWithoutDepartamentosInput = {
    id_ciudad?: IntFieldUpdateOperationsInput | number
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    Clientes?: ClientesUncheckedUpdateManyWithoutCiudadesInput
    DireccionesEnvio?: DireccionesEnvioUncheckedUpdateManyWithoutCiudadesInput
    Empleados?: EmpleadosUncheckedUpdateManyWithoutCiudadesInput
    EmpresasEnvio?: EmpresasEnvioUncheckedUpdateManyWithoutCiudadesInput
    Proveedores?: ProveedoresUncheckedUpdateManyWithoutCiudadesInput
  }

  export type CiudadesUncheckedUpdateManyWithoutCiudadesInput = {
    id_ciudad?: IntFieldUpdateOperationsInput | number
    nombre_ciudad?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
  }

  export type VentaCreateManyDireccionesEnvioInput = {
    fecha: Date | string
    id_cliente: number
    RTN_estado: boolean
    ISV: number
    descuento: number
  }

  export type VentaUpdateWithoutDireccionesEnvioInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    Clientes?: ClientesUpdateOneRequiredWithoutVentaInput
    DetallesVentas?: DetallesVentasUpdateManyWithoutVentaInput
    Envios?: EnviosUpdateManyWithoutVentaInput
  }

  export type VentaUncheckedUpdateWithoutDireccionesEnvioInput = {
    id_Venta?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    id_cliente?: IntFieldUpdateOperationsInput | number
    RTN_estado?: BoolFieldUpdateOperationsInput | boolean
    ISV?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    DetallesVentas?: DetallesVentasUncheckedUpdateManyWithoutVentaInput
    Envios?: EnviosUncheckedUpdateManyWithoutVentaInput
  }

  export type ComprasCreateManyEmpleadosInput = {
    fecha_compra: Date | string
    id_prov: number
    isv: number
    descuento: number
  }

  export type UsuarioEmpleadosCreateManyEmpleadosInput = {
    nom_usuarioEmpleado: string
    estado: boolean
    contrasenia_empleado: string
    correo_empleado: string
  }

  export type ComprasUpdateWithoutEmpleadosInput = {
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    Proveedores?: ProveedoresUpdateOneRequiredWithoutComprasInput
    DetalleCompras?: DetalleComprasUpdateManyWithoutComprasInput
  }

  export type ComprasUncheckedUpdateWithoutEmpleadosInput = {
    id_compra?: IntFieldUpdateOperationsInput | number
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    id_prov?: IntFieldUpdateOperationsInput | number
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    DetalleCompras?: DetalleComprasUncheckedUpdateManyWithoutComprasInput
  }

  export type ComprasUncheckedUpdateManyWithoutComprasInput = {
    id_compra?: IntFieldUpdateOperationsInput | number
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    id_prov?: IntFieldUpdateOperationsInput | number
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
  }

  export type UsuarioEmpleadosUpdateWithoutEmpleadosInput = {
    nom_usuarioEmpleado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    contrasenia_empleado?: StringFieldUpdateOperationsInput | string
    correo_empleado?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioEmpleadosUncheckedUpdateWithoutEmpleadosInput = {
    id_usuarioEmpleado?: IntFieldUpdateOperationsInput | number
    nom_usuarioEmpleado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    contrasenia_empleado?: StringFieldUpdateOperationsInput | string
    correo_empleado?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioEmpleadosUncheckedUpdateManyWithoutUsuarioEmpleadosInput = {
    id_usuarioEmpleado?: IntFieldUpdateOperationsInput | number
    nom_usuarioEmpleado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    contrasenia_empleado?: StringFieldUpdateOperationsInput | string
    correo_empleado?: StringFieldUpdateOperationsInput | string
  }

  export type EnviosCreateManyEmpresasEnvioInput = {
    num_rastreo: string
    id_venta: number
  }

  export type EnviosUpdateWithoutEmpresasEnvioInput = {
    num_rastreo?: StringFieldUpdateOperationsInput | string
    Venta?: VentaUpdateOneRequiredWithoutEnviosInput
  }

  export type EnviosUncheckedUpdateWithoutEmpresasEnvioInput = {
    id_envio?: IntFieldUpdateOperationsInput | number
    num_rastreo?: StringFieldUpdateOperationsInput | string
    id_venta?: IntFieldUpdateOperationsInput | number
  }

  export type EnviosUncheckedUpdateManyWithoutEnviosInput = {
    id_envio?: IntFieldUpdateOperationsInput | number
    num_rastreo?: StringFieldUpdateOperationsInput | string
    id_venta?: IntFieldUpdateOperationsInput | number
  }

  export type ProductosCreateManyMarcasInput = {
    descripcion_producto: string
    id_categoria: number
    id_proveedor: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
  }

  export type ProductosUpdateWithoutMarcasInput = {
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    Categorias?: CategoriasUpdateOneRequiredWithoutProductosInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutProductosInput
    CarritoItem?: CarritoItemUpdateManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUpdateManyWithoutProductosInput
  }

  export type ProductosUncheckedUpdateWithoutMarcasInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_proveedor?: IntFieldUpdateOperationsInput | number
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    CarritoItem?: CarritoItemUncheckedUpdateManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUncheckedUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedUpdateManyWithoutProductosInput
  }

  export type CarritoItemCreateManyProductosInput = {
    id_Carrito: number
    cantidad: number
  }

  export type DetalleComprasCreateManyProductosInput = {
    id_compra: number
    precio: number
    cantidad: number
  }

  export type DetallesVentasCreateManyProductosInput = {
    id_venta: number
    precio: number
    cantidad: number
  }

  export type CarritoItemUpdateWithoutProductosInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    Carrito?: CarritoUpdateOneRequiredWithoutCarritoItemInput
  }

  export type CarritoItemUncheckedUpdateWithoutProductosInput = {
    id_itemCarrito?: IntFieldUpdateOperationsInput | number
    id_Carrito?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type CarritoItemUncheckedUpdateManyWithoutCarritoItemInput = {
    id_itemCarrito?: IntFieldUpdateOperationsInput | number
    id_Carrito?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleComprasUpdateWithoutProductosInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
    Compras?: ComprasUpdateOneRequiredWithoutDetalleComprasInput
  }

  export type DetalleComprasUncheckedUpdateWithoutProductosInput = {
    id_detalleCompra?: IntFieldUpdateOperationsInput | number
    id_compra?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type DetallesVentasUpdateWithoutProductosInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
    Venta?: VentaUpdateOneRequiredWithoutDetallesVentasInput
  }

  export type DetallesVentasUncheckedUpdateWithoutProductosInput = {
    id_detalleVenta?: IntFieldUpdateOperationsInput | number
    id_venta?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type DetallesVentasUncheckedUpdateManyWithoutDetallesVentasInput = {
    id_detalleVenta?: IntFieldUpdateOperationsInput | number
    id_venta?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type ComprasCreateManyProveedoresInput = {
    fecha_compra: Date | string
    id_empleado: number
    isv: number
    descuento: number
  }

  export type ProductosCreateManyProveedoresInput = {
    descripcion_producto: string
    id_marca: number
    id_categoria: number
    cantidad_por_unidad: string
    costo_producto: number
    precio_actual: number
    stock: number
    descuento?: number | null
    estado: boolean
    imagen?: string | null
  }

  export type ComprasUpdateWithoutProveedoresInput = {
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    Empleados?: EmpleadosUpdateOneRequiredWithoutComprasInput
    DetalleCompras?: DetalleComprasUpdateManyWithoutComprasInput
  }

  export type ComprasUncheckedUpdateWithoutProveedoresInput = {
    id_compra?: IntFieldUpdateOperationsInput | number
    fecha_compra?: DateTimeFieldUpdateOperationsInput | Date | string
    id_empleado?: IntFieldUpdateOperationsInput | number
    isv?: FloatFieldUpdateOperationsInput | number
    descuento?: FloatFieldUpdateOperationsInput | number
    DetalleCompras?: DetalleComprasUncheckedUpdateManyWithoutComprasInput
  }

  export type ProductosUpdateWithoutProveedoresInput = {
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    Categorias?: CategoriasUpdateOneRequiredWithoutProductosInput
    Marcas?: MarcasUpdateOneRequiredWithoutProductosInput
    CarritoItem?: CarritoItemUpdateManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUpdateManyWithoutProductosInput
  }

  export type ProductosUncheckedUpdateWithoutProveedoresInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    descripcion_producto?: StringFieldUpdateOperationsInput | string
    id_marca?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    cantidad_por_unidad?: StringFieldUpdateOperationsInput | string
    costo_producto?: FloatFieldUpdateOperationsInput | number
    precio_actual?: FloatFieldUpdateOperationsInput | number
    stock?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    CarritoItem?: CarritoItemUncheckedUpdateManyWithoutProductosInput
    DetalleCompras?: DetalleComprasUncheckedUpdateManyWithoutProductosInput
    DetallesVentas?: DetallesVentasUncheckedUpdateManyWithoutProductosInput
  }

  export type EmpleadosCreateManyRolesEmpleadosInput = {
    nom_empleado: string
    apellido_empleado: string
    telefono_empleado: string
    direccion_empleado: string
    id_ciudad: number
    fnacimiento_empleado: number
    Estado: boolean
  }

  export type EmpleadosUpdateWithoutRolesEmpleadosInput = {
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Ciudades?: CiudadesUpdateOneRequiredWithoutEmpleadosInput
    Compras?: ComprasUpdateManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosUpdateManyWithoutEmpleadosInput
  }

  export type EmpleadosUncheckedUpdateWithoutRolesEmpleadosInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    nom_empleado?: StringFieldUpdateOperationsInput | string
    apellido_empleado?: StringFieldUpdateOperationsInput | string
    telefono_empleado?: StringFieldUpdateOperationsInput | string
    direccion_empleado?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    fnacimiento_empleado?: IntFieldUpdateOperationsInput | number
    Estado?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUncheckedUpdateManyWithoutEmpleadosInput
    UsuarioEmpleados?: UsuarioEmpleadosUncheckedUpdateManyWithoutEmpleadosInput
  }

  export type CarritoCreateManyUsuariosClientesInput = {

  }

  export type DireccionesEnvioCreateManyUsuariosClientesInput = {
    direccion: string
    id_ciudad: number
    direccion_opcional: string
  }

  export type CarritoUpdateWithoutUsuariosClientesInput = {
    CarritoItem?: CarritoItemUpdateManyWithoutCarritoInput
  }

  export type CarritoUncheckedUpdateWithoutUsuariosClientesInput = {
    id_carrito?: IntFieldUpdateOperationsInput | number
    CarritoItem?: CarritoItemUncheckedUpdateManyWithoutCarritoInput
  }

  export type CarritoUncheckedUpdateManyWithoutCarritoInput = {
    id_carrito?: IntFieldUpdateOperationsInput | number
  }

  export type DireccionesEnvioUpdateWithoutUsuariosClientesInput = {
    direccion?: StringFieldUpdateOperationsInput | string
    direccion_opcional?: StringFieldUpdateOperationsInput | string
    Ciudades?: CiudadesUpdateOneRequiredWithoutDireccionesEnvioInput
    Venta?: VentaUpdateManyWithoutDireccionesEnvioInput
  }

  export type DireccionesEnvioUncheckedUpdateWithoutUsuariosClientesInput = {
    id_direccionEnvio?: IntFieldUpdateOperationsInput | number
    direccion?: StringFieldUpdateOperationsInput | string
    id_ciudad?: IntFieldUpdateOperationsInput | number
    direccion_opcional?: StringFieldUpdateOperationsInput | string
    Venta?: VentaUncheckedUpdateManyWithoutDireccionesEnvioInput
  }

  export type DetallesVentasCreateManyVentaInput = {
    id_producto: number
    precio: number
    cantidad: number
  }

  export type EnviosCreateManyVentaInput = {
    num_rastreo: string
    id_empresaEnvio: number
  }

  export type DetallesVentasUpdateWithoutVentaInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
    Productos?: ProductosUpdateOneRequiredWithoutDetallesVentasInput
  }

  export type DetallesVentasUncheckedUpdateWithoutVentaInput = {
    id_detalleVenta?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type EnviosUpdateWithoutVentaInput = {
    num_rastreo?: StringFieldUpdateOperationsInput | string
    EmpresasEnvio?: EmpresasEnvioUpdateOneRequiredWithoutEnviosInput
  }

  export type EnviosUncheckedUpdateWithoutVentaInput = {
    id_envio?: IntFieldUpdateOperationsInput | number
    num_rastreo?: StringFieldUpdateOperationsInput | string
    id_empresaEnvio?: IntFieldUpdateOperationsInput | number
  }

  export type CarritoItemCreateManyCarritoInput = {
    id_producto: number
    cantidad: number
  }

  export type CarritoItemUpdateWithoutCarritoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    Productos?: ProductosUpdateOneRequiredWithoutCarritoItemInput
  }

  export type CarritoItemUncheckedUpdateWithoutCarritoInput = {
    id_itemCarrito?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}